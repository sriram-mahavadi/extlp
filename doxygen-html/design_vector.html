<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ExtLP: Vector</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ExtLP
   &#160;<span id="projectnumber">1.0-dev</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('design_vector.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Vector </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="author"><dt><b>Author:</b></dt><dd>Roman Dementiev (2006)</dd></dl>
<p>The most universal STXXL container is stxxl::vector. Vector is an array whose size can vary dynamically. The implementation of stxxl::vector is similar to the LEDA-SM array <a class="el" href="citelist.html#CITEREF_CraMeh99">CraMeh99</a>. The content of a vector is striped block-wise over the disks, using an assignment strategy given as a template parameter. Some of the blocks are cached in a vector cache of fixed size (also a parameter). The replacement of cache blocks is controlled by a specified page-replacement strategy. STXXL has implementations of LRU and random replacement strategies. The user can provide his/her own strategy as well. The stxxl::vector has STL-compatible Random Access Iterators.</p>
<ul>
<li>One random access costs <img class="formulaInl" alt="$ \mathcal{O}(1) $" src="form_0.png"/> I/Os in the worst case. Same for insertion and removal at the end.</li>
<li>Sequential scanning of the vector costs <img class="formulaInl" alt="$ \mathcal{O}(1/DB) $" src="form_1.png"/> amortized I/Os per vector element.</li>
</ul>
<h2><a class="anchor" id="design_vector_architecture"></a>
The Architecture of stxxl::vector</h2>
<p>The stxxl::vector is organized as a collection of blocks residing on the external storage media (parallel disks). Access to the external blocks is organized through the fully associative <em>cache</em> which consist of some fixed amount of in-memory pages (The page is a collection of consecutive blocks. The number of blocks in the page is constant.). The schema of stxxl::vector is depicted in the following figure. When accessing an element the implementation of stxxl::vector access methods (<code>[]</code>operator, <code>push_back</code>, etc.) first checks whether the page to which the requested element belongs is in the vector's cache. If it is the case the reference to the element in the cache is returned. Otherwise the page is brought into the cache (If the page of the element has not been touched so far, this step is skipped. To keep an eye on such situations there is a special flag for each page.). If there was no free space in the cache, then some page is to be written out. Vector maintains a <em>pager</em> object, that tells which page to kick out. STXXL provides LRU and random paging strategies. The most efficient and default one is LRU. For each page vector maintains the <em>dirty</em> flag, which is set when <em>non-constant</em> reference to one of the page's elements was returned. The dirty flag is cleared each time when the page is read into the cache. The purpose of the flag is to track whether any element of the page is modified and therefore the page needs to be written to the disk(s) when it has to be evicted from the cache.</p>
<div class="image">
<img src="vector_architecture_small.png" alt="vector_architecture_small.png"/>
<div class="caption">
The schema of stxxl::vector that consists of ten external memory pages and has a cache with the capacity of four pages. The first cache page is mapped to external page 1, the second page is mapped to external page 8, and the fourth cache page is mapped to page 5. The third page is not assigned to any external memory page.</div></div>
<p> In the worst case scenario when vector elements are read/written in the random order each access takes 2 x blocks_per_page I/Os. The factor <em>two</em> shows up here because one has to write the replaced from cache page and read the required one). However the scanning of the array costs about <img class="formulaInl" alt="$ n/B $" src="form_2.png"/> I/Os using constant vector iterators or const reference to the vector, where <em>n</em> is the number of elements to read or write (read-only access). Using non-const vector access methods leads to <img class="formulaInl" alt="$ 2 \times n/B $" src="form_3.png"/> I/Os because every page becomes dirty when returning a non const reference. If one needs only to sequentially write elements to the vector in <img class="formulaInl" alt="$ n/B $" src="form_2.png"/> I/Os the currently fastest method is stxxl::generate. Sequential writing to an untouched before vector (e.g. when created using stxxl::vector(size_type n) constructor.) or alone adding elements at the end of the vector, using the push_back(const T&amp;) method, leads also to <img class="formulaInl" alt="$ n/B $" src="form_2.png"/> I/Os.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// Example of use</span>
stxxl::vector&lt;int&gt; V;
V.push_back(3);
assert(V.size() == 1 &amp;&amp; V.capacity() &gt;= 1 &amp;&amp; V[0] == 3);
</pre></div><h2><a class="anchor" id="design_vector_generator"></a>
stxxl::VECTOR_GENERATOR</h2>
<p>Besides the type of the elements stxxl::vector has many other template parameters (block size, number of blocks per page, pager class, etc.). To make the configuration of the vector type easier STXXL provides special type generator template meta programs for its containers.</p>
<p>The meta-program for stxxl::vector is called stxxl::VECTOR_GENERATOR.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// Example of use</span>
<span class="keyword">typedef</span> stxxl::VECTOR_GENERATOR&lt;int&gt;::result vector_type;
vector_type V;
V.push_back(3);
assert(V.size() == 1 &amp;&amp; V.capacity() &gt;= 1 &amp;&amp; V[0] == 3);
</pre></div><p>The stxxl::VECTOR_GENERATOR has the following template parameters:</p>
<p>### Notes:</p>
<ul>
<li>All blocks of a page are read and written from/to disks together. Therefore to increase the I/O bandwidth, it is recommended to set the PageSize parameter to multiple of <em>D</em>.</li>
</ul>
<ul>
<li>Memory consumption of constructed vector is BlockSize x CachePages x PageSize bytes (see below).</li>
</ul>
<ul>
<li>The configured vector type is available as <a class="el" href="structVECTOR__GENERATOR.html#a8948fb8e7364462b40029e1ec4bf7c7c">VECTOR_GENERATOR&lt;&gt;::result</a>.</li>
</ul>
<ul>
<li>Since there are defaults for the last five of the parameters, it is not necessary to specify them all.</li>
</ul>
<ul>
<li>Supported parallel disk assignment strategies: strategy | identifier ------------------ | ---------- striping | striping simple randomized | SR fully randomized | FR randomized cycling | RC</li>
</ul>
<ul>
<li>Supported paging strategies: strategy | identifier ------------------- | ------ random | random least recently used | lru</li>
</ul>
<p>### Examples:</p>
<ul>
<li><a class="el" href="structVECTOR__GENERATOR.html#a8948fb8e7364462b40029e1ec4bf7c7c">VECTOR_GENERATOR&lt;double&gt;::result</a> -- external vector of <b>double's</b> with four blocks per page, the cache with eight pages, 2 MiB blocks, Random Allocation and lru cache replacement strategy.</li>
</ul>
<ul>
<li><a class="el" href="structVECTOR__GENERATOR.html#a8948fb8e7364462b40029e1ec4bf7c7c">VECTOR_GENERATOR&lt;double,8&gt;::result</a> -- external vector of <b>double's</b> , with <b>eight</b> blocks per page, the cache with eight pages, 2 MiB blocks, Random Allocation and lru cache replacement strategy</li>
</ul>
<ul>
<li><a class="el" href="structVECTOR__GENERATOR.html#a8948fb8e7364462b40029e1ec4bf7c7c">VECTOR_GENERATOR&lt;double,8,2,524288,SR&gt;::result</a> -- external vector of <b>double's</b>, with <b>eight</b> blocks per page, the cache with <b>two</b> pages, <b>512</b> KiB blocks, <b>Simple Randomized</b> allocation and lru cache replacement strategy</li>
</ul>
<h2><a class="anchor" id="design_vector_memory"></a>
Internal Memory Consumption of stxxl::vector</h2>
<p>The cache of stxxl::vector largely dominates in its internal memory consumption. Other members consume very small fraction of stxxl::vector's memory even when the vector size is large. Therefore, the internal memory consumption of stxxl::vector can be estimated as <img class="formulaInl" alt="$ BlockSize \times CachePages \times PageSize $" src="form_4.png"/> bytes.</p>
<h2><a class="anchor" id="design_vector_notes"></a>
More Notes</h2>
<ul>
<li>In opposite to STL, stxxl::vector's iterators do not get invalidated when the vector is resized or reallocated.</li>
</ul>
<ul>
<li>Dereferencing a non-const iterator makes the page of the element to which the iterator points to <b>dirty</b>. This causes the page to be written back to the disks(s) when the page is to be kicked off from the cache (additional write I/Os). If you do not want this behavior, use const iterators instead. See following example: <div class="fragment"><pre class="fragment">vector_type V;
<span class="comment">// ... fill the vector here</span>

vector_type::iterator iter = V.begin();
<span class="comment">// ... advance the iterator</span>
a = *iter; <span class="comment">// causes write I/Os, although *iter is not changed</span>

vector_type::const_iterator citer = V.begin();
<span class="comment">// ... advance the iterator</span>
a = *citer; <span class="comment">// read-only access, causes no write I/Os</span>
*citer = b; <span class="comment">// does not compile, citer is const</span>
</pre></div></li>
</ul>
<ul>
<li>Non const <code>operator</code>[] makes the page of the element <b>dirty</b>. This causes the page to be written back to the disks(s) when the page is to be kicked off from the cache (additional write I/Os). If you do not want this behavior, use const <code>operator</code>[]. For that you need to access the vector via a const reference to it. Example: <div class="fragment"><pre class="fragment">vector_type V;
<span class="comment">// ... fill the vector here</span>

a = V[index]; <span class="comment">// causes write I/Os, although V[index] is not changed</span>

<span class="keyword">const</span> vector_type &amp; CV = V; <span class="comment">// const reference to V</span>
a = CV[index]; <span class="comment">// read-only access, can cause no write I/Os</span>
CV[index] = b; <span class="comment">// does not compile, CV is const</span>
</pre></div> This issue also concerns <code>front()</code> and <code>back()</code> methods. </li>
</ul>
</div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="design.html">Design of STXXL</a>      </li>
      <li class="navelem"><a class="el" href="design_stl.html">The STL-User Layer</a>      </li>
      <li class="navelem"><a class="el" href="design_stl_containers.html">STXXL Containers</a>      </li>

    <li class="footer">Generated on Sat Jun 14 2014 01:55:17 for ExtLP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
