<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ExtLP: Algorithm Pipelining</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ExtLP
   &#160;<span id="projectnumber">1.0-dev</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('design_pipeline.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Algorithm Pipelining </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="author"><dt><b>Author:</b></dt><dd>Roman Dementiev (2006)</dd></dl>
<p>The pipelined processing technique is very well known in the database world <a class="el" href="citelist.html#CITEREF_SKS01">SKS01</a>. This page describes the abstract design of the stream package, see also <a class="el" href="tutorial_stream.html">Tutorial for the Stream Package</a>.</p>
<p>Usually, the interface of an external memory algorithm assumes that it reads the input from (an) external memory container(s) and writes output into (an) external memory container(s). The idea of pipelining is to equip the external memory algorithms with a new interface that allows them to feed the output as a data stream directly to the algorithm that consumes the output, rather than writing it to the external memory first. Logically, the input of an external memory algorithm does not have to reside in the external memory, rather, it could be a data stream produced by another external memory algorithm.</p>
<p>Many external memory algorithms can be viewed as a data flow through a directed acyclic graph <img class="formulaInl" alt="$ G $" src="form_72.png"/> with node set <img class="formulaInl" alt="$ V = F \cup S \cup R $" src="form_73.png"/> and edge set <img class="formulaInl" alt="$ E $" src="form_74.png"/>. The <b>file nodes</b> <img class="formulaInl" alt="$ F $" src="form_75.png"/> represent physical data sources and data sinks, which are stored on disks (e.g. in the external memory containers of the STL-user layer). A file node writes or/and reads one stream of elements. The <b>streaming nodes</b> <img class="formulaInl" alt="$ S $" src="form_76.png"/> read zero, one or several streams and output zero, one or several new streams. Streaming nodes are equivalent to scan operations in non-pipelined external memory algorithms. The difference is that non-pipelined conventional scanning needs a linear number of I/Os, whereas streaming nodes usually do not perform any I/O, unless a node needs to access external memory data structures (stacks, priority queues, etc.). The sorting nodes <img class="formulaInl" alt="$ R $" src="form_77.png"/> read a stream and output it in a sorted order. Edges <img class="formulaInl" alt="$ E $" src="form_74.png"/> in the graph <img class="formulaInl" alt="$ G $" src="form_72.png"/> denote the directions of data flow between nodes. The question "When is a pipelined execution of the computations in a data flow graph \f$ G \f$ possible in an I/O-efficient way?" is analyzed in <a class="el" href="citelist.html#CITEREF_DKMS05">DKMS05</a>.</p>
<h2><a class="anchor" id="design_pipeline_streaming"></a>
Streaming Layer</h2>
<p>The streaming layer provides a framework for the <b>pipelined</b> processing of large sequences. Many external memory algorithms implemented with the STXXL streaming layer save a factor of at least two in I/Os. To the best of our knowledge we are the first who apply the pipelining method systematically in the domain of external memory algorithms. We introduce it in the context of an external memory software library.</p>
<p>In STXXL, all data flow node implementations have an <code>stream</code> interface which is similar to the STL Input iterators (Not be confused with the stream interface of the C++ <code>iostream</code> library.). As an input iterator, an <code>stream</code> object may be dereferenced to refer to some object and may be incremented to proceed to the next object in the stream. The reference obtained by dereferencing is read-only and must be convertible to the <code>value_type</code> of the <code>stream</code>. The concept of the <code>stream</code> also defines a boolean member function <code>empty()</code> which returns <code>true</code> iff the end of the stream is reached.</p>
<p>Now we tabulate the valid expressions and the expression semantics of the <code>stream</code> concept in the style of the STL documentation.</p>
<p>### Notation</p>
<p>Symbol | Semantics | --------------------- | --------------------------------------------- | <code>X, X1,...,Xn</code> | A type that is a model of the <code>stream</code> | <code>T</code> | The value type of <code>X</code> | <code>s, s1,...,sn</code> | Object of type <code>X, X1,...,Xn</code> | <code>t</code> | Object of type <code>T</code> |</p>
<p>### Valid expressions</p>
<p>Name | Expression | Type requirements | Return type | ------------------- | ----------------------- | ------------------------------------------------------------- | ------------------------- | Constructor | <code>X s(s1,...,sn)</code> | <code>s1,....,sn</code> are convertible to <code>X1&amp;,...,Xn&amp;</code> | | Dereference | <code>*s</code> | | Convertible to <code>T</code> | Member access | <code>s-&gt;m</code> | <code>T</code> is a type for which <code>t.m</code> is defined | | Preincrement | <code>++s</code> | | <code>X&amp;</code> | End of stream check | <code>(*s).empty()</code> | | <code>bool</code> |</p>
<p>### Expression semantics</p>
<p>Name | Expression | Precondition | Semantics | Postcondition | ------------- | ----------------------- | ----------------------------------------------------------- | --------------------------------| ------------------------------------------- | Constructor | <code>X s(s1,...,sn)</code> | <code>s1,...,sn</code> are the <em>n</em> input streams of <code>s</code> | | | Dereference | <code>*s</code> | <code>s</code> is incrementable | | | Member access | <code>s-&gt;m</code> | <code>s</code> is incrementable | Equivalent to <code>(*s).m</code> | | Preincrement | <code>++s</code> | <code>s</code> is incrementable | | <code>s</code> is incrementable or past-the-end |</p>
<p>The binding of a <code>stream</code> object to its input streams (incoming edges in a data flow graph <img class="formulaInl" alt="$ G $" src="form_72.png"/>) happens at compile time, i.e. statically. The other approach would be to allow binding at running time using the C++ virtual function mechanism. However this would result in a severe performance penalty because most C++ compilers are not able to inline virtual functions. To avoid this disadvantage, we follow the static binding approach using C++ templates. For example, assuming that streams <code>s1,...,sn</code> are already constructed, construction of stream <code>s</code> with constructor <code>X::X(X1&amp; s1,..., Xn&amp; sn)</code> will bind <code>s</code> to its inputs <code>s1,...,sn</code>.</p>
<p>After creating all node objects, the computation starts in a "lazy" fashion, first trying to evaluate the result of the topologically latest node. The node reads its intermediate input nodes, element by element, using the dereference and increment operator of the <code>stream</code> interface. The input nodes proceed in the same way, invoking the inputs needed to produce an output element. This process terminates when the result of the topologically latest node is computed. This style of pipelined execution scheduling is I/O efficient, it allows to keep the intermediate results in-memory without needing to store them in external memory.</p>
<p>The Streaming layer of the STXXL library offers generic classes which implement the functionality of sorting, file, and streaming nodes:</p>
<ul>
<li>File nodes: Function streamify() serves as an adaptor that converts a range of ForwardIterators into a compatible <code>stream</code>. Since iterators of stxxl::vector are RandomAccessIterators, streamify() can be used to read external memory. The set of (overloaded) materialize functions implement data sink nodes, they flush the content of a STXXL stream object to an output iterator.</li>
</ul>
<p>The library also offers specializations of streamify() and stream::materialize for stxxl::vector, which are more efficient than the generic implementations due to the support of overlapping between I/O and computation.</p>
<ul>
<li><a class="anchor" id="design_stream_pipesort"></a>Sort nodes: The Stream layer sort class is a generic pipelined sorter which has the interface of an <code>stream</code>. The input of the sorter may be an object complying to the <code>stream</code> interface. As the STL-user layer sorter, the pipelined sorter is an implementation of parallel disk merge sort <a class="el" href="citelist.html#CITEREF_DemSan03">DemSan03</a> that overlaps I/O and computation.</li>
</ul>
<p>The implementation of stream::sort relies on two classes that encapsulate the two phases of the algorithm: sorted run formation (class runs_creator) and run merging (runs_merger). The separate use of these classes breaks the pipelined data flow: the runs_creator must read the entire input to compute the sorted runs. This facilitates an efficient implementation of loops and recursions: the input for the next iteration or recursion can be the sorted runs stored on disks ( <a class="el" href="citelist.html#CITEREF_JensThesis">JensThesis</a> <a class="el" href="citelist.html#CITEREF_DKMS05">DKMS05</a>).</p>
<p>The templated class runs_creator has several specializations which have input interfaces different from the <code>stream</code> interface: a specialization where elements to be sorted are <code>push_back</code>'ed into the runs_creator object and a specialization that accepts a set of presorted sequences. All specializations are compatible with the runs_merger.</p>
<ul>
<li>Streaming nodes: In general, most of the implementation effort for algorithms with the streaming layer goes to the streaming nodes. The STXXL library exposes generic classes that help to accelerate coding the streaming node classes. For example stream::transform is similar to the std::transform algorithm: it reads <em>n</em> input streams <code>s1,...,sn</code> and returns the result of a user-given <code>n</code>-ary function object <code>functor(*s1,...,*sn)</code> as the next element of the output stream until one of the input streams gets empty.</li>
</ul>
<p>As mentioned above, STXXL allows streaming nodes to have more than one output. In this case, only one output of a streaming node can have the <code>stream</code> interface (it is an iterator). The other outputs can be passed to other nodes using a "push-item" interface. Such an interface have file nodes (e.g. the method <code>push_back</code> of stxxl::vector) and sorting nodes (<code>push_back</code>-specializations). Streaming nodes do not have such methods by definition, however, it is always possible to reimplement all streaming nodes between sorting and/or file nodes as a single streaming node that will <code>push_back</code> the output elements to the corresponding sorting/file nodes. </p>
</div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="design.html">Design of STXXL</a>      </li>

    <li class="footer">Generated on Sat Jun 14 2014 01:55:17 for ExtLP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
