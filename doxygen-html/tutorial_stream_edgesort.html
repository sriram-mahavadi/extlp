<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ExtLP: Generating Random Graphs using Streams</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ExtLP
   &#160;<span id="projectnumber">1.0-dev</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('tutorial_stream_edgesort.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Generating Random Graphs using Streams </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="author"><dt><b>Author:</b></dt><dd>Roman Dementiev (2007)</dd></dl>
<p>This page gives an example of how an application using "traditional" containers and algorithms can be converted into using pipelines streaming.</p>
<p>The purpose of our example is to generate a huge random directed graph in a sorted edge array representation, i.e. the edges in the edge array must be sorted lexicographically. The definitions of the classes <code>edge</code>, <code>random_edge</code> and <code>edge_cmp</code> are in the following code listing.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>edge { <span class="comment">// edge class</span>
    <span class="keywordtype">int</span> src, dst; <span class="comment">// nodes</span>
    edge() {}
    edge(<span class="keywordtype">int</span> src_, <span class="keywordtype">int</span> dst_): src(src_), dst(dst_) {}
    <span class="keywordtype">bool</span> <a class="code" href="group__stlcont__vector.html#ga46ffdcb7d5820e4d71a8cd65a2940834">operator == </a>(<span class="keyword">const</span> edge &amp; b)<span class="keyword"> const </span>{
        <span class="keywordflow">return</span> src == b.src &amp;&amp; dst == b.dst;
    }
};
<span class="keyword">struct </span>random_edge { <span class="comment">// random edge generator functor</span>
    edge operator () ()<span class="keyword"> const </span>{
        edge Edge(random() - 1, random() - 1);
        <span class="keywordflow">while</span>(Edge.dst == Edge.src)
             Edge.dst = random() - 1 ; <span class="comment">// no self-loops</span>
        <span class="keywordflow">return</span> Edge;
    }
};
<span class="keyword">struct </span>edge_cmp { <span class="comment">// edge comparison functor</span>
    edge min_value()<span class="keyword"> const </span>{
        <span class="keywordflow">return</span> edge(std::numeric_limits&lt;int&gt;::min(),0); };
    edge max_value()<span class="keyword"> const </span>{
        <span class="keywordflow">return</span> edge(std::numeric_limits&lt;int&gt;::max(),0); };
    <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> edge &amp; a,
                      <span class="keyword">const</span> edge &amp; b)<span class="keyword"> const </span>{
        <span class="keywordflow">return</span> a.src &lt; b.src || (a.src == b.src &amp;&amp; a.dst &lt; b.dst);
    }
};
</pre></div><p>A straightforward procedure to generate the graph is to: 1) generate a sequence of random edges, 2) sort the sequence, 3) remove duplicate edges from it. If we ignore definitions of helper classes the STL/STXXL code of the algorithm implementation is only five lines long:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// create vector</span>
stxxl::vector&lt;edge&gt; ExtEdgeVec(10000000000ULL);
<span class="comment">// generate random edges</span>
stxxl::generate(ExtEdgeVec.begin(), ExtEdgeVec.end(), random_edge());
<span class="comment">// sort edges by source vertex</span>
stxxl::sort(ExtEdgeVec.begin(), ExtEdgeVec.end(), edge_cmp(), 512*1024*1024);
<span class="comment">// unify equal edges</span>
stxxl::vector&lt;edge&gt;::iterator NewEnd =  std::unique(ExtEdgeVec.begin(), ExtEdgeVec.end());
ExtEdgeVec.resize(NewEnd - ExtEdgeVec.begin());
</pre></div><p>Line 2 creates an STXXL external memory vector with 10 billion edges. Line 4 fills the vector with random edges (stxxl::generate from the STL is used). In the next line the STXXL external memory sorter sorts randomly generated edges using 512 megabytes of internal memory. The lexicographical order is defined by functor <code>my_cmp</code>, stxxl::sort also requires the comparison functor to provide upper and lower bounds for the elements being sorted. Line 8 deletes duplicate edges in the external memory vector with the help of the STL <code>std::unique</code> algorithm. The <code>NewEnd</code> vector iterator points to the right boundary of the range without duplicates. Finally (in the last line), we chop the vector at the <code>NewEnd</code> boundary.</p>
<p>Now we count the number of I/Os performed by this example: external vector construction takes no I/Os; filling with random values requires a scan --- <img class="formulaInl" alt="$ N/DB $" src="form_70.png"/> I/Os; sorting will take <img class="formulaInl" alt="$ 4N/DB $" src="form_69.png"/> I/Os; duplicate removal needs no more than <img class="formulaInl" alt="$ 2N/DB $" src="form_71.png"/> I/Os; chopping a vector is I/O-free. The total number of I/Os is <img class="formulaInl" alt="$ 7N/DB $" src="form_82.png"/>.</p>
<p># Pipelined random graph generation</p>
<p>Now we <b>"pipeline"</b> the random graph generation example shown in the previous chapter. The data flow graph of the algorithm is presented in the following figure:</p>
<div class="image">
<img src="pipeline_randomgraph_small.png" alt="pipeline_randomgraph_small.png"/>
<div class="caption">
Pipeline of Random Graph Generator</div></div>
<p> The following code listing shows the pipelined code of the algorithm, the definitions of <code>edge</code>, <code>random_edge</code>, and <code>edge_cmp</code> are assumed to be available from the listing in the previous section.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>random_edge_stream {
    stxxl::int64 counter;
    edge current;
    random_edge_stream();
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> edge value_type;
    random_edge_stream(stxxl::int64 elements)
        : counter(elements), current(random_edge()())
    { }
    <span class="keyword">const</span> edge &amp; operator * ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> current; }
    <span class="keyword">const</span> edge * operator -&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;current; }
    random_edge_stream &amp; operator ++ ()
    {
        --counter;
        current = random_edge()();
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }
    <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> counter == 0; }
};

random_edge_stream RandomStream(10000000000ULL);
<span class="keyword">typedef</span> stxxl::stream::sort&lt;random_edge_stream, edge_cmp&gt; sorted_stream;
sorted_stream SortedStream(RandomStream, edge_cmp(), 512*1024*1024);
<span class="keyword">typedef</span> stxxl::stream::unique&lt;sorted_stream&gt; unique_stream_type;
unique_stream_type UniqueStream(SortedStream);
stxxl::vector&lt;edge&gt; ExtEdgeVec(10000000000ULL);
stxxl::vector&lt;edge&gt;::iterator NewEnd =
    stxxl::stream::materialize(UniqueStream, ExtEdgeVec.begin());
ExtEdgeVec.resize(NewEnd - ExtEdgeVec.begin());
</pre></div><p>Since the sorter of the streaming layer accepts an <code>stream</code> input, we do not need to output the random edges. Rather, we generate them on the fly. The <code>random_edge_stream</code> object (model of <code>stream</code>) supplies the sorter with a stream of random edges. We define the type of the sorter node as <code>sorted_stream</code>; it is parameterized by the type of the input stream and the type of the comparison function object. Then a <code>SortedStream</code> object is created and its input is attached to the <code>RandomStream</code> object's output. The internal memory consumption of the sorter stream object is limited to 512 MB. The <code>UniqueStream</code> object filters the duplicates in its input edge stream. The generic <code>stream::unique</code> stream class stems from the STXXL library. The stream::materialize function records the content of the <code>UniqueStream</code> into the external memory vector. As in the previous non-pipelined version, we cut the vector at the <code>NewEnd</code> boundary.</p>
<p>Let us count the number of I/Os the program performs: random edge generation by <code>RandomStream</code> costs no I/O; sorting in <code>SortedStream</code> needs to store the sorted runs and read them again to merge --- <img class="formulaInl" alt="$ 2N/DB $" src="form_71.png"/> I/Os; <code>UniqueStream</code> deletes duplicates on the fly, it does not need any I/O; and materializing the final output can cost up to <img class="formulaInl" alt="$ N/DB $" src="form_70.png"/> I/Os. All in all, the program only incurs <img class="formulaInl" alt="$ 3N/DB $" src="form_83.png"/> I/Os, compared to <img class="formulaInl" alt="$ 7N/DB $" src="form_82.png"/> for the non-pipelined code. </p>
</div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="tutorial.html">Tutorials and Examples</a>      </li>

    <li class="footer">Generated on Sat Jun 14 2014 01:55:17 for ExtLP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
