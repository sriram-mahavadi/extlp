<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ExtLP: Stack</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ExtLP
   &#160;<span id="projectnumber">1.0-dev</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('design_stack.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Stack </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="author"><dt><b>Author:</b></dt><dd>Roman Dementiev (2006)</dd></dl>
<p>The I/O efficient stack is perhaps the simplest external memory data structure. Stacks provide only restricted subset of sequence operations: insertion, removal, and inspection of the element at the top of the stack. Stacks are a "last in first out" (LIFO) data structures: the element at the top of a stack is the one that was most recently added. Stacks does not allow iteration through its elements.</p>
<p>The basic variant of EM stack keeps the top <em>k</em> elements in the main memory buffer, where <img class="formulaInl" alt="$ k \leq 2B $" src="form_5.png"/>. If the buffers get empty on a removal call, one block is brought from the disk to the buffers. Therefore at least <em>B</em> removals are required to make one I/O reading a block. Insertions cause no I/Os until the internal buffers get full. In this case to make space the first <em>B</em> elements are written to the disk. Thus a block write happens only after at least <em>B</em> insertions. If we choose the unit of disk transfer to be a multiple of <em>DB</em> (we denote it as a <em>page</em>), set the stack buffer size to <em>2D</em> pages, and evenly assign the blocks of a page to disks we obtain the following amortized running times of the basic operations of stxxl::stack</p>
<p>operation | internal work | I/O (amortized) -------------------- | ---------------------- | ------------------------- insertion at the end | <img class="formulaInl" alt="$ \mathcal{O}(1) $" src="form_0.png"/> | <img class="formulaInl" alt="$ \mathcal{O}(1/DB) $" src="form_1.png"/> removal at the end | <img class="formulaInl" alt="$ \mathcal{O}(1) $" src="form_0.png"/> | <img class="formulaInl" alt="$ \mathcal{O}(1/DB) $" src="form_1.png"/></p>
<p>The STXXL library contains four different variants of stacks, each implementation is specialized for a certain access pattern:</p>
<p>1. The stxxl::normal_stack is a general purpose implementation which is the best if the access pattern to the stack is an irregular mix of push'es and pop's, i.e. the stack grows and shrinks without a certain rule.</p>
<p>2. The stxxl::grow_shrink stack is a stack that is optimized for an access pattern where the insertions are (almost) not intermixed with the removals, and/or vice versa, the removals are (almost) not intermixed with the insertions. In short, the stack first grows to its maximal size, then shrinks, then grow again and so on, a pattern which can be described by <img class="formulaInl" alt="$ (push^{r_i}, push^{r_j})^k $" src="form_6.png"/> with <img class="formulaInl" alt="$ 1 \leq j \leq k $" src="form_7.png"/> and large values for <img class="formulaInl" alt="$ r_i $" src="form_8.png"/> and <img class="formulaInl" alt="$ r_j $" src="form_9.png"/>.</p>
<p>3. stxxl::grow_shrink2 stack is a "grow-shrink" stack that allows the use of common prefetch and write buffer pools. The pools are shared between several "grow-shrink" stacks.</p>
<p>4. stxxl::migrating stack is a stack that migrates from internal memory to external memory when its size exceeds a certain threshold (determined by parameter migrating_critical_size)</p>
<p>To make use of stxxl::stack, one can use the generator template stxxl::STACK_GENERATOR which expects the parameters from left to right as shown in the table below.</p>
<h2><a class="anchor" id="design_stack_normal"></a>
stxxl::normal_stack</h2>
<p>The stxxl::normal_stack is a general purpose implementation of the external memory stack. The stack has two pages, the size of the page in blocks is a configuration constant and can be given as a template parameter. The implementation of the methods follows the description given in the previous section.</p>
<p>## Internal Memory Consumption of stxxl::normal_stack</p>
<p>The cache of stxxl::normal_stack largely dominates in its internal memory consumption. Other members consume very small fraction of stxxl::normal_stack's memory even when the stack size is large. Therefore, the internal memory consumption of stxxl::normal_stack can be estimated as <img class="formulaInl" alt="$ 2 \times BlockSize \times PageSize $" src="form_10.png"/> bytes, where <img class="formulaInl" alt="$ BlockSize $" src="form_11.png"/> is the block size and <img class="formulaInl" alt="$ PageSize $" src="form_12.png"/> is the page size in blocks (see <a class="el" href="design_stack.html">Stack</a>).</p>
<h2><a class="anchor" id="design_stack_grow_shrink"></a>
stxxl::grow_shrink_stack</h2>
<p>The stxxl::grow_shrink_stack specialization is optimized for an access pattern where the insertions are (almost) not intermixed with the removals, and/or vice versa, the removals are (almost) not intermixed with the insertions. In other words the stack first grows to its maximal size, then it shrinks, then it might again grow, then shrink, and so forth, i.e. the pattern is <img class="formulaInl" alt="$ (push^{i_j}pop^{r_j})^k $" src="form_13.png"/>, where <img class="formulaInl" alt="$ k \in N $" src="form_14.png"/>, <img class="formulaInl" alt="$ 1 \leq j \leq k $" src="form_7.png"/>, and <img class="formulaInl" alt="$ i_j $" src="form_15.png"/>, <img class="formulaInl" alt="$ r_j $" src="form_9.png"/> are <em>large</em>. The implementation efficiently exploits the knowledge of the access pattern that allows <b>prefetching</b> the blocks beforehand while the stack shrinks and <b>buffered writing</b> while the stack grows. Therefore the <b>overlapping</b> of I/O and computation is possible.</p>
<p>## Internal Memory Consumption of stxxl::grow_shrink_stack</p>
<p>The cache of stxxl::grow_shrink_stack largely dominates in its internal memory consumption. Other members consume very small fraction of stxxl::grow_shrink_stack's memory even when the stack size is large. Therefore, the internal memory consumption of stxxl::grow_shrink_stack can be estimated as <img class="formulaInl" alt="$ 2 \times BlockSize \times PageSize $" src="form_10.png"/> bytes, where <img class="formulaInl" alt="$ BlockSize $" src="form_11.png"/> is the block size and <img class="formulaInl" alt="$ PageSize $" src="form_12.png"/> is the page size in blocks (see <a class="el" href="design_stack.html">Stack</a>).</p>
<p>## Members of stxxl::grow_shrink_stack</p>
<p>The stxxl::grow_shrink_stack has the same set of members as the stxxl::normal_stack. The running times of stxxl::grow_shrink_stack are the same as stxxl::normal_stack except that when the stack switches from growing to shrinking (or from shrinking to growing) <img class="formulaInl" alt="$ PageSize $" src="form_12.png"/> I/Os can be spent additionally in the worst case. (This is for the single disk setting, if the page is perfectly striped over parallel disk the number of I/Os is <img class="formulaInl" alt="$ PageSize \cdot D $" src="form_16.png"/>.)</p>
<h2><a class="anchor" id="design_stack_grow_shrink2"></a>
stxxl::grow_shrink_stack2</h2>
<p>The stxxl::grow_shrink_stack2 is optimized for the same kind of access pattern as stxxl::grow_shrink_stack. The difference is that each instance of stxxl::grow_shrink_stack uses an own internal buffer to overlap I/Os and computation, but stxxl::grow_shrink_stack2 is able to share the buffers from the pool used by several stacks.</p>
<p>## Internal Memory Consumption of stxxl::grow_shrink_stack2</p>
<p>Not counting the memory consumption of the shared blocks from the pools, the stack alone consumes about <img class="formulaInl" alt="$ BlockSize $" src="form_11.png"/> bytes. It has a cache that consists of only a single block.</p>
<p>## Members of stxxl::grow_shrink_stack2</p>
<p>The stxxl::grow_shrink_stack2 has almost the same set of members as the stxxl::normal_stack, except that it does not have the default constructor. The stxxl::grow_shrink_stack2 requires prefetching and write pool objects (see stxxl::prefetch_pool, stxxl::write_pool and stxxl::read_write_pool) to be specified in the creation time.</p>
<p>Consequently, the constructor requires a read_write_pool for prefetching and buffered writing. But it also has a second parameter, which tells how many blocks from the prefetching pool are used, this is called "prefetch_aggressiveness".</p>
<h2><a class="anchor" id="design_stack_grow_migrating"></a>
stxxl::migrating_stack</h2>
<p>The stxxl::migrating_stack is a stack that migrates from internal memory to external when its size exceeds a certain threshold (template parameter). The implementation of internal and external memory stacks can be arbitrary and given as a template parameters.</p>
<p>## Internal Memory Consumption of stxxl::migrating_stack</p>
<p>The stxxl::migrating_stack memory consumption depends on the memory consumption of the stack implementations given as template parameters. The current state is internal (external), the stxxl::migrating_stack consumes almost exactly the same space as internal (external) memory stack implementation. (The stxxl::migrating_stack needs only few pointers to maintain the switching from internal to external memory implementations.)</p>
<p>## Members of stxxl::migrating_stack</p>
<p>The stxxl::migrating_stack extends the member set of stxxl::normal_stack. Additionally, there are stxxl::migrating_stack::internal() and stxxl::migrating_stack::external(), which return true if the currently used implementation is internal or external.</p>
<h2><a class="anchor" id="design_stack_generator"></a>
stxxl::STACK_GENERATOR</h2>
<p>To provide an easy way to choose and configure the stack implementations, STXXL offers a template meta program called stxxl::STACK_GENERATOR.</p>
<p>The stxxl::STACK_GENERATOR has the following template parameters:</p>
<p>## Examples:</p>
<ul>
<li>STACK_GENERATOR&lt;double&gt;::result external stack of <code>double's</code> </li>
<li>STACK_GENERATOR&lt;double,internal&gt;::result internal stack of <code>double's</code> </li>
<li>STACK_GENERATOR&lt;double,external,grow_shrink&gt;::result external grow-shrink stack of <code>double's</code> </li>
<li>STACK_GENERATOR&lt;double,migrating,grow_shrink&gt;::result migrating grow-shrink stack of <code>double's</code>, internal implementation is <code>std::stack&lt;double&gt;</code> </li>
<li>STACK_GENERATOR&lt;double,migrating,grow_shrink,1,512*1024&gt;::result migrating grow-shrink stack of <code>double's</code> with 1 block per page and block size 512 KiB (total memory occupied = 1 MiB)</li>
</ul>
<p>## Example for stxxl::grow_shrink_stack2</p>
<p>TODO-df : but use read_write_pool instead of the two pools.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> STACK_GENERATOR&lt;int,external,grow_shrink2&gt;::result stack_type;
<span class="keyword">typedef</span> stack_type::block_type block_type;

stxxl::prefetch_pool p_pool(10); <span class="comment">// 10 read buffers</span>
stxxl::write_pool w_pool(6);     <span class="comment">// 6 write buffers</span>
stack_type S(p_pool,w_pool,0);   <span class="comment">// no read buffers used</span>

<span class="keywordflow">for</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> i = 0; i &lt; max_value; ++i)
    S.push(i);

S.set_prefetch_aggressiveness(5);

<span class="comment">/* give a hint that we are going to shrink the stack from now on,</span>
<span class="comment">always prefetch 5 buffers beforehand */</span>

<span class="keywordflow">for</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> i = 0; i &lt; max_value; ++i)
    S.pop();

S.set_prefetch_aggressiveness(0);
<span class="comment">// stop prefetching</span>
</pre></div> </div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="design.html">Design of STXXL</a>      </li>
      <li class="navelem"><a class="el" href="design_stl.html">The STL-User Layer</a>      </li>
      <li class="navelem"><a class="el" href="design_stl_containers.html">STXXL Containers</a>      </li>

    <li class="footer">Generated on Sat Jun 14 2014 01:55:17 for ExtLP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
