<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ExtLP: local/deprecated/ExtStxxlVector.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ExtLP
   &#160;<span id="projectnumber">1.0-dev</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('ExtStxxlVector_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">local/deprecated/ExtStxxlVector.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="ExtStxxlVector_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* </span>
<a name="l00002"></a>00002 <span class="comment"> * File:   ExtStxxlVector.h</span>
<a name="l00003"></a>00003 <span class="comment"> * Author: Sriram Mahavadi</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * Created on 25 April, 2014, 4:01 PM</span>
<a name="l00006"></a>00006 <span class="comment"> */</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="preprocessor">#ifndef EXTSTXXLVECTOR_H</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span><span class="preprocessor">#define EXTSTXXLVECTOR_H</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span>
<a name="l00011"></a>00011 <span class="comment">/***************************************************************************</span>
<a name="l00012"></a>00012 <span class="comment"> *  include/stxxl/bits/containers/vector.h</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> *  Part of the STXXL and EXTL. See http://stxxl.sourceforge.net</span>
<a name="l00015"></a>00015 <span class="comment"> *  </span>
<a name="l00016"></a>00016 <span class="comment"> *  Copyright (C) 2002-2008 Roman Dementiev &lt;dementiev@mpi-sb.mpg.de&gt;</span>
<a name="l00017"></a>00017 <span class="comment"> *  Copyright (C) 2007-2009 Johannes Singler &lt;singler@ira.uka.de&gt;</span>
<a name="l00018"></a>00018 <span class="comment"> *  Copyright (C) 2008-2010 Andreas Beckmann &lt;beckmann@cs.uni-frankfurt.de&gt;</span>
<a name="l00019"></a>00019 <span class="comment"> *  Copyright (C) 2013 Timo Bingmann &lt;tb@panthema.net&gt;</span>
<a name="l00020"></a>00020 <span class="comment"> *  Copyright (C) 2014 Sriram Mahavadi &lt; sriram.mahavadi@gmail.com &gt;</span>
<a name="l00021"></a>00021 <span class="comment"> * </span>
<a name="l00022"></a>00022 <span class="comment"> *  Distributed under the Boost Software License, Version 1.0.</span>
<a name="l00023"></a>00023 <span class="comment"> *  (See accompanying file LICENSE_1_0.txt or copy at</span>
<a name="l00024"></a>00024 <span class="comment"> *  http://www.boost.org/LICENSE_1_0.txt)</span>
<a name="l00025"></a>00025 <span class="comment"> **************************************************************************/</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;queue&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;stxxl/vector&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;stxxl/bits/deprecated.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;stxxl/bits/io/request_operations.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;stxxl/bits/mng/block_manager.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;stxxl/bits/mng/typed_block.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;stxxl/bits/common/tmeta.h&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;stxxl/bits/containers/pager.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;stxxl/bits/common/is_sorted.h&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;stxxl/bits/mng/buf_istream.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;stxxl/bits/mng/buf_istream_reverse.h&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;stxxl/bits/mng/buf_ostream.h&gt;</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="comment">//STXXL_BEGIN_NAMESPACE</span>
<a name="l00045"></a>00045 
<a name="l00046"></a><a class="code" href="ExtStxxlVector_8h.html#adce24d9daba86c6533c3ade041e3da39">00046</a> <span class="preprocessor">#define STXXL_VERBOSE_VECTOR(msg) STXXL_VERBOSE1(&quot;vector[&quot; &lt;&lt; static_cast&lt;const void*&gt;(this) &lt;&lt; &quot;]::&quot; &lt;&lt; msg)</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00048"></a>00048 <span class="comment">//! \defgroup stlcont Containers</span>
<a name="l00049"></a>00049 <span class="comment">//! \ingroup stllayer</span>
<a name="l00050"></a>00050 <span class="comment">//! Containers with STL-compatible interface</span>
<a name="l00051"></a>00051 <span class="comment"></span>
<a name="l00052"></a>00052 <span class="comment"></span>
<a name="l00053"></a>00053 <span class="comment">//! \defgroup stlcont_vector vector</span>
<a name="l00054"></a>00054 <span class="comment">//! \ingroup stlcont</span>
<a name="l00055"></a>00055 <span class="comment">//! Vector and support classes</span>
<a name="l00056"></a>00056 <span class="comment">//! \{</span>
<a name="l00057"></a>00057 <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="keywordtype">size_t</span>ype, <span class="keywordtype">size_t</span>ype modulo2, <span class="keywordtype">size_t</span>ype modulo1&gt;
<a name="l00058"></a><a class="code" href="classdouble__blocked__index.html">00058</a> <span class="keyword">class </span><a class="code" href="classdouble__blocked__index.html">double_blocked_index</a> {
<a name="l00059"></a><a class="code" href="classdouble__blocked__index.html#af678f019e756b17ebffe76b5dd04a61c">00059</a>     <span class="keyword">static</span> <span class="keyword">const</span> size_type <a class="code" href="classdouble__blocked__index.html#af678f019e756b17ebffe76b5dd04a61c">modulo12</a> = modulo1 * modulo2;
<a name="l00060"></a>00060 
<a name="l00061"></a><a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">00061</a>     size_type <a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>;
<a name="l00062"></a><a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">00062</a>     stxxl::unsigned_type <a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a>, <a class="code" href="classdouble__blocked__index.html#abb35497b6e00614a996d4409de648cce">block2</a>, <a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a>;
<a name="l00063"></a>00063 <span class="comment"></span>
<a name="l00064"></a>00064 <span class="comment">    //! \invariant block2 * modulo12 + block1 * modulo1 + offset == pos &amp;&amp; 0 &lt;= block1 &amp;lt; modulo2 &amp;&amp; 0 &lt;= offset &amp;lt; modulo1</span>
<a name="l00065"></a><a class="code" href="classdouble__blocked__index.html#a7e9cbb1f73c863ec968d7880c1c6a528">00065</a> <span class="comment"></span>    <span class="keywordtype">void</span> <span class="keyword">set</span>(size_type <a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>) {
<a name="l00066"></a>00066         this-&gt;<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> = <a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>;
<a name="l00067"></a>00067         <a class="code" href="classdouble__blocked__index.html#abb35497b6e00614a996d4409de648cce">block2</a> = (stxxl::int_type)(<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> / <a class="code" href="classdouble__blocked__index.html#af678f019e756b17ebffe76b5dd04a61c">modulo12</a>);
<a name="l00068"></a>00068         <a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> -= <a class="code" href="classdouble__blocked__index.html#abb35497b6e00614a996d4409de648cce">block2</a> * <a class="code" href="classdouble__blocked__index.html#af678f019e756b17ebffe76b5dd04a61c">modulo12</a>;
<a name="l00069"></a>00069         <a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a> = (stxxl::int_type)(<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> / modulo1);
<a name="l00070"></a>00070         <a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a> = (stxxl::int_type)(<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> - <a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a> * modulo1);
<a name="l00071"></a>00071 
<a name="l00072"></a>00072         assert(<a class="code" href="classdouble__blocked__index.html#abb35497b6e00614a996d4409de648cce">block2</a> * modulo12 + <a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a> * modulo1 + <a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a> == this-&gt;<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>);
<a name="l00073"></a>00073         assert(<span class="comment">/* 0 &lt;= block1 &amp;&amp; */</span> <a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a> &lt; modulo2);
<a name="l00074"></a>00074         assert(<span class="comment">/* 0 &lt;= offset &amp;&amp; */</span> <a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a> &lt; modulo1);
<a name="l00075"></a>00075     }
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="keyword">public</span>:
<a name="l00078"></a><a class="code" href="classdouble__blocked__index.html#abe48987577f202cbcc45c6d1ee055fb4">00078</a>     <a class="code" href="classdouble__blocked__index.html#abe48987577f202cbcc45c6d1ee055fb4">double_blocked_index</a>() {
<a name="l00079"></a>00079         <span class="keyword">set</span>(0);
<a name="l00080"></a>00080     }
<a name="l00081"></a><a class="code" href="classdouble__blocked__index.html#aa839e571877ead51f82e830ac1ef2484">00081</a>     <a class="code" href="classdouble__blocked__index.html#aa839e571877ead51f82e830ac1ef2484">double_blocked_index</a>(size_type <a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>) {
<a name="l00082"></a>00082         <span class="keyword">set</span>(<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>);
<a name="l00083"></a>00083     }
<a name="l00084"></a><a class="code" href="classdouble__blocked__index.html#ac7c5d0943904181070477f508d5e4ce4">00084</a>     <a class="code" href="classdouble__blocked__index.html#ac7c5d0943904181070477f508d5e4ce4">double_blocked_index</a>(stxxl::unsigned_type <a class="code" href="classdouble__blocked__index.html#abb35497b6e00614a996d4409de648cce">block2</a>, stxxl::unsigned_type <a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a>, stxxl::unsigned_type <a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a>) {
<a name="l00085"></a>00085         assert(<span class="comment">/* 0 &lt;= block1 &amp;&amp; */</span> block1 &lt; modulo2);
<a name="l00086"></a>00086         assert(<span class="comment">/* 0 &lt;= offset &amp;&amp; */</span> offset &lt; modulo1);
<a name="l00087"></a>00087 
<a name="l00088"></a>00088         this-&gt;block2 = <a class="code" href="classdouble__blocked__index.html#abb35497b6e00614a996d4409de648cce">block2</a>;
<a name="l00089"></a>00089         this-&gt;block1 = <a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a>;
<a name="l00090"></a>00090         this-&gt;offset = <a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a>;
<a name="l00091"></a>00091         <a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> = block2 * <a class="code" href="classdouble__blocked__index.html#af678f019e756b17ebffe76b5dd04a61c">modulo12</a> + block1 * modulo1 + <a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a>;
<a name="l00092"></a>00092     }
<a name="l00093"></a><a class="code" href="classdouble__blocked__index.html#a7462be8aadaa6c123cb5f91a9a5c6485">00093</a>     <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a>&amp; <a class="code" href="classdouble__blocked__index.html#a7462be8aadaa6c123cb5f91a9a5c6485">operator =</a>(size_type <a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>) {
<a name="l00094"></a>00094         <span class="keyword">set</span>(<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>);
<a name="l00095"></a>00095         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00096"></a>00096     }
<a name="l00097"></a>00097 
<a name="l00098"></a>00098     <span class="comment">//pre-increment operator</span>
<a name="l00099"></a><a class="code" href="classdouble__blocked__index.html#af347b9b4d3a4ae5b8b86ffb03ff57324">00099</a>     <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a>&amp; <a class="code" href="classdouble__blocked__index.html#af347b9b4d3a4ae5b8b86ffb03ff57324">operator ++</a>() {
<a name="l00100"></a>00100         ++<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>;
<a name="l00101"></a>00101         ++<a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a>;
<a name="l00102"></a>00102         <span class="keywordflow">if</span> (<a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a> == modulo1) {
<a name="l00103"></a>00103             <a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a> = 0;
<a name="l00104"></a>00104             ++<a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a>;
<a name="l00105"></a>00105             <span class="keywordflow">if</span> (<a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a> == modulo2) {
<a name="l00106"></a>00106                 <a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a> = 0;
<a name="l00107"></a>00107                 ++<a class="code" href="classdouble__blocked__index.html#abb35497b6e00614a996d4409de648cce">block2</a>;
<a name="l00108"></a>00108             }
<a name="l00109"></a>00109         }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111         assert(<a class="code" href="classdouble__blocked__index.html#abb35497b6e00614a996d4409de648cce">block2</a> * <a class="code" href="classdouble__blocked__index.html#af678f019e756b17ebffe76b5dd04a61c">modulo12</a> + <a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a> * modulo1 + <a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a> == this-&gt;<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>);
<a name="l00112"></a>00112         assert(<span class="comment">/* 0 &lt;= block1 &amp;&amp; */</span> <a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a> &lt; modulo2);
<a name="l00113"></a>00113         assert(<span class="comment">/* 0 &lt;= offset &amp;&amp; */</span> <a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a> &lt; modulo1);
<a name="l00114"></a>00114 
<a name="l00115"></a>00115         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00116"></a>00116     }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118     <span class="comment">//post-increment operator</span>
<a name="l00119"></a><a class="code" href="classdouble__blocked__index.html#a506b2f1d47616dcf0e47e8fc6344aedc">00119</a>     <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a> <a class="code" href="classdouble__blocked__index.html#af347b9b4d3a4ae5b8b86ffb03ff57324">operator ++</a>(<span class="keywordtype">int</span>) {
<a name="l00120"></a>00120         <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a> former(*<span class="keyword">this</span>);
<a name="l00121"></a>00121         <a class="code" href="classdouble__blocked__index.html#af347b9b4d3a4ae5b8b86ffb03ff57324">operator ++</a>();
<a name="l00122"></a>00122         <span class="keywordflow">return</span> former;
<a name="l00123"></a>00123     }
<a name="l00124"></a>00124 
<a name="l00125"></a>00125     <span class="comment">//pre-increment operator</span>
<a name="l00126"></a><a class="code" href="classdouble__blocked__index.html#ae460ff1f682358aec3cd8673cc8b17df">00126</a>     <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a>&amp; <a class="code" href="classdouble__blocked__index.html#ae460ff1f682358aec3cd8673cc8b17df">operator --</a>() {
<a name="l00127"></a>00127         --<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>;
<a name="l00128"></a>00128         <span class="keywordflow">if</span> (<a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a> == 0) {
<a name="l00129"></a>00129             <a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a> = modulo1;
<a name="l00130"></a>00130             <span class="keywordflow">if</span> (<a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a> == 0) {
<a name="l00131"></a>00131                 <a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a> = modulo2;
<a name="l00132"></a>00132                 --<a class="code" href="classdouble__blocked__index.html#abb35497b6e00614a996d4409de648cce">block2</a>;
<a name="l00133"></a>00133             }
<a name="l00134"></a>00134             --<a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a>;
<a name="l00135"></a>00135         }
<a name="l00136"></a>00136         --<a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a>;
<a name="l00137"></a>00137 
<a name="l00138"></a>00138         assert(<a class="code" href="classdouble__blocked__index.html#abb35497b6e00614a996d4409de648cce">block2</a> * <a class="code" href="classdouble__blocked__index.html#af678f019e756b17ebffe76b5dd04a61c">modulo12</a> + <a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a> * modulo1 + <a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a> == this-&gt;<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>);
<a name="l00139"></a>00139         assert(<span class="comment">/*0 &lt;= block1 &amp;&amp;*/</span> <a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a> &lt; modulo2);
<a name="l00140"></a>00140         assert(<span class="comment">/*0 &lt;= offset &amp;&amp;*/</span> <a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a> &lt; modulo1);
<a name="l00141"></a>00141 
<a name="l00142"></a>00142         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00143"></a>00143     }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145     <span class="comment">//post-increment operator</span>
<a name="l00146"></a><a class="code" href="classdouble__blocked__index.html#a979fb9f95e88ef7578b1a8f84953c61a">00146</a>     <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a> <a class="code" href="classdouble__blocked__index.html#ae460ff1f682358aec3cd8673cc8b17df">operator --</a>(<span class="keywordtype">int</span>) {
<a name="l00147"></a>00147         <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a> former(*<span class="keyword">this</span>);
<a name="l00148"></a>00148         <a class="code" href="classdouble__blocked__index.html#ae460ff1f682358aec3cd8673cc8b17df">operator --</a>();
<a name="l00149"></a>00149         <span class="keywordflow">return</span> former;
<a name="l00150"></a>00150     }
<a name="l00151"></a><a class="code" href="classdouble__blocked__index.html#aa3e06021691dda527207c3500dcef49c">00151</a>     <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a> <a class="code" href="classdouble__blocked__index.html#aa3e06021691dda527207c3500dcef49c">operator +</a>(size_type addend)<span class="keyword"> const </span>{
<a name="l00152"></a>00152         <span class="keywordflow">return</span> <a class="code" href="classdouble__blocked__index.html#abe48987577f202cbcc45c6d1ee055fb4">double_blocked_index</a>(<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> + addend);
<a name="l00153"></a>00153     }
<a name="l00154"></a><a class="code" href="classdouble__blocked__index.html#a80171742e7f865a88f046595389ffab3">00154</a>     <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a>&amp; <a class="code" href="classdouble__blocked__index.html#a80171742e7f865a88f046595389ffab3">operator +=</a>(size_type addend) {
<a name="l00155"></a>00155         <span class="keyword">set</span>(<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> + addend);
<a name="l00156"></a>00156         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00157"></a>00157     }
<a name="l00158"></a><a class="code" href="classdouble__blocked__index.html#ab2c7023ddaad75a1a44c7c7b0e3a8d86">00158</a>     <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a> <a class="code" href="classdouble__blocked__index.html#ab2c7023ddaad75a1a44c7c7b0e3a8d86">operator -</a>(size_type addend)<span class="keyword"> const </span>{
<a name="l00159"></a>00159         <span class="keywordflow">return</span> <a class="code" href="classdouble__blocked__index.html#abe48987577f202cbcc45c6d1ee055fb4">double_blocked_index</a>(<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> - addend);
<a name="l00160"></a>00160     }
<a name="l00161"></a><a class="code" href="classdouble__blocked__index.html#a46f24908146a58f23adf2954fb5ddab9">00161</a>     size_type <a class="code" href="classdouble__blocked__index.html#ab2c7023ddaad75a1a44c7c7b0e3a8d86">operator -</a>(<span class="keyword">const</span> <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a>&amp; dbi2)<span class="keyword"> const </span>{
<a name="l00162"></a>00162         <span class="keywordflow">return</span> <a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> - dbi2.<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>;
<a name="l00163"></a>00163     }
<a name="l00164"></a><a class="code" href="classdouble__blocked__index.html#a9642df6506181ee23fa107f123b73c61">00164</a>     <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a>&amp; <a class="code" href="classdouble__blocked__index.html#a9642df6506181ee23fa107f123b73c61">operator -=</a>(size_type subtrahend) {
<a name="l00165"></a>00165         <span class="keyword">set</span>(<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> - subtrahend);
<a name="l00166"></a>00166         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00167"></a>00167     }
<a name="l00168"></a><a class="code" href="classdouble__blocked__index.html#a9c53e961e8791230bc225f6c9ab532f8">00168</a>     <span class="keywordtype">bool</span> <a class="code" href="classdouble__blocked__index.html#a9c53e961e8791230bc225f6c9ab532f8">operator ==</a>(<span class="keyword">const</span> <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a>&amp; dbi2)<span class="keyword"> const </span>{
<a name="l00169"></a>00169         <span class="keywordflow">return</span> <a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> == dbi2.<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>;
<a name="l00170"></a>00170     }
<a name="l00171"></a><a class="code" href="classdouble__blocked__index.html#a71ef8124571602f725decb7d579921ba">00171</a>     <span class="keywordtype">bool</span> <a class="code" href="classdouble__blocked__index.html#a71ef8124571602f725decb7d579921ba">operator !=</a>(<span class="keyword">const</span> <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a>&amp; dbi2)<span class="keyword"> const </span>{
<a name="l00172"></a>00172         <span class="keywordflow">return</span> <a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> != dbi2.<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>;
<a name="l00173"></a>00173     }
<a name="l00174"></a><a class="code" href="classdouble__blocked__index.html#a4b009aba86e589bf473216c67124b791">00174</a>     <span class="keywordtype">bool</span> <a class="code" href="classdouble__blocked__index.html#a4b009aba86e589bf473216c67124b791">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a>&amp; dbi2)<span class="keyword"> const </span>{
<a name="l00175"></a>00175         <span class="keywordflow">return</span> <a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> &lt; dbi2.<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>;
<a name="l00176"></a>00176     }
<a name="l00177"></a><a class="code" href="classdouble__blocked__index.html#a0f2914a6880c8a2879fa917cc8c04a5e">00177</a>     <span class="keywordtype">bool</span> <a class="code" href="classdouble__blocked__index.html#a0f2914a6880c8a2879fa917cc8c04a5e">operator &lt;=</a>(<span class="keyword">const</span> <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a>&amp; dbi2)<span class="keyword"> const </span>{
<a name="l00178"></a>00178         <span class="keywordflow">return</span> <a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> &lt;= dbi2.<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>;
<a name="l00179"></a>00179     }
<a name="l00180"></a><a class="code" href="classdouble__blocked__index.html#a707989cd1c05ef4fcb8e51d51ee60cc5">00180</a>     <span class="keywordtype">bool</span> <a class="code" href="classdouble__blocked__index.html#a707989cd1c05ef4fcb8e51d51ee60cc5">operator&gt;</a>(<span class="keyword">const</span> <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a>&amp; dbi2)<span class="keyword"> const </span>{
<a name="l00181"></a>00181         <span class="keywordflow">return</span> <a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> &gt; dbi2.<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>;
<a name="l00182"></a>00182     }
<a name="l00183"></a><a class="code" href="classdouble__blocked__index.html#aacadfd99de6f86842b413c4f7d0610d1">00183</a>     <span class="keywordtype">bool</span> <a class="code" href="classdouble__blocked__index.html#aacadfd99de6f86842b413c4f7d0610d1">operator &gt;=</a>(<span class="keyword">const</span> <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a>&amp; dbi2)<span class="keyword"> const </span>{
<a name="l00184"></a>00184         <span class="keywordflow">return</span> <a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> &gt;= dbi2.<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>;
<a name="l00185"></a>00185     }
<a name="l00186"></a><a class="code" href="classdouble__blocked__index.html#ae8e15f94de5816181a789ab88a84c7ce">00186</a>     <a class="code" href="classdouble__blocked__index.html">double_blocked_index</a>&amp; <a class="code" href="classdouble__blocked__index.html#ae8e15f94de5816181a789ab88a84c7ce">operator &gt;&gt;=</a>(size_type shift) {
<a name="l00187"></a>00187         <span class="keyword">set</span>(<a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a> &gt;&gt; shift);
<a name="l00188"></a>00188         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00189"></a>00189     }
<a name="l00190"></a><a class="code" href="classdouble__blocked__index.html#a7060ab1819ce0b998152781efc863ea9">00190</a>     size_type <a class="code" href="classdouble__blocked__index.html#a7060ab1819ce0b998152781efc863ea9">get_pos</a>()<span class="keyword"> const </span>{
<a name="l00191"></a>00191         <span class="keywordflow">return</span> <a class="code" href="classdouble__blocked__index.html#a357671f0b2a188ff69ed991b7e1adea8">pos</a>;
<a name="l00192"></a>00192     }
<a name="l00193"></a><a class="code" href="classdouble__blocked__index.html#a009424151b91d062eae3de2f6f2348e0">00193</a>     <span class="keyword">const</span> stxxl::unsigned_type &amp; <a class="code" href="classdouble__blocked__index.html#a009424151b91d062eae3de2f6f2348e0">get_block2</a>()<span class="keyword"> const </span>{
<a name="l00194"></a>00194         <span class="keywordflow">return</span> <a class="code" href="classdouble__blocked__index.html#abb35497b6e00614a996d4409de648cce">block2</a>;
<a name="l00195"></a>00195     }
<a name="l00196"></a><a class="code" href="classdouble__blocked__index.html#aafdf535df1c21633f37dae5e67868cd4">00196</a>     <span class="keyword">const</span> stxxl::unsigned_type &amp; <a class="code" href="classdouble__blocked__index.html#aafdf535df1c21633f37dae5e67868cd4">get_block1</a>()<span class="keyword"> const </span>{
<a name="l00197"></a>00197         <span class="keywordflow">return</span> <a class="code" href="classdouble__blocked__index.html#a08119ef7db41669b87c7df156eeb505f">block1</a>;
<a name="l00198"></a>00198     }
<a name="l00199"></a><a class="code" href="classdouble__blocked__index.html#ab2aae63d414d2b771b3cb6fff9f279cc">00199</a>     <span class="keyword">const</span> stxxl::unsigned_type &amp; <a class="code" href="classdouble__blocked__index.html#ab2aae63d414d2b771b3cb6fff9f279cc">get_offset</a>()<span class="keyword"> const </span>{
<a name="l00200"></a>00200         <span class="keywordflow">return</span> <a class="code" href="classdouble__blocked__index.html#a6772d645a1ca186c268081a6d70fb7de">offset</a>;
<a name="l00201"></a>00201     }
<a name="l00202"></a>00202 };
<a name="l00203"></a>00203 <span class="comment"></span>
<a name="l00204"></a>00204 <span class="comment">////////////////////////////////////////////////////////////////////////////</span>
<a name="l00205"></a>00205 <span class="comment"></span>
<a name="l00206"></a>00206 <span class="keyword">template</span> &lt;
<a name="l00207"></a>00207 <span class="keyword">typename</span> ValueType,
<a name="l00208"></a>00208 <span class="keywordtype">unsigned</span> PageSize,
<a name="l00209"></a>00209 <span class="keyword">typename</span> PagerType,
<a name="l00210"></a>00210 <span class="keywordtype">unsigned</span> BlockSize,
<a name="l00211"></a>00211 <span class="keyword">typename</span> AllocStr,
<a name="l00212"></a>00212 <span class="keyword">typename</span> SizeType&gt;
<a name="l00213"></a>00213 <span class="keyword">class </span><a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector</a>;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> AllocStr, <span class="keyword">typename</span> SizeType, <span class="keyword">typename</span> DiffType,
<a name="l00216"></a>00216 <span class="keywordtype">unsigned</span> BlockSize, <span class="keyword">typename</span> PagerType, <span class="keywordtype">unsigned</span> PageSize&gt;
<a name="l00217"></a>00217 <span class="keyword">class </span><a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_vector_iterator</a>;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorIteratorType&gt;
<a name="l00220"></a>00220 <span class="keyword">class </span><a class="code" href="classvector__bufreader.html" title="Buffered sequential reader from a vector using overlapped I/O.">vector_bufreader</a>;
<a name="l00221"></a>00221 
<a name="l00222"></a>00222 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorIteratorType&gt;
<a name="l00223"></a>00223 <span class="keyword">class </span><a class="code" href="classvector__bufreader__reverse.html" title="Buffered sequential reverse reader from a vector using overlapped I/O.">vector_bufreader_reverse</a>;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorIteratorType&gt;
<a name="l00226"></a>00226 <span class="keyword">class </span><a class="code" href="classvector__bufwriter.html" title="Buffered sequential writer to a vector using overlapped I/O.">vector_bufwriter</a>;
<a name="l00227"></a>00227 <span class="comment"></span>
<a name="l00228"></a>00228 <span class="comment">////////////////////////////////////////////////////////////////////////////</span>
<a name="l00229"></a>00229 <span class="comment"></span><span class="comment"></span>
<a name="l00230"></a>00230 <span class="comment">//! External vector iterator, model of \c ext_random_access_iterator concept.</span>
<a name="l00231"></a>00231 <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> AllocStr, <span class="keyword">typename</span> SizeType, <span class="keyword">typename</span> DiffType,
<a name="l00232"></a>00232 <span class="keywordtype">unsigned</span> BlockSize, <span class="keyword">typename</span> PagerType, <span class="keywordtype">unsigned</span> PageSize&gt;
<a name="l00233"></a><a class="code" href="classvector__iterator.html">00233</a> <span class="keyword">class </span><a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">vector_iterator</a> {
<a name="l00234"></a><a class="code" href="classvector__iterator.html#a6f58db6809bbad783cd559192cb9decf">00234</a>     <span class="keyword">typedef</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">vector_iterator&lt;ValueType, AllocStr, SizeType, DiffType, BlockSize, PagerType, PageSize&gt;</a> <a class="code" href="classvector__iterator.html#a6f58db6809bbad783cd559192cb9decf">self_type</a>;
<a name="l00235"></a><a class="code" href="classvector__iterator.html#a2d6ac8f84df3cda11c878556bd86be43">00235</a>     <span class="keyword">typedef</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_vector_iterator&lt;ValueType, AllocStr, SizeType, DiffType, BlockSize, PagerType, PageSize&gt;</a> <a class="code" href="classvector__iterator.html#a2d6ac8f84df3cda11c878556bd86be43">const_self_type</a>;
<a name="l00236"></a>00236 
<a name="l00237"></a><a class="code" href="classvector__iterator.html#a1fd3c073603b9bdfb1449d9a4d56d1b7">00237</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_vector_iterator</a>&lt;ValueType, AllocStr, SizeType, DiffType, BlockSize, PagerType, PageSize&gt;;
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l00240"></a>00240 <span class="comment">    //! \name Types</span>
<a name="l00241"></a>00241 <span class="comment">    //! \{</span>
<a name="l00242"></a>00242 <span class="comment"></span>
<a name="l00243"></a><a class="code" href="classvector__iterator.html#a9b5cb2a84f41def013167ffe6c02816c">00243</a>     <span class="keyword">typedef</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a> <a class="code" href="classvector__iterator.html#a9b5cb2a84f41def013167ffe6c02816c">iterator</a>;
<a name="l00244"></a><a class="code" href="classvector__iterator.html#a9bc4279ab06ec876001b774d92270ee7">00244</a>     <span class="keyword">typedef</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_self_type</a> <a class="code" href="classvector__iterator.html#a9bc4279ab06ec876001b774d92270ee7">const_iterator</a>;
<a name="l00245"></a>00245 
<a name="l00246"></a><a class="code" href="classvector__iterator.html#aa0d771cfd42bb73b2a477e054fdd065e">00246</a>     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <a class="code" href="classvector__iterator.html#aa0d771cfd42bb73b2a477e054fdd065e">block_offset_type</a>;
<a name="l00247"></a><a class="code" href="classvector__iterator.html#a5a3c64fb2e0788e3810a767aa1337029">00247</a>     <span class="keyword">typedef</span> <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector&lt;ValueType, PageSize, PagerType, BlockSize, AllocStr, SizeType&gt;</a> <a class="code" href="classvector__iterator.html#a5a3c64fb2e0788e3810a767aa1337029">vector_type</a>;
<a name="l00248"></a><a class="code" href="classvector__iterator.html#a8280d57953e3d7a84e320324ba9ef18c">00248</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector</a>&lt;ValueType, PageSize, PagerType, BlockSize, AllocStr, SizeType&gt;;
<a name="l00249"></a><a class="code" href="classvector__iterator.html#a309fb476f940a6874d712bd4b0fe3c14">00249</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector_1_1bid__vector.html">vector_type::bids_container_type</a> <a class="code" href="classvector__iterator.html#a309fb476f940a6874d712bd4b0fe3c14">bids_container_type</a>;
<a name="l00250"></a><a class="code" href="classvector__iterator.html#a340cc826e811035e2026f7ff171ebcf4">00250</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> bids_container_type::iterator <a class="code" href="classvector__iterator.html#a340cc826e811035e2026f7ff171ebcf4">bids_container_iterator</a>;
<a name="l00251"></a><a class="code" href="classvector__iterator.html#abc73547ab67142bb9f6d1cb46644b5bf">00251</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector_1_1bid__vector.html#adfbf24f2fb99176ba1b6ddbfb6fce504">bids_container_type::bid_type</a> <a class="code" href="classvector__iterator.html#abc73547ab67142bb9f6d1cb46644b5bf">bid_type</a>;
<a name="l00252"></a><a class="code" href="classvector__iterator.html#aa8bad0dbea2f07e71cd709281215e692">00252</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#a202563e16860bc03b8fa49b7f9b1e244" title="type of the block used in disk-memory transfers">vector_type::block_type</a> <a class="code" href="classvector__iterator.html#aa8bad0dbea2f07e71cd709281215e692">block_type</a>;
<a name="l00253"></a><a class="code" href="classvector__iterator.html#af8360821b27a4546b9c866fc7fc0d984">00253</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classdouble__blocked__index.html">vector_type::blocked_index_type</a> <a class="code" href="classvector__iterator.html#af8360821b27a4546b9c866fc7fc0d984">blocked_index_type</a>;
<a name="l00254"></a>00254 
<a name="l00255"></a><a class="code" href="classvector__iterator.html#a7054e70b61f1833893cb4b1f18445747">00255</a>     <span class="keyword">typedef</span> std::random_access_iterator_tag <a class="code" href="classvector__iterator.html#a7054e70b61f1833893cb4b1f18445747">iterator_category</a>;
<a name="l00256"></a><a class="code" href="classvector__iterator.html#a2e5202718bda5367b5d4198f1b15affd">00256</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">vector_type::size_type</a> <a class="code" href="classvector__iterator.html#a2e5202718bda5367b5d4198f1b15affd">size_type</a>;
<a name="l00257"></a><a class="code" href="classvector__iterator.html#af11da2b3eba86eee88530d2bca7b33d2">00257</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#a02d34518b2a1428147a358d3a019efbf">vector_type::difference_type</a> <a class="code" href="classvector__iterator.html#af11da2b3eba86eee88530d2bca7b33d2">difference_type</a>;
<a name="l00258"></a><a class="code" href="classvector__iterator.html#aa16ec4422db7d2291bdffc67fdec9863">00258</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">vector_type::value_type</a> <a class="code" href="classvector__iterator.html#aa16ec4422db7d2291bdffc67fdec9863">value_type</a>;
<a name="l00259"></a><a class="code" href="classvector__iterator.html#abb338aa9d8a51f12446313a05e7084e7">00259</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#a7d234f8da8ce66aacfe18001d887e4cf" title="reference to value_type">vector_type::reference</a> <a class="code" href="classvector__iterator.html#abb338aa9d8a51f12446313a05e7084e7">reference</a>;
<a name="l00260"></a><a class="code" href="classvector__iterator.html#a14f52a4071c7d731e3d2771a74b8d299">00260</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#ab1387877afd358151c6b6b8867d40fa6" title="constant reference to value_type">vector_type::const_reference</a> <a class="code" href="classvector__iterator.html#a14f52a4071c7d731e3d2771a74b8d299">const_reference</a>;
<a name="l00261"></a><a class="code" href="classvector__iterator.html#a9cb0d486fcbca821bfb85642666f56be">00261</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#a1b3713b0f86bdb4f7e5f93d4b6c2530e" title="pointer to value_type">vector_type::pointer</a> <a class="code" href="classvector__iterator.html#a9cb0d486fcbca821bfb85642666f56be">pointer</a>;
<a name="l00262"></a><a class="code" href="classvector__iterator.html#ab43255dfeb9eda2df4ead96727be7d2b">00262</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#a2f47dad8340cde2b655189944426a5bb" title="constant pointer to value_type">vector_type::const_pointer</a> <a class="code" href="classvector__iterator.html#ab43255dfeb9eda2df4ead96727be7d2b">const_pointer</a>;
<a name="l00263"></a>00263 <span class="comment"></span>
<a name="l00264"></a>00264 <span class="comment">    //! \}</span>
<a name="l00265"></a>00265 <span class="comment"></span>
<a name="l00266"></a>00266 <span class="keyword">protected</span>:
<a name="l00267"></a><a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">00267</a>     <a class="code" href="classdouble__blocked__index.html">blocked_index_type</a> <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>;
<a name="l00268"></a><a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">00268</a>     <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector_type</a>* <a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 <span class="keyword">private</span>:<span class="comment"></span>
<a name="l00271"></a>00271 <span class="comment">    //! private constructor for initializing other iterators</span>
<a name="l00272"></a><a class="code" href="classvector__iterator.html#aecd28a325bdeeb90257bf87448f28ce7">00272</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html#a95e703c0637b8b2744704c16e28764f0" title="constructs invalid iterator">vector_iterator</a>(<a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector_type</a>* v, <a class="code" href="classvector__iterator.html#a2e5202718bda5367b5d4198f1b15affd">size_type</a> o)
<a name="l00273"></a>00273     : <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>(o), <a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>(v) {
<a name="l00274"></a>00274     }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l00277"></a>00277 <span class="comment">    //! constructs invalid iterator</span>
<a name="l00278"></a><a class="code" href="classvector__iterator.html#a95e703c0637b8b2744704c16e28764f0">00278</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html#a95e703c0637b8b2744704c16e28764f0" title="constructs invalid iterator">vector_iterator</a>()
<a name="l00279"></a>00279     : <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>(0), <a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>(NULL) {
<a name="l00280"></a>00280     }<span class="comment"></span>
<a name="l00281"></a>00281 <span class="comment">    //! copy-constructor</span>
<a name="l00282"></a><a class="code" href="classvector__iterator.html#addc05d9e7d567f833a834727b8beebaa">00282</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html#a95e703c0637b8b2744704c16e28764f0" title="constructs invalid iterator">vector_iterator</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)
<a name="l00283"></a>00283     : <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>(a.<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>),
<a name="l00284"></a>00284     <a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>(a.<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>) {
<a name="l00285"></a>00285     }
<a name="l00286"></a>00286 <span class="comment"></span>
<a name="l00287"></a>00287 <span class="comment">    //! \name Iterator Properties</span>
<a name="l00288"></a>00288 <span class="comment">    //! \{</span>
<a name="l00289"></a>00289 <span class="comment"></span><span class="comment"></span>
<a name="l00290"></a>00290 <span class="comment">    //! return pointer to vector containing iterator</span>
<a name="l00291"></a><a class="code" href="classvector__iterator.html#a94bf75e57233314a3290c3c3289247da">00291</a> <span class="comment"></span>    <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector_type</a> * <a class="code" href="classvector__iterator.html#a94bf75e57233314a3290c3c3289247da" title="return pointer to vector containing iterator">parent_vector</a>()<span class="keyword"> const </span>{
<a name="l00292"></a>00292         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>;
<a name="l00293"></a>00293     }<span class="comment"></span>
<a name="l00294"></a>00294 <span class="comment">    //! return block offset of current element</span>
<a name="l00295"></a><a class="code" href="classvector__iterator.html#ae27ab01411beabf314ead9a0e1742220">00295</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html#aa0d771cfd42bb73b2a477e054fdd065e">block_offset_type</a> <a class="code" href="classvector__iterator.html#ae27ab01411beabf314ead9a0e1742220" title="return block offset of current element">block_offset</a>()<span class="keyword"> const </span>{
<a name="l00296"></a>00296         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="classvector__iterator.html#aa0d771cfd42bb73b2a477e054fdd065e">block_offset_type</a><span class="keyword">&gt;</span> (<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>.<a class="code" href="classdouble__blocked__index.html#ab2aae63d414d2b771b3cb6fff9f279cc">get_offset</a>());
<a name="l00297"></a>00297     }<span class="comment"></span>
<a name="l00298"></a>00298 <span class="comment">    //! return iterator to stxxl::BID containg current element</span>
<a name="l00299"></a><a class="code" href="classvector__iterator.html#aa9b242933a60fcca4153482c87caf899">00299</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html#a340cc826e811035e2026f7ff171ebcf4">bids_container_iterator</a> <a class="code" href="classvector__iterator.html#aa9b242933a60fcca4153482c87caf899" title="return iterator to stxxl::BID containg current element">bid</a>()<span class="keyword"> const </span>{
<a name="l00300"></a>00300         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>-&gt;<a class="code" href="classvector.html#afc255367efd086550c9d14dfaf525e2f">bid</a>(<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>);
<a name="l00301"></a>00301     }
<a name="l00302"></a>00302 <span class="comment"></span>
<a name="l00303"></a>00303 <span class="comment">    //! \}</span>
<a name="l00304"></a>00304 <span class="comment"></span><span class="comment"></span>
<a name="l00305"></a>00305 <span class="comment">    //! \name Access Operators</span>
<a name="l00306"></a>00306 <span class="comment">    //! \{</span>
<a name="l00307"></a>00307 <span class="comment"></span><span class="comment"></span>
<a name="l00308"></a>00308 <span class="comment">    //! return current element</span>
<a name="l00309"></a><a class="code" href="classvector__iterator.html#a7460dc8949148c4c7c1e0f21493eaffb">00309</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html#abb338aa9d8a51f12446313a05e7084e7">reference</a> <a class="code" href="classvector__iterator.html#a7460dc8949148c4c7c1e0f21493eaffb" title="return current element">operator *</a>() {
<a name="l00310"></a>00310         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>-&gt;<a class="code" href="classvector.html#a675d7bf74bd470ba56b7105531825255">element</a>(<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>);
<a name="l00311"></a>00311     }<span class="comment"></span>
<a name="l00312"></a>00312 <span class="comment">    //! return pointer to current element</span>
<a name="l00313"></a><a class="code" href="classvector__iterator.html#a41ff8ff3e088f54283b7c2a11ae1da46">00313</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html#a9cb0d486fcbca821bfb85642666f56be">pointer</a> <a class="code" href="classvector__iterator.html#a41ff8ff3e088f54283b7c2a11ae1da46" title="return pointer to current element">operator -&gt; </a>() {
<a name="l00314"></a>00314         <span class="keywordflow">return</span> &amp;(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>-&gt;<a class="code" href="classvector.html#a675d7bf74bd470ba56b7105531825255">element</a>(<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>));
<a name="l00315"></a>00315     }<span class="comment"></span>
<a name="l00316"></a>00316 <span class="comment">    //! return const reference to current element</span>
<a name="l00317"></a><a class="code" href="classvector__iterator.html#ad277cc10adec08e210dd9ab331e4deeb">00317</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html#a14f52a4071c7d731e3d2771a74b8d299">const_reference</a> <a class="code" href="classvector__iterator.html#a7460dc8949148c4c7c1e0f21493eaffb" title="return current element">operator *</a>()<span class="keyword"> const </span>{
<a name="l00318"></a>00318         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>-&gt;<a class="code" href="classvector.html#a606834d73c078850aba1ce9f750a3ac7">const_element</a>(<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>);
<a name="l00319"></a>00319     }<span class="comment"></span>
<a name="l00320"></a>00320 <span class="comment">    //! return const pointer to current element</span>
<a name="l00321"></a><a class="code" href="classvector__iterator.html#a29836cf707f77dde52886a7585032319">00321</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html#ab43255dfeb9eda2df4ead96727be7d2b">const_pointer</a> <a class="code" href="classvector__iterator.html#a41ff8ff3e088f54283b7c2a11ae1da46" title="return pointer to current element">operator -&gt; </a>()<span class="keyword"> const </span>{
<a name="l00322"></a>00322         <span class="keywordflow">return</span> &amp;(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>-&gt;<a class="code" href="classvector.html#a606834d73c078850aba1ce9f750a3ac7">const_element</a>(<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>));
<a name="l00323"></a>00323     }<span class="comment"></span>
<a name="l00324"></a>00324 <span class="comment">    //! return mutable reference to element +i after the current element</span>
<a name="l00325"></a><a class="code" href="classvector__iterator.html#a5be2396083625f99d3c57c2afba63795">00325</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html#abb338aa9d8a51f12446313a05e7084e7">reference</a> <a class="code" href="classvector__iterator.html#a5be2396083625f99d3c57c2afba63795" title="return mutable reference to element +i after the current element">operator [] </a>(<a class="code" href="classvector__iterator.html#a2e5202718bda5367b5d4198f1b15affd">size_type</a> i) {
<a name="l00326"></a>00326         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>-&gt;<a class="code" href="classvector.html#a675d7bf74bd470ba56b7105531825255">element</a>(<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>.<a class="code" href="classdouble__blocked__index.html#a7060ab1819ce0b998152781efc863ea9">get_pos</a>() + i);
<a name="l00327"></a>00327     }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 <span class="preprocessor">#ifdef _LIBCPP_VERSION</span>
<a name="l00330"></a>00330 <span class="preprocessor"></span>    <span class="comment">//-tb 2013-11: libc++ defines std::reverse_iterator::operator[] in such a</span>
<a name="l00331"></a>00331     <span class="comment">// way that it expects vector_iterator::operator[] to return a (mutable)</span>
<a name="l00332"></a>00332     <span class="comment">// reference. Thus to remove confusion about the compiler error, we remove</span>
<a name="l00333"></a>00333     <span class="comment">// the operator[] const for libc++. The const_reference actually violates</span>
<a name="l00334"></a>00334     <span class="comment">// some version of the STL standard, but works well in gcc&#39;s libstdc++.</span>
<a name="l00335"></a>00335 <span class="preprocessor">#else</span>
<a name="l00336"></a>00336 <span class="preprocessor"></span><span class="comment">    //! return const reference to element +i after the current element</span>
<a name="l00337"></a><a class="code" href="classvector__iterator.html#a137315a97816740eda712c332a49e4a3">00337</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html#a14f52a4071c7d731e3d2771a74b8d299">const_reference</a> <a class="code" href="classvector__iterator.html#a5be2396083625f99d3c57c2afba63795" title="return mutable reference to element +i after the current element">operator [] </a>(<a class="code" href="classvector__iterator.html#a2e5202718bda5367b5d4198f1b15affd">size_type</a> i)<span class="keyword"> const </span>{
<a name="l00338"></a>00338         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>-&gt;<a class="code" href="classvector.html#a606834d73c078850aba1ce9f750a3ac7">const_element</a>(<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>.<a class="code" href="classdouble__blocked__index.html#a7060ab1819ce0b998152781efc863ea9">get_pos</a>() + i);
<a name="l00339"></a>00339     }
<a name="l00340"></a>00340 <span class="preprocessor">#endif</span>
<a name="l00341"></a>00341 <span class="preprocessor"></span><span class="comment">    //! \}</span>
<a name="l00342"></a>00342 <span class="comment"></span><span class="comment"></span>
<a name="l00343"></a>00343 <span class="comment">    //! \name Relative Calculation of Iterators</span>
<a name="l00344"></a>00344 <span class="comment">    //! \{</span>
<a name="l00345"></a>00345 <span class="comment"></span><span class="comment"></span>
<a name="l00346"></a>00346 <span class="comment">    //! calculate different between two iterator</span>
<a name="l00347"></a><a class="code" href="classvector__iterator.html#a8c53c439cf2276ca220709a63977957d">00347</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html#af11da2b3eba86eee88530d2bca7b33d2">difference_type</a> <a class="code" href="classvector__iterator.html#a8c53c439cf2276ca220709a63977957d" title="calculate different between two iterator">operator -</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00348"></a>00348         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> - a.<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>;
<a name="l00349"></a>00349     }<span class="comment"></span>
<a name="l00350"></a>00350 <span class="comment">    //! calculate different between two iterator</span>
<a name="l00351"></a><a class="code" href="classvector__iterator.html#a2192ffda1be51299bb7b37ca2e41f753">00351</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html#af11da2b3eba86eee88530d2bca7b33d2">difference_type</a> <a class="code" href="classvector__iterator.html#a8c53c439cf2276ca220709a63977957d" title="calculate different between two iterator">operator -</a>(<span class="keyword">const</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00352"></a>00352         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> - a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>;
<a name="l00353"></a>00353     }<span class="comment"></span>
<a name="l00354"></a>00354 <span class="comment">    //! return iterator advanced -i positions in the vector</span>
<a name="l00355"></a><a class="code" href="classvector__iterator.html#aa7ae255be694ccfdabb22ca753d78b42">00355</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a> <a class="code" href="classvector__iterator.html#a8c53c439cf2276ca220709a63977957d" title="calculate different between two iterator">operator -</a>(<a class="code" href="classvector__iterator.html#a2e5202718bda5367b5d4198f1b15affd">size_type</a> i)<span class="keyword"> const </span>{
<a name="l00356"></a>00356         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#a6f58db6809bbad783cd559192cb9decf">self_type</a>(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>, <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>.<a class="code" href="classdouble__blocked__index.html#a7060ab1819ce0b998152781efc863ea9">get_pos</a>() - i);
<a name="l00357"></a>00357     }<span class="comment"></span>
<a name="l00358"></a>00358 <span class="comment">    //! return iterator advanced +i positions in the vector</span>
<a name="l00359"></a><a class="code" href="classvector__iterator.html#acf72438805b0b51a1a32871a067670df">00359</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a> <a class="code" href="classvector__iterator.html#acf72438805b0b51a1a32871a067670df" title="return iterator advanced +i positions in the vector">operator +</a>(<a class="code" href="classvector__iterator.html#a2e5202718bda5367b5d4198f1b15affd">size_type</a> i)<span class="keyword"> const </span>{
<a name="l00360"></a>00360         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#a6f58db6809bbad783cd559192cb9decf">self_type</a>(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>, <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>.<a class="code" href="classdouble__blocked__index.html#a7060ab1819ce0b998152781efc863ea9">get_pos</a>() + i);
<a name="l00361"></a>00361     }<span class="comment"></span>
<a name="l00362"></a>00362 <span class="comment">    //! advance this iterator -i positions in the vector</span>
<a name="l00363"></a><a class="code" href="classvector__iterator.html#ad11b12acf8eb75c60a71d843660c2a0c">00363</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; <a class="code" href="classvector__iterator.html#ad11b12acf8eb75c60a71d843660c2a0c" title="advance this iterator -i positions in the vector">operator -=</a>(<a class="code" href="classvector__iterator.html#a2e5202718bda5367b5d4198f1b15affd">size_type</a> i) {
<a name="l00364"></a>00364         <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> -= i;
<a name="l00365"></a>00365         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00366"></a>00366     }<span class="comment"></span>
<a name="l00367"></a>00367 <span class="comment">    //! advance this iterator +i positions in the vector</span>
<a name="l00368"></a><a class="code" href="classvector__iterator.html#a9f2b47ffe1e0a0c5aa7f5231ac2863ed">00368</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; <a class="code" href="classvector__iterator.html#a9f2b47ffe1e0a0c5aa7f5231ac2863ed" title="advance this iterator +i positions in the vector">operator +=</a>(<a class="code" href="classvector__iterator.html#a2e5202718bda5367b5d4198f1b15affd">size_type</a> i) {
<a name="l00369"></a>00369         <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> += i;
<a name="l00370"></a>00370         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00371"></a>00371     }<span class="comment"></span>
<a name="l00372"></a>00372 <span class="comment">    //! advance this iterator to next position in the vector</span>
<a name="l00373"></a><a class="code" href="classvector__iterator.html#aba7a7c633c0a70690259fbec468fd9d3">00373</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; <a class="code" href="classvector__iterator.html#aba7a7c633c0a70690259fbec468fd9d3" title="advance this iterator to next position in the vector">operator ++</a>() {
<a name="l00374"></a>00374         <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>++;
<a name="l00375"></a>00375         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00376"></a>00376     }<span class="comment"></span>
<a name="l00377"></a>00377 <span class="comment">    //! advance this iterator to next position in the vector</span>
<a name="l00378"></a><a class="code" href="classvector__iterator.html#aed4363c921090b89d541b77e6e84341c">00378</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a> <a class="code" href="classvector__iterator.html#aba7a7c633c0a70690259fbec468fd9d3" title="advance this iterator to next position in the vector">operator ++</a>(<span class="keywordtype">int</span>) {
<a name="l00379"></a>00379         <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a> tmp = *<span class="keyword">this</span>;
<a name="l00380"></a>00380         <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>++;
<a name="l00381"></a>00381         <span class="keywordflow">return</span> tmp;
<a name="l00382"></a>00382     }<span class="comment"></span>
<a name="l00383"></a>00383 <span class="comment">    //! advance this iterator to preceding position in the vector</span>
<a name="l00384"></a><a class="code" href="classvector__iterator.html#a7f55b6a7130d77edc5939c1f4a33e8e3">00384</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; <a class="code" href="classvector__iterator.html#a7f55b6a7130d77edc5939c1f4a33e8e3" title="advance this iterator to preceding position in the vector">operator --</a>() {
<a name="l00385"></a>00385         <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>--;
<a name="l00386"></a>00386         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00387"></a>00387     }<span class="comment"></span>
<a name="l00388"></a>00388 <span class="comment">    //! advance this iterator to preceding position in the vector</span>
<a name="l00389"></a><a class="code" href="classvector__iterator.html#ae1129a2f68a2d028372d151807db56d8">00389</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a> <a class="code" href="classvector__iterator.html#a7f55b6a7130d77edc5939c1f4a33e8e3" title="advance this iterator to preceding position in the vector">operator --</a>(<span class="keywordtype">int</span>) {
<a name="l00390"></a>00390         <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a> tmp = *<span class="keyword">this</span>;
<a name="l00391"></a>00391         <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>--;
<a name="l00392"></a>00392         <span class="keywordflow">return</span> tmp;
<a name="l00393"></a>00393     }
<a name="l00394"></a>00394 <span class="comment"></span>
<a name="l00395"></a>00395 <span class="comment">    //! \}</span>
<a name="l00396"></a>00396 <span class="comment"></span><span class="comment"></span>
<a name="l00397"></a>00397 <span class="comment">    //! \name Comparison Operators</span>
<a name="l00398"></a>00398 <span class="comment">    //! \{</span>
<a name="l00399"></a><a class="code" href="classvector__iterator.html#aef0029497c8b2a48b1e693e6779ce798">00399</a> <span class="comment"></span>    <span class="keywordtype">bool</span> <a class="code" href="classvector__iterator.html#aef0029497c8b2a48b1e693e6779ce798">operator ==</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00400"></a>00400         assert(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a> == a.<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>);
<a name="l00401"></a>00401         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> == a.<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>;
<a name="l00402"></a>00402     }
<a name="l00403"></a><a class="code" href="classvector__iterator.html#a7746d3c18ecc122b861cf5ec6f21e604">00403</a>     <span class="keywordtype">bool</span> <a class="code" href="classvector__iterator.html#a7746d3c18ecc122b861cf5ec6f21e604">operator !=</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00404"></a>00404         assert(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a> == a.<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>);
<a name="l00405"></a>00405         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> != a.<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>;
<a name="l00406"></a>00406     }
<a name="l00407"></a><a class="code" href="classvector__iterator.html#a31ad48e6d0bc3bb2487b6681237ae237">00407</a>     <span class="keywordtype">bool</span> <a class="code" href="classvector__iterator.html#a31ad48e6d0bc3bb2487b6681237ae237">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00408"></a>00408         assert(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a> == a.<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>);
<a name="l00409"></a>00409         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> &lt; a.<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>;
<a name="l00410"></a>00410     }
<a name="l00411"></a><a class="code" href="classvector__iterator.html#a2f0c48f1286fa22c61c70c7f9c3f409f">00411</a>     <span class="keywordtype">bool</span> <a class="code" href="classvector__iterator.html#a2f0c48f1286fa22c61c70c7f9c3f409f">operator &lt;=</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00412"></a>00412         assert(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a> == a.<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>);
<a name="l00413"></a>00413         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> &lt;= a.<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>;
<a name="l00414"></a>00414     }
<a name="l00415"></a><a class="code" href="classvector__iterator.html#aa8245f6d9abf5a0ae2d4a97b612a88f5">00415</a>     <span class="keywordtype">bool</span> <a class="code" href="classvector__iterator.html#aa8245f6d9abf5a0ae2d4a97b612a88f5">operator&gt;</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00416"></a>00416         assert(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a> == a.<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>);
<a name="l00417"></a>00417         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> &gt; a.<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>;
<a name="l00418"></a>00418     }
<a name="l00419"></a><a class="code" href="classvector__iterator.html#ab4a0288470042cdbeb1afb7126b22784">00419</a>     <span class="keywordtype">bool</span> <a class="code" href="classvector__iterator.html#ab4a0288470042cdbeb1afb7126b22784">operator &gt;=</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00420"></a>00420         assert(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a> == a.<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>);
<a name="l00421"></a>00421         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> &gt;= a.<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>;
<a name="l00422"></a>00422     }
<a name="l00423"></a><a class="code" href="classvector__iterator.html#a6dce60807cca1685f8174fe4c12c9b45">00423</a>     <span class="keywordtype">bool</span> <a class="code" href="classvector__iterator.html#aef0029497c8b2a48b1e693e6779ce798">operator ==</a>(<span class="keyword">const</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00424"></a>00424         assert(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a> == a.<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>);
<a name="l00425"></a>00425         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> == a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>;
<a name="l00426"></a>00426     }
<a name="l00427"></a><a class="code" href="classvector__iterator.html#a863a5a1bb31a0a70590f0a6126f36708">00427</a>     <span class="keywordtype">bool</span> <a class="code" href="classvector__iterator.html#a7746d3c18ecc122b861cf5ec6f21e604">operator !=</a>(<span class="keyword">const</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00428"></a>00428         assert(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a> == a.<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>);
<a name="l00429"></a>00429         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> != a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>;
<a name="l00430"></a>00430     }
<a name="l00431"></a><a class="code" href="classvector__iterator.html#aa4e177a5295b093d2a5bba6f66ae63ab">00431</a>     <span class="keywordtype">bool</span> <a class="code" href="classvector__iterator.html#aa4e177a5295b093d2a5bba6f66ae63ab">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00432"></a>00432         assert(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a> == a.<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>);
<a name="l00433"></a>00433         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> &lt; a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>;
<a name="l00434"></a>00434     }
<a name="l00435"></a><a class="code" href="classvector__iterator.html#ac6c0ea865ef02ec167ec3e55373c046c">00435</a>     <span class="keywordtype">bool</span> <a class="code" href="classvector__iterator.html#a2f0c48f1286fa22c61c70c7f9c3f409f">operator &lt;=</a>(<span class="keyword">const</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00436"></a>00436         assert(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a> == a.<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>);
<a name="l00437"></a>00437         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> &lt;= a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>;
<a name="l00438"></a>00438     }
<a name="l00439"></a><a class="code" href="classvector__iterator.html#a7c65f99b7859f6f18a69adbce0e9e9b4">00439</a>     <span class="keywordtype">bool</span> <a class="code" href="classvector__iterator.html#a7c65f99b7859f6f18a69adbce0e9e9b4">operator&gt;</a>(<span class="keyword">const</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00440"></a>00440         assert(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a> == a.<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>);
<a name="l00441"></a>00441         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> &gt; a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>;
<a name="l00442"></a>00442     }
<a name="l00443"></a><a class="code" href="classvector__iterator.html#ad71e511cda1beea9e0e21933734435de">00443</a>     <span class="keywordtype">bool</span> <a class="code" href="classvector__iterator.html#ab4a0288470042cdbeb1afb7126b22784">operator &gt;=</a>(<span class="keyword">const</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00444"></a>00444         assert(<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a> == a.<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>);
<a name="l00445"></a>00445         <span class="keywordflow">return</span> <a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a> &gt;= a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>;
<a name="l00446"></a>00446     }
<a name="l00447"></a>00447 <span class="comment"></span>
<a name="l00448"></a>00448 <span class="comment">    //! \}</span>
<a name="l00449"></a>00449 <span class="comment"></span><span class="comment"></span>
<a name="l00450"></a>00450 <span class="comment">    //! \name Flushing Operation</span>
<a name="l00451"></a>00451 <span class="comment">    //! \{</span>
<a name="l00452"></a><a class="code" href="classvector__iterator.html#a7e2805f6343b52130c982391a72a4f73">00452</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector__iterator.html#a7e2805f6343b52130c982391a72a4f73">block_externally_updated</a>() {
<a name="l00453"></a>00453         <a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>-&gt;<a class="code" href="classvector.html#a4b2645e4c1afd03149aeb7b8975a2e17">block_externally_updated</a>(<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>);
<a name="l00454"></a>00454     }
<a name="l00455"></a><a class="code" href="classvector__iterator.html#a2584361cbad094f15f197060afb07b67">00455</a>     <span class="keywordtype">void</span> <a class="code" href="classvector__iterator.html#a2584361cbad094f15f197060afb07b67">flush</a>() {
<a name="l00456"></a>00456         <a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>-&gt;<a class="code" href="classvector.html#a08276777f1d54845546843d77f402904" title="Flushes the cache pages to the external memory.">flush</a>();
<a name="l00457"></a>00457     }
<a name="l00458"></a>00458 <span class="comment"></span>
<a name="l00459"></a>00459 <span class="comment">    //! \}</span>
<a name="l00460"></a>00460 <span class="comment"></span>};
<a name="l00461"></a>00461 <span class="comment"></span>
<a name="l00462"></a>00462 <span class="comment">////////////////////////////////////////////////////////////////////////////</span>
<a name="l00463"></a>00463 <span class="comment"></span><span class="comment"></span>
<a name="l00464"></a>00464 <span class="comment">//! Const external vector iterator, model of \c ext_random_access_iterator concept.</span>
<a name="l00465"></a>00465 <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> AllocStr, <span class="keyword">typename</span> SizeType, <span class="keyword">typename</span> DiffType,
<a name="l00466"></a>00466 <span class="keywordtype">unsigned</span> BlockSize, <span class="keyword">typename</span> PagerType, <span class="keywordtype">unsigned</span> PageSize&gt;
<a name="l00467"></a><a class="code" href="classconst__vector__iterator.html">00467</a> <span class="keyword">class </span><a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_vector_iterator</a> {
<a name="l00468"></a><a class="code" href="classconst__vector__iterator.html#a1bdc428ef8193709d68499ad9b5fd54e">00468</a>     <span class="keyword">typedef</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_vector_iterator&lt;ValueType, AllocStr, SizeType, DiffType, BlockSize, PagerType, PageSize&gt;</a> <a class="code" href="classconst__vector__iterator.html#a1bdc428ef8193709d68499ad9b5fd54e">self_type</a>;
<a name="l00469"></a><a class="code" href="classconst__vector__iterator.html#a7c4c2652b215fc44800eb93ff0695ddd">00469</a>     <span class="keyword">typedef</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">vector_iterator&lt;ValueType, AllocStr, SizeType, DiffType, BlockSize, PagerType, PageSize&gt;</a> <a class="code" href="classconst__vector__iterator.html#a7c4c2652b215fc44800eb93ff0695ddd">mutable_self_type</a>;
<a name="l00470"></a>00470 
<a name="l00471"></a><a class="code" href="classconst__vector__iterator.html#a07dca479c78b40d7dde3aaed92793720">00471</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">vector_iterator</a>&lt;ValueType, AllocStr, SizeType, DiffType, BlockSize, PagerType, PageSize&gt;;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l00474"></a>00474 <span class="comment">    //! \name Types</span>
<a name="l00475"></a>00475 <span class="comment">    //! \{</span>
<a name="l00476"></a>00476 <span class="comment"></span>
<a name="l00477"></a><a class="code" href="classconst__vector__iterator.html#a925575886d5f415e360c244b3656081b">00477</a>     <span class="keyword">typedef</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a> <a class="code" href="classconst__vector__iterator.html#a925575886d5f415e360c244b3656081b">const_iterator</a>;
<a name="l00478"></a><a class="code" href="classconst__vector__iterator.html#a8f165ca81af6c3b094ce3d6310f8c09a">00478</a>     <span class="keyword">typedef</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">mutable_self_type</a> <a class="code" href="classconst__vector__iterator.html#a8f165ca81af6c3b094ce3d6310f8c09a">iterator</a>;
<a name="l00479"></a>00479 
<a name="l00480"></a><a class="code" href="classconst__vector__iterator.html#ada46f69b46d9a37f1833d7994cf9ea1a">00480</a>     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <a class="code" href="classconst__vector__iterator.html#ada46f69b46d9a37f1833d7994cf9ea1a">block_offset_type</a>;
<a name="l00481"></a><a class="code" href="classconst__vector__iterator.html#aeef572e5732daa6844b37ca6402cfbdd">00481</a>     <span class="keyword">typedef</span> <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector&lt;ValueType, PageSize, PagerType, BlockSize, AllocStr, SizeType&gt;</a> <a class="code" href="classconst__vector__iterator.html#aeef572e5732daa6844b37ca6402cfbdd">vector_type</a>;
<a name="l00482"></a><a class="code" href="classconst__vector__iterator.html#a8280d57953e3d7a84e320324ba9ef18c">00482</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector</a>&lt;ValueType, PageSize, PagerType, BlockSize, AllocStr, SizeType&gt;;
<a name="l00483"></a><a class="code" href="classconst__vector__iterator.html#a8d1398bcdc9745ebf441badaec62b0e6">00483</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector_1_1bid__vector.html">vector_type::bids_container_type</a> <a class="code" href="classconst__vector__iterator.html#a8d1398bcdc9745ebf441badaec62b0e6">bids_container_type</a>;
<a name="l00484"></a><a class="code" href="classconst__vector__iterator.html#ad02c6aead35e5cbd5e6cf568f4ffe7c8">00484</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> bids_container_type::iterator <a class="code" href="classconst__vector__iterator.html#ad02c6aead35e5cbd5e6cf568f4ffe7c8">bids_container_iterator</a>;
<a name="l00485"></a><a class="code" href="classconst__vector__iterator.html#a158400220c40e99fa867bd5fed5821d3">00485</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector_1_1bid__vector.html#adfbf24f2fb99176ba1b6ddbfb6fce504">bids_container_type::bid_type</a> <a class="code" href="classconst__vector__iterator.html#a158400220c40e99fa867bd5fed5821d3">bid_type</a>;
<a name="l00486"></a><a class="code" href="classconst__vector__iterator.html#a338ad83f22d0a8939d6c5ccaba6b3199">00486</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#a202563e16860bc03b8fa49b7f9b1e244" title="type of the block used in disk-memory transfers">vector_type::block_type</a> <a class="code" href="classconst__vector__iterator.html#a338ad83f22d0a8939d6c5ccaba6b3199">block_type</a>;
<a name="l00487"></a><a class="code" href="classconst__vector__iterator.html#adacf5fc63a91fe137bffb59509416308">00487</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classdouble__blocked__index.html">vector_type::blocked_index_type</a> <a class="code" href="classconst__vector__iterator.html#adacf5fc63a91fe137bffb59509416308">blocked_index_type</a>;
<a name="l00488"></a>00488 
<a name="l00489"></a><a class="code" href="classconst__vector__iterator.html#a1311d36a65a6e676a7129d19c54378ca">00489</a>     <span class="keyword">typedef</span> std::random_access_iterator_tag <a class="code" href="classconst__vector__iterator.html#a1311d36a65a6e676a7129d19c54378ca">iterator_category</a>;
<a name="l00490"></a><a class="code" href="classconst__vector__iterator.html#a9c625c62332f092b25daa13535cb15e5">00490</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">vector_type::size_type</a> <a class="code" href="classconst__vector__iterator.html#a9c625c62332f092b25daa13535cb15e5">size_type</a>;
<a name="l00491"></a><a class="code" href="classconst__vector__iterator.html#a594a181f508d290e83a3e329013c5a4f">00491</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#a02d34518b2a1428147a358d3a019efbf">vector_type::difference_type</a> <a class="code" href="classconst__vector__iterator.html#a594a181f508d290e83a3e329013c5a4f">difference_type</a>;
<a name="l00492"></a><a class="code" href="classconst__vector__iterator.html#a591e0e9ec62387ab991a7205890d9ac4">00492</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">vector_type::value_type</a> <a class="code" href="classconst__vector__iterator.html#a591e0e9ec62387ab991a7205890d9ac4">value_type</a>;
<a name="l00493"></a><a class="code" href="classconst__vector__iterator.html#a1059a3cddece04ce5927994aeaa0f693">00493</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#ab1387877afd358151c6b6b8867d40fa6" title="constant reference to value_type">vector_type::const_reference</a> <a class="code" href="classconst__vector__iterator.html#a1059a3cddece04ce5927994aeaa0f693">reference</a>;
<a name="l00494"></a><a class="code" href="classconst__vector__iterator.html#a8efca8608ce99230f3ed6ea9c757c74f">00494</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#ab1387877afd358151c6b6b8867d40fa6" title="constant reference to value_type">vector_type::const_reference</a> <a class="code" href="classconst__vector__iterator.html#a8efca8608ce99230f3ed6ea9c757c74f">const_reference</a>;
<a name="l00495"></a><a class="code" href="classconst__vector__iterator.html#afa30b398934b031315037418c049ae0f">00495</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#a2f47dad8340cde2b655189944426a5bb" title="constant pointer to value_type">vector_type::const_pointer</a> <a class="code" href="classconst__vector__iterator.html#afa30b398934b031315037418c049ae0f">pointer</a>;
<a name="l00496"></a><a class="code" href="classconst__vector__iterator.html#abd5b80fff2d16ca0400e97345d99610c">00496</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html#a2f47dad8340cde2b655189944426a5bb" title="constant pointer to value_type">vector_type::const_pointer</a> <a class="code" href="classconst__vector__iterator.html#abd5b80fff2d16ca0400e97345d99610c">const_pointer</a>;
<a name="l00497"></a>00497 <span class="comment"></span>
<a name="l00498"></a>00498 <span class="comment">    //! \}</span>
<a name="l00499"></a>00499 <span class="comment"></span>
<a name="l00500"></a>00500 <span class="keyword">protected</span>:
<a name="l00501"></a><a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">00501</a>     <a class="code" href="classdouble__blocked__index.html">blocked_index_type</a> <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>;
<a name="l00502"></a><a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">00502</a>     <span class="keyword">const</span> <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector_type</a>* <a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>;
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="keyword">private</span>:<span class="comment"></span>
<a name="l00505"></a>00505 <span class="comment">    //! private constructor for initializing other iterators</span>
<a name="l00506"></a><a class="code" href="classconst__vector__iterator.html#a343127b9c2512e6e5b96f2de7ec3b1f8">00506</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html#ae629175243907e4a75209ad72d3a7219" title="constructs invalid iterator">const_vector_iterator</a>(<span class="keyword">const</span> <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector_type</a>* v, <a class="code" href="classconst__vector__iterator.html#a9c625c62332f092b25daa13535cb15e5">size_type</a> o)
<a name="l00507"></a>00507     : <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>(o), <a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>(v) {
<a name="l00508"></a>00508     }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l00511"></a>00511 <span class="comment">    //! constructs invalid iterator</span>
<a name="l00512"></a><a class="code" href="classconst__vector__iterator.html#ae629175243907e4a75209ad72d3a7219">00512</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html#ae629175243907e4a75209ad72d3a7219" title="constructs invalid iterator">const_vector_iterator</a>()
<a name="l00513"></a>00513     : <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>(0), <a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>(NULL) {
<a name="l00514"></a>00514     }<span class="comment"></span>
<a name="l00515"></a>00515 <span class="comment">    //! copy-constructor</span>
<a name="l00516"></a><a class="code" href="classconst__vector__iterator.html#ae9eaa1c9032e00c987ece694432e3097">00516</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html#ae629175243907e4a75209ad72d3a7219" title="constructs invalid iterator">const_vector_iterator</a>(<span class="keyword">const</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)
<a name="l00517"></a>00517     : <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>(a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>), <a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>(a.<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>) {
<a name="l00518"></a>00518     }<span class="comment"></span>
<a name="l00519"></a>00519 <span class="comment">    //! copy-constructor from mutable iterator</span>
<a name="l00520"></a><a class="code" href="classconst__vector__iterator.html#ac813c82c0927fb8014096942e2aaef00">00520</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html#ae629175243907e4a75209ad72d3a7219" title="constructs invalid iterator">const_vector_iterator</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">mutable_self_type</a>&amp; a)
<a name="l00521"></a>00521     : <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>(a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>), <a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>(a.<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>) {
<a name="l00522"></a>00522     }
<a name="l00523"></a>00523 <span class="comment"></span>
<a name="l00524"></a>00524 <span class="comment">    //! \name Iterator Properties</span>
<a name="l00525"></a>00525 <span class="comment">    //! \{</span>
<a name="l00526"></a>00526 <span class="comment"></span><span class="comment"></span>
<a name="l00527"></a>00527 <span class="comment">    //! return pointer to vector containing iterator</span>
<a name="l00528"></a><a class="code" href="classconst__vector__iterator.html#a96a23c9235a618a8f4f0070920642ec8">00528</a> <span class="comment"></span>    <span class="keyword">const</span> <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector_type</a> * <a class="code" href="classconst__vector__iterator.html#a96a23c9235a618a8f4f0070920642ec8" title="return pointer to vector containing iterator">parent_vector</a>()<span class="keyword"> const </span>{
<a name="l00529"></a>00529         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>;
<a name="l00530"></a>00530     }<span class="comment"></span>
<a name="l00531"></a>00531 <span class="comment">    //! return block offset of current element</span>
<a name="l00532"></a><a class="code" href="classconst__vector__iterator.html#ace79aa609270d4a05bdb417ca26767a5">00532</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html#ada46f69b46d9a37f1833d7994cf9ea1a">block_offset_type</a> <a class="code" href="classconst__vector__iterator.html#ace79aa609270d4a05bdb417ca26767a5" title="return block offset of current element">block_offset</a>()<span class="keyword"> const </span>{
<a name="l00533"></a>00533         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="classconst__vector__iterator.html#ada46f69b46d9a37f1833d7994cf9ea1a">block_offset_type</a><span class="keyword">&gt;</span> (<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>.<a class="code" href="classdouble__blocked__index.html#ab2aae63d414d2b771b3cb6fff9f279cc">get_offset</a>());
<a name="l00534"></a>00534     }<span class="comment"></span>
<a name="l00535"></a>00535 <span class="comment">    //! return iterator to stxxl::BID containg current element</span>
<a name="l00536"></a><a class="code" href="classconst__vector__iterator.html#a77fcbb32836ed70de43f92f7c017b1c7">00536</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html#ad02c6aead35e5cbd5e6cf568f4ffe7c8">bids_container_iterator</a> <a class="code" href="classconst__vector__iterator.html#a77fcbb32836ed70de43f92f7c017b1c7" title="return iterator to stxxl::BID containg current element">bid</a>()<span class="keyword"> const </span>{
<a name="l00537"></a>00537         <span class="keywordflow">return</span> ((<a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector_type</a>*) <a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>)-&gt;bid(<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>);
<a name="l00538"></a>00538     }
<a name="l00539"></a>00539 <span class="comment"></span>
<a name="l00540"></a>00540 <span class="comment">    //! \}</span>
<a name="l00541"></a>00541 <span class="comment"></span><span class="comment"></span>
<a name="l00542"></a>00542 <span class="comment">    //! \name Access Operators</span>
<a name="l00543"></a>00543 <span class="comment">    //! \{</span>
<a name="l00544"></a>00544 <span class="comment"></span><span class="comment"></span>
<a name="l00545"></a>00545 <span class="comment">    //! return current element</span>
<a name="l00546"></a><a class="code" href="classconst__vector__iterator.html#aeccf0b15351a0bdd6acd5fd5dfcad932">00546</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html#a8efca8608ce99230f3ed6ea9c757c74f">const_reference</a> <a class="code" href="classconst__vector__iterator.html#aeccf0b15351a0bdd6acd5fd5dfcad932" title="return current element">operator *</a>()<span class="keyword"> const </span>{
<a name="l00547"></a>00547         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>-&gt;<a class="code" href="classvector.html#a606834d73c078850aba1ce9f750a3ac7">const_element</a>(<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>);
<a name="l00548"></a>00548     }<span class="comment"></span>
<a name="l00549"></a>00549 <span class="comment">    //! return pointer to current element</span>
<a name="l00550"></a><a class="code" href="classconst__vector__iterator.html#a11f6bed81176109299c18f014aa72ae5">00550</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html#abd5b80fff2d16ca0400e97345d99610c">const_pointer</a> <a class="code" href="classconst__vector__iterator.html#a11f6bed81176109299c18f014aa72ae5" title="return pointer to current element">operator -&gt; </a>()<span class="keyword"> const </span>{
<a name="l00551"></a>00551         <span class="keywordflow">return</span> &amp;(<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>-&gt;<a class="code" href="classvector.html#a606834d73c078850aba1ce9f750a3ac7">const_element</a>(<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>));
<a name="l00552"></a>00552     }<span class="comment"></span>
<a name="l00553"></a>00553 <span class="comment">    //! return const reference to element +i after the current element</span>
<a name="l00554"></a><a class="code" href="classconst__vector__iterator.html#ae719a7327b98d4ca955004d655466690">00554</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html#a8efca8608ce99230f3ed6ea9c757c74f">const_reference</a> <a class="code" href="classconst__vector__iterator.html#ae719a7327b98d4ca955004d655466690" title="return const reference to element +i after the current element">operator [] </a>(<a class="code" href="classconst__vector__iterator.html#a9c625c62332f092b25daa13535cb15e5">size_type</a> i)<span class="keyword"> const </span>{
<a name="l00555"></a>00555         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>-&gt;<a class="code" href="classvector.html#a606834d73c078850aba1ce9f750a3ac7">const_element</a>(<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>.<a class="code" href="classdouble__blocked__index.html#a7060ab1819ce0b998152781efc863ea9">get_pos</a>() + i);
<a name="l00556"></a>00556     }
<a name="l00557"></a>00557 <span class="comment"></span>
<a name="l00558"></a>00558 <span class="comment">    //! \}</span>
<a name="l00559"></a>00559 <span class="comment"></span><span class="comment"></span>
<a name="l00560"></a>00560 <span class="comment">    //! \name Relative Calculation of Iterators</span>
<a name="l00561"></a>00561 <span class="comment">    //! \{</span>
<a name="l00562"></a>00562 <span class="comment"></span><span class="comment"></span>
<a name="l00563"></a>00563 <span class="comment">    //! calculate different between two iterator</span>
<a name="l00564"></a><a class="code" href="classconst__vector__iterator.html#a9173c554656c12af9c3d39ded725f086">00564</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html#a594a181f508d290e83a3e329013c5a4f">difference_type</a> <a class="code" href="classconst__vector__iterator.html#a9173c554656c12af9c3d39ded725f086" title="calculate different between two iterator">operator -</a>(<span class="keyword">const</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00565"></a>00565         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> - a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>;
<a name="l00566"></a>00566     }<span class="comment"></span>
<a name="l00567"></a>00567 <span class="comment">    //! calculate different between two iterator</span>
<a name="l00568"></a><a class="code" href="classconst__vector__iterator.html#aebd2171d2f7f8b11f796d019b1b6b767">00568</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html#a594a181f508d290e83a3e329013c5a4f">difference_type</a> <a class="code" href="classconst__vector__iterator.html#a9173c554656c12af9c3d39ded725f086" title="calculate different between two iterator">operator -</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">mutable_self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00569"></a>00569         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> - a.<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>;
<a name="l00570"></a>00570     }<span class="comment"></span>
<a name="l00571"></a>00571 <span class="comment">    //! return iterator advanced -i positions in the vector</span>
<a name="l00572"></a><a class="code" href="classconst__vector__iterator.html#ac94cb83815e11966c662ae36a41d8eca">00572</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a> <a class="code" href="classconst__vector__iterator.html#a9173c554656c12af9c3d39ded725f086" title="calculate different between two iterator">operator -</a>(<a class="code" href="classconst__vector__iterator.html#a9c625c62332f092b25daa13535cb15e5">size_type</a> i)<span class="keyword"> const </span>{
<a name="l00573"></a>00573         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#a1bdc428ef8193709d68499ad9b5fd54e">self_type</a>(<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>, <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>.<a class="code" href="classdouble__blocked__index.html#a7060ab1819ce0b998152781efc863ea9">get_pos</a>() - i);
<a name="l00574"></a>00574     }<span class="comment"></span>
<a name="l00575"></a>00575 <span class="comment">    //! return iterator advanced +i positions in the vector</span>
<a name="l00576"></a><a class="code" href="classconst__vector__iterator.html#a5367f862a836293d12c39171d80adf46">00576</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a> <a class="code" href="classconst__vector__iterator.html#a5367f862a836293d12c39171d80adf46" title="return iterator advanced +i positions in the vector">operator +</a>(<a class="code" href="classconst__vector__iterator.html#a9c625c62332f092b25daa13535cb15e5">size_type</a> i)<span class="keyword"> const </span>{
<a name="l00577"></a>00577         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#a1bdc428ef8193709d68499ad9b5fd54e">self_type</a>(<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>, <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>.<a class="code" href="classdouble__blocked__index.html#a7060ab1819ce0b998152781efc863ea9">get_pos</a>() + i);
<a name="l00578"></a>00578     }<span class="comment"></span>
<a name="l00579"></a>00579 <span class="comment">    //! advance this iterator -i positions in the vector</span>
<a name="l00580"></a><a class="code" href="classconst__vector__iterator.html#ac30508c2c8c816f88a7458229b425d2c">00580</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; <a class="code" href="classconst__vector__iterator.html#ac30508c2c8c816f88a7458229b425d2c" title="advance this iterator -i positions in the vector">operator -=</a>(<a class="code" href="classconst__vector__iterator.html#a9c625c62332f092b25daa13535cb15e5">size_type</a> i) {
<a name="l00581"></a>00581         <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> -= i;
<a name="l00582"></a>00582         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00583"></a>00583     }<span class="comment"></span>
<a name="l00584"></a>00584 <span class="comment">    //! advance this iterator +i positions in the vector</span>
<a name="l00585"></a><a class="code" href="classconst__vector__iterator.html#a9307bf6ff408033ae35c82c95f564ac9">00585</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; <a class="code" href="classconst__vector__iterator.html#a9307bf6ff408033ae35c82c95f564ac9" title="advance this iterator +i positions in the vector">operator +=</a>(<a class="code" href="classconst__vector__iterator.html#a9c625c62332f092b25daa13535cb15e5">size_type</a> i) {
<a name="l00586"></a>00586         <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> += i;
<a name="l00587"></a>00587         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00588"></a>00588     }<span class="comment"></span>
<a name="l00589"></a>00589 <span class="comment">    //! advance this iterator to next position in the vector</span>
<a name="l00590"></a><a class="code" href="classconst__vector__iterator.html#a43f0767d638e93c3a741937f6e0e6e04">00590</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; <a class="code" href="classconst__vector__iterator.html#a43f0767d638e93c3a741937f6e0e6e04" title="advance this iterator to next position in the vector">operator ++</a>() {
<a name="l00591"></a>00591         <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>++;
<a name="l00592"></a>00592         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00593"></a>00593     }<span class="comment"></span>
<a name="l00594"></a>00594 <span class="comment">    //! advance this iterator to next position in the vector</span>
<a name="l00595"></a><a class="code" href="classconst__vector__iterator.html#ac27862bd4b9d58d4183a1406f8fd9389">00595</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a> <a class="code" href="classconst__vector__iterator.html#a43f0767d638e93c3a741937f6e0e6e04" title="advance this iterator to next position in the vector">operator ++</a>(<span class="keywordtype">int</span>) {
<a name="l00596"></a>00596         <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a> tmp_ = *<span class="keyword">this</span>;
<a name="l00597"></a>00597         <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>++;
<a name="l00598"></a>00598         <span class="keywordflow">return</span> tmp_;
<a name="l00599"></a>00599     }<span class="comment"></span>
<a name="l00600"></a>00600 <span class="comment">    //! advance this iterator to preceding position in the vector</span>
<a name="l00601"></a><a class="code" href="classconst__vector__iterator.html#ab4bcd85110a76a1fc65e5ebded3d4355">00601</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; <a class="code" href="classconst__vector__iterator.html#ab4bcd85110a76a1fc65e5ebded3d4355" title="advance this iterator to preceding position in the vector">operator --</a>() {
<a name="l00602"></a>00602         <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>--;
<a name="l00603"></a>00603         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00604"></a>00604     }<span class="comment"></span>
<a name="l00605"></a>00605 <span class="comment">    //! advance this iterator to preceding position in the vector</span>
<a name="l00606"></a><a class="code" href="classconst__vector__iterator.html#ac697d88321ccae3812b0d3517bb9f833">00606</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a> <a class="code" href="classconst__vector__iterator.html#ab4bcd85110a76a1fc65e5ebded3d4355" title="advance this iterator to preceding position in the vector">operator --</a>(<span class="keywordtype">int</span>) {
<a name="l00607"></a>00607         <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a> tmp = *<span class="keyword">this</span>;
<a name="l00608"></a>00608         <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>--;
<a name="l00609"></a>00609         <span class="keywordflow">return</span> tmp;
<a name="l00610"></a>00610     }
<a name="l00611"></a>00611 <span class="comment"></span>
<a name="l00612"></a>00612 <span class="comment">    //! \}</span>
<a name="l00613"></a>00613 <span class="comment"></span><span class="comment"></span>
<a name="l00614"></a>00614 <span class="comment">    //! \name Comparison Operators</span>
<a name="l00615"></a>00615 <span class="comment">    //! \{</span>
<a name="l00616"></a><a class="code" href="classconst__vector__iterator.html#abb97cc5a30feb922cf84dc9ffd65a42f">00616</a> <span class="comment"></span>    <span class="keywordtype">bool</span> <a class="code" href="classconst__vector__iterator.html#abb97cc5a30feb922cf84dc9ffd65a42f">operator ==</a>(<span class="keyword">const</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00617"></a>00617         assert(<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a> == a.<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>);
<a name="l00618"></a>00618         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> == a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>;
<a name="l00619"></a>00619     }
<a name="l00620"></a><a class="code" href="classconst__vector__iterator.html#abb1045986e554e625baa3b074dbd5719">00620</a>     <span class="keywordtype">bool</span> <a class="code" href="classconst__vector__iterator.html#abb1045986e554e625baa3b074dbd5719">operator !=</a>(<span class="keyword">const</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00621"></a>00621         assert(<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a> == a.<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>);
<a name="l00622"></a>00622         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> != a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>;
<a name="l00623"></a>00623     }
<a name="l00624"></a><a class="code" href="classconst__vector__iterator.html#a122cc37e0c6dae38838bf72015643944">00624</a>     <span class="keywordtype">bool</span> <a class="code" href="classconst__vector__iterator.html#a122cc37e0c6dae38838bf72015643944">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00625"></a>00625         assert(<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a> == a.<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>);
<a name="l00626"></a>00626         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> &lt; a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>;
<a name="l00627"></a>00627     }
<a name="l00628"></a><a class="code" href="classconst__vector__iterator.html#a503f77bedd0a5fb00648b0452cbf9c59">00628</a>     <span class="keywordtype">bool</span> <a class="code" href="classconst__vector__iterator.html#a503f77bedd0a5fb00648b0452cbf9c59">operator &lt;=</a>(<span class="keyword">const</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00629"></a>00629         assert(<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a> == a.<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>);
<a name="l00630"></a>00630         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> &lt;= a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>;
<a name="l00631"></a>00631     }
<a name="l00632"></a><a class="code" href="classconst__vector__iterator.html#a2515bbcf239032a188ffeb598606d88e">00632</a>     <span class="keywordtype">bool</span> <a class="code" href="classconst__vector__iterator.html#a2515bbcf239032a188ffeb598606d88e">operator&gt;</a>(<span class="keyword">const</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00633"></a>00633         assert(<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a> == a.<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>);
<a name="l00634"></a>00634         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> &gt; a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>;
<a name="l00635"></a>00635     }
<a name="l00636"></a><a class="code" href="classconst__vector__iterator.html#ab4a88dc624a0dab3795af5af612ed010">00636</a>     <span class="keywordtype">bool</span> <a class="code" href="classconst__vector__iterator.html#ab4a88dc624a0dab3795af5af612ed010">operator &gt;=</a>(<span class="keyword">const</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00637"></a>00637         assert(<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a> == a.<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>);
<a name="l00638"></a>00638         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> &gt;= a.<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>;
<a name="l00639"></a>00639     }
<a name="l00640"></a><a class="code" href="classconst__vector__iterator.html#a7e7fda04d2531d23ad1a5208c6469b00">00640</a>     <span class="keywordtype">bool</span> <a class="code" href="classconst__vector__iterator.html#abb97cc5a30feb922cf84dc9ffd65a42f">operator ==</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">mutable_self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00641"></a>00641         assert(<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a> == a.<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>);
<a name="l00642"></a>00642         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> == a.<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>;
<a name="l00643"></a>00643     }
<a name="l00644"></a><a class="code" href="classconst__vector__iterator.html#a7e356290e5a261de74646f42694624cf">00644</a>     <span class="keywordtype">bool</span> <a class="code" href="classconst__vector__iterator.html#abb1045986e554e625baa3b074dbd5719">operator !=</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">mutable_self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00645"></a>00645         assert(<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a> == a.<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>);
<a name="l00646"></a>00646         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> != a.<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>;
<a name="l00647"></a>00647     }
<a name="l00648"></a><a class="code" href="classconst__vector__iterator.html#aec9475d7167512220a98f37fe82f97fe">00648</a>     <span class="keywordtype">bool</span> <a class="code" href="classconst__vector__iterator.html#aec9475d7167512220a98f37fe82f97fe">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">mutable_self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00649"></a>00649         assert(<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a> == a.<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>);
<a name="l00650"></a>00650         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> &lt; a.<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>;
<a name="l00651"></a>00651     }
<a name="l00652"></a><a class="code" href="classconst__vector__iterator.html#acc7cbe0d248444660c8f22006b2c6dca">00652</a>     <span class="keywordtype">bool</span> <a class="code" href="classconst__vector__iterator.html#a503f77bedd0a5fb00648b0452cbf9c59">operator &lt;=</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">mutable_self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00653"></a>00653         assert(<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a> == a.<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>);
<a name="l00654"></a>00654         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> &lt;= a.<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>;
<a name="l00655"></a>00655     }
<a name="l00656"></a><a class="code" href="classconst__vector__iterator.html#a4c5c04d15de0f55810433df6a2215442">00656</a>     <span class="keywordtype">bool</span> <a class="code" href="classconst__vector__iterator.html#a4c5c04d15de0f55810433df6a2215442">operator&gt;</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">mutable_self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00657"></a>00657         assert(<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a> == a.<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>);
<a name="l00658"></a>00658         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> &gt; a.<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>;
<a name="l00659"></a>00659     }
<a name="l00660"></a><a class="code" href="classconst__vector__iterator.html#a006420c9c84560958d904440e9ff2a64">00660</a>     <span class="keywordtype">bool</span> <a class="code" href="classconst__vector__iterator.html#ab4a88dc624a0dab3795af5af612ed010">operator &gt;=</a>(<span class="keyword">const</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">mutable_self_type</a>&amp; a)<span class="keyword"> const </span>{
<a name="l00661"></a>00661         assert(<a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a> == a.<a class="code" href="classvector__iterator.html#a3a0e5e117402435bc57bff580e1d1a50">p_vector</a>);
<a name="l00662"></a>00662         <span class="keywordflow">return</span> <a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a> &gt;= a.<a class="code" href="classvector__iterator.html#ad40fb379bd332aef3a377721311b795d">offset</a>;
<a name="l00663"></a>00663     }
<a name="l00664"></a>00664 <span class="comment"></span>
<a name="l00665"></a>00665 <span class="comment">    //! \}</span>
<a name="l00666"></a>00666 <span class="comment"></span><span class="comment"></span>
<a name="l00667"></a>00667 <span class="comment">    //! \name Flushing Operation</span>
<a name="l00668"></a>00668 <span class="comment">    //! \{</span>
<a name="l00669"></a><a class="code" href="classconst__vector__iterator.html#a057e85b09599c736e4318b1660ef5337">00669</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classconst__vector__iterator.html#a057e85b09599c736e4318b1660ef5337">block_externally_updated</a>() {
<a name="l00670"></a>00670         <a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>-&gt;<a class="code" href="classvector.html#a4b2645e4c1afd03149aeb7b8975a2e17">block_externally_updated</a>(<a class="code" href="classconst__vector__iterator.html#af5f7066b3f69586f4795fae657846b19">offset</a>);
<a name="l00671"></a>00671     }
<a name="l00672"></a><a class="code" href="classconst__vector__iterator.html#a1a397defba969b14c0e6c9b3bc1d70a5">00672</a>     <span class="keywordtype">void</span> <a class="code" href="classconst__vector__iterator.html#a1a397defba969b14c0e6c9b3bc1d70a5">flush</a>() {
<a name="l00673"></a>00673         <a class="code" href="classconst__vector__iterator.html#a6569a78d6052784f73ab2f43bb4d2b97">p_vector</a>-&gt;<a class="code" href="classvector.html#a08276777f1d54845546843d77f402904" title="Flushes the cache pages to the external memory.">flush</a>();
<a name="l00674"></a>00674     }
<a name="l00675"></a>00675 <span class="comment"></span>
<a name="l00676"></a>00676 <span class="comment">    //! \}</span>
<a name="l00677"></a>00677 <span class="comment"></span>};
<a name="l00678"></a>00678 <span class="comment"></span>
<a name="l00679"></a>00679 <span class="comment">////////////////////////////////////////////////////////////////////////////</span>
<a name="l00680"></a>00680 <span class="comment"></span><span class="comment"></span>
<a name="l00681"></a>00681 <span class="comment">//! \brief External vector container. \n</span>
<a name="l00682"></a>00682 <span class="comment">//! &lt;b&gt;Introduction&lt;/b&gt; to vector container: see \ref tutorial_vector tutorial. \n</span>
<a name="l00683"></a>00683 <span class="comment">//! &lt;b&gt;Design and Internals&lt;/b&gt; of vector container: see \ref design_vector</span>
<a name="l00684"></a>00684 <span class="comment">//!</span>
<a name="l00685"></a>00685 <span class="comment">//! For semantics of the methods see documentation of the STL std::vector</span>
<a name="l00686"></a>00686 <span class="comment">//! \tparam ValueType type of contained objects (POD with no references to internal memory)</span>
<a name="l00687"></a>00687 <span class="comment">//! \tparam PageSize number of blocks in a page</span>
<a name="l00688"></a>00688 <span class="comment">//! \tparam PagerType pager type, \c random_pager&lt;x&gt; or \c lru_pager&lt;x&gt;, where x is the default number of pages,</span>
<a name="l00689"></a>00689 <span class="comment">//!  default is \c lru_pager&lt;8&gt;</span>
<a name="l00690"></a>00690 <span class="comment">//! \tparam BlockSize external block size in bytes, default is 2 MiB</span>
<a name="l00691"></a>00691 <span class="comment">//! \tparam AllocStr one of allocation strategies: \c striping , \c RC , \c SR , or \c FR</span>
<a name="l00692"></a>00692 <span class="comment">//!  default is RC</span>
<a name="l00693"></a>00693 <span class="comment">//!</span>
<a name="l00694"></a>00694 <span class="comment">//! Memory consumption: BlockSize*x*PageSize bytes</span>
<a name="l00695"></a>00695 <span class="comment">//! \warning Do not store references to the elements of an external vector. Such references</span>
<a name="l00696"></a>00696 <span class="comment">//! might be invalidated during any following access to elements of the vector</span>
<a name="l00697"></a>00697 <span class="comment"></span><span class="keyword">template</span> &lt;
<a name="l00698"></a>00698 <span class="keyword">typename</span> ValueType,
<a name="l00699"></a>00699 <span class="keywordtype">unsigned</span> PageSize = 4,
<a name="l00700"></a>00700 <span class="keyword">typename</span> PagerType = stxxl::lru_pager&lt;1&gt;,
<a name="l00701"></a>00701 <span class="keywordtype">unsigned</span> BlockSize = STXXL_DEFAULT_BLOCK_SIZE(ValueType),
<a name="l00702"></a>00702 <span class="keyword">typename</span> AllocStr = STXXL_DEFAULT_ALLOC_STRATEGY,
<a name="l00703"></a>00703 <span class="keyword">typename</span> SizeType = stxxl::uint64 <span class="comment">// will be deprecated soon</span>
<a name="l00704"></a>00704 &gt;
<a name="l00705"></a><a class="code" href="classvector.html">00705</a> <span class="keyword">class </span><a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector</a> {
<a name="l00706"></a>00706 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l00707"></a>00707 <span class="comment">    //! \name Standard Types</span>
<a name="l00708"></a>00708 <span class="comment">    //! \{</span>
<a name="l00709"></a>00709 <span class="comment"></span><span class="comment"></span>
<a name="l00710"></a>00710 <span class="comment">    //! The type of elements stored in the vector.</span>
<a name="l00711"></a><a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029">00711</a> <span class="comment"></span>    <span class="keyword">typedef</span> ValueType <a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">value_type</a>;<span class="comment"></span>
<a name="l00712"></a>00712 <span class="comment">    //! reference to value_type</span>
<a name="l00713"></a><a class="code" href="classvector.html#a7d234f8da8ce66aacfe18001d887e4cf">00713</a> <span class="comment"></span>    <span class="keyword">typedef</span> <a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">value_type</a>&amp; <a class="code" href="classvector.html#a7d234f8da8ce66aacfe18001d887e4cf" title="reference to value_type">reference</a>;<span class="comment"></span>
<a name="l00714"></a>00714 <span class="comment">    //! constant reference to value_type</span>
<a name="l00715"></a><a class="code" href="classvector.html#ab1387877afd358151c6b6b8867d40fa6">00715</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">value_type</a>&amp; <a class="code" href="classvector.html#ab1387877afd358151c6b6b8867d40fa6" title="constant reference to value_type">const_reference</a>;<span class="comment"></span>
<a name="l00716"></a>00716 <span class="comment">    //! pointer to value_type</span>
<a name="l00717"></a><a class="code" href="classvector.html#a1b3713b0f86bdb4f7e5f93d4b6c2530e">00717</a> <span class="comment"></span>    <span class="keyword">typedef</span> <a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">value_type</a>* <a class="code" href="classvector.html#a1b3713b0f86bdb4f7e5f93d4b6c2530e" title="pointer to value_type">pointer</a>;<span class="comment"></span>
<a name="l00718"></a>00718 <span class="comment">    //! constant pointer to value_type</span>
<a name="l00719"></a><a class="code" href="classvector.html#a2f47dad8340cde2b655189944426a5bb">00719</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">value_type</a>* <a class="code" href="classvector.html#a2f47dad8340cde2b655189944426a5bb" title="constant pointer to value_type">const_pointer</a>;<span class="comment"></span>
<a name="l00720"></a>00720 <span class="comment">    //! an unsigned 64-bit integral type</span>
<a name="l00721"></a><a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3">00721</a> <span class="comment"></span>    <span class="keyword">typedef</span> SizeType <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>;
<a name="l00722"></a><a class="code" href="classvector.html#a02d34518b2a1428147a358d3a019efbf">00722</a>     <span class="keyword">typedef</span> stxxl::int64 <a class="code" href="classvector.html#a02d34518b2a1428147a358d3a019efbf">difference_type</a>;
<a name="l00723"></a>00723 
<a name="l00724"></a><a class="code" href="classvector.html#a536cc2505df2fd69a3c035fbfe069df2">00724</a>     <span class="keyword">typedef</span> PagerType <a class="code" href="classvector.html#a536cc2505df2fd69a3c035fbfe069df2">pager_type</a>;
<a name="l00725"></a><a class="code" href="classvector.html#a361ba78ad3101dcb3fd2f2aef77dc6fc">00725</a>     <span class="keyword">typedef</span> AllocStr <a class="code" href="classvector.html#a361ba78ad3101dcb3fd2f2aef77dc6fc">alloc_strategy_type</a>;
<a name="l00726"></a><a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352">00726</a>     <span class="keyword">enum</span> <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352">constants</a> {
<a name="l00727"></a><a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a66830a503ccbc47736f18c498fd440ec">00727</a>         <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a66830a503ccbc47736f18c498fd440ec">block_size</a> = BlockSize,
<a name="l00728"></a><a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">00728</a>         <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a> = PageSize,
<a name="l00729"></a><a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a86d6dc0e6dae77e956822ccd989c8e75">00729</a>         <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a86d6dc0e6dae77e956822ccd989c8e75">on_disk</a> = -1
<a name="l00730"></a>00730     };
<a name="l00731"></a>00731 <span class="comment"></span>
<a name="l00732"></a>00732 <span class="comment">    //! iterator used to iterate through a vector, see \ref design_vector_notes.</span>
<a name="l00733"></a>00733 <span class="comment"></span>    <span class="keyword">typedef</span> <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">vector_iterator</a>&lt;<a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">value_type</a>, <a class="code" href="classvector.html#a361ba78ad3101dcb3fd2f2aef77dc6fc">alloc_strategy_type</a>, <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>,
<a name="l00734"></a><a class="code" href="classvector.html#ad44a127aabeaa7a573f0c193b9f1b093">00734</a>     <a class="code" href="classvector.html#a02d34518b2a1428147a358d3a019efbf">difference_type</a>, <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a66830a503ccbc47736f18c498fd440ec">block_size</a>, <a class="code" href="classvector.html#a536cc2505df2fd69a3c035fbfe069df2">pager_type</a>, <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>&gt; <a class="code" href="classvector.html#ad44a127aabeaa7a573f0c193b9f1b093" title="iterator used to iterate through a vector, see More Notes.">iterator</a>;
<a name="l00735"></a><a class="code" href="classvector.html#aba1666dedaee1e78197a2ebd5f40a67f">00735</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">vector_iterator</a>&lt;<a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">value_type</a>, <a class="code" href="classvector.html#a361ba78ad3101dcb3fd2f2aef77dc6fc">alloc_strategy_type</a>, <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>, <a class="code" href="classvector.html#a02d34518b2a1428147a358d3a019efbf">difference_type</a>, <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a66830a503ccbc47736f18c498fd440ec">block_size</a>, <a class="code" href="classvector.html#a536cc2505df2fd69a3c035fbfe069df2">pager_type</a>, <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>&gt;;
<a name="l00736"></a>00736 <span class="comment"></span>
<a name="l00737"></a>00737 <span class="comment">    //! constant iterator used to iterate through a vector, see \ref design_vector_notes.</span>
<a name="l00738"></a>00738 <span class="comment"></span>    <span class="keyword">typedef</span> <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_vector_iterator</a>&lt;<a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">value_type</a>, <a class="code" href="classvector.html#a361ba78ad3101dcb3fd2f2aef77dc6fc">alloc_strategy_type</a>,
<a name="l00739"></a><a class="code" href="classvector.html#aa4028dfad10b3ba6322ed5ad588f2713">00739</a>     <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>, <a class="code" href="classvector.html#a02d34518b2a1428147a358d3a019efbf">difference_type</a>, <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a66830a503ccbc47736f18c498fd440ec">block_size</a>, <a class="code" href="classvector.html#a536cc2505df2fd69a3c035fbfe069df2">pager_type</a>, <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>&gt; <a class="code" href="classvector.html#aa4028dfad10b3ba6322ed5ad588f2713" title="constant iterator used to iterate through a vector, see More Notes.">const_iterator</a>;
<a name="l00740"></a><a class="code" href="classvector.html#a738e510609ada6117834c37e9b8acf0c">00740</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_vector_iterator</a>&lt;<a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">value_type</a>, <a class="code" href="classvector.html#a361ba78ad3101dcb3fd2f2aef77dc6fc">alloc_strategy_type</a>, <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>, <a class="code" href="classvector.html#a02d34518b2a1428147a358d3a019efbf">difference_type</a>, <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a66830a503ccbc47736f18c498fd440ec">block_size</a>, <a class="code" href="classvector.html#a536cc2505df2fd69a3c035fbfe069df2">pager_type</a>, <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>&gt;;
<a name="l00741"></a><a class="code" href="classvector.html#aa339b04394662dd990f847148927e08e">00741</a>     <span class="keyword">typedef</span> std::reverse_iterator&lt;iterator&gt; <a class="code" href="classvector.html#aa339b04394662dd990f847148927e08e">reverse_iterator</a>;
<a name="l00742"></a><a class="code" href="classvector.html#a1d133685550d866a9bf624c2098cfb2d">00742</a>     <span class="keyword">typedef</span> std::reverse_iterator&lt;const_iterator&gt; <a class="code" href="classvector.html#a1d133685550d866a9bf624c2098cfb2d">const_reverse_iterator</a>;
<a name="l00743"></a>00743 <span class="comment"></span>
<a name="l00744"></a>00744 <span class="comment">    //! \}</span>
<a name="l00745"></a>00745 <span class="comment"></span><span class="comment"></span>
<a name="l00746"></a>00746 <span class="comment">    //! \name Extra Types</span>
<a name="l00747"></a>00747 <span class="comment">    //! \{</span>
<a name="l00748"></a>00748 <span class="comment"></span><span class="comment"></span>
<a name="l00749"></a>00749 <span class="comment">    //! vector_bufwriter compatible with this vector</span>
<a name="l00750"></a><a class="code" href="classvector.html#a17b303d6362a1197b4cb039ce73015cd">00750</a> <span class="comment"></span>    <span class="keyword">typedef</span> <a class="code" href="classvector__bufwriter.html" title="Buffered sequential writer to a vector using overlapped I/O.">vector_bufwriter&lt;iterator&gt;</a> <a class="code" href="classvector.html#a17b303d6362a1197b4cb039ce73015cd" title="vector_bufwriter compatible with this vector">bufwriter_type</a>;
<a name="l00751"></a>00751 <span class="comment"></span>
<a name="l00752"></a>00752 <span class="comment">    //! vector_bufreader compatible with this vector</span>
<a name="l00753"></a><a class="code" href="classvector.html#a73bc2a4348cf178fe4488ca83d0e6d1f">00753</a> <span class="comment"></span>    <span class="keyword">typedef</span> <a class="code" href="classvector__bufreader.html" title="Buffered sequential reader from a vector using overlapped I/O.">vector_bufreader&lt;const_iterator&gt;</a> <a class="code" href="classvector.html#a73bc2a4348cf178fe4488ca83d0e6d1f" title="vector_bufreader compatible with this vector">bufreader_type</a>;
<a name="l00754"></a>00754 <span class="comment"></span>
<a name="l00755"></a>00755 <span class="comment">    //! vector_bufreader compatible with this vector</span>
<a name="l00756"></a><a class="code" href="classvector.html#a4407beb443590b73160c2c25e9f204e3">00756</a> <span class="comment"></span>    <span class="keyword">typedef</span> <a class="code" href="classvector__bufreader__reverse.html" title="Buffered sequential reverse reader from a vector using overlapped I/O.">vector_bufreader_reverse&lt;const_iterator&gt;</a> <a class="code" href="classvector.html#a4407beb443590b73160c2c25e9f204e3" title="vector_bufreader compatible with this vector">bufreader_reverse_type</a>;
<a name="l00757"></a>00757 <span class="comment"></span>
<a name="l00758"></a>00758 <span class="comment">    //! \internal</span>
<a name="l00759"></a><a class="code" href="classvector_1_1bid__vector.html">00759</a> <span class="comment"></span>    <span class="keyword">class </span><a class="code" href="classvector_1_1bid__vector.html">bid_vector</a> : <span class="keyword">public</span> std::<a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector</a>&lt;stxxl::BID&lt;block_size&gt; &gt; {
<a name="l00760"></a>00760     <span class="keyword">public</span>:
<a name="l00761"></a><a class="code" href="classvector_1_1bid__vector.html#a1458e7ab3aa61ac515ac985cbc261597">00761</a>         <span class="keyword">typedef</span> std::vector&lt;stxxl::BID&lt;block_size&gt; &gt; <a class="code" href="classvector_1_1bid__vector.html#a1458e7ab3aa61ac515ac985cbc261597">super_type</a>;
<a name="l00762"></a><a class="code" href="classvector_1_1bid__vector.html#a7ab1cec499de77fff1848a7a018ae63d">00762</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> super_type::size_type <a class="code" href="classvector_1_1bid__vector.html#a7ab1cec499de77fff1848a7a018ae63d">size_type</a>;
<a name="l00763"></a><a class="code" href="classvector_1_1bid__vector.html#adfbf24f2fb99176ba1b6ddbfb6fce504">00763</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> super_type::value_type <a class="code" href="classvector_1_1bid__vector.html#adfbf24f2fb99176ba1b6ddbfb6fce504">bid_type</a>;
<a name="l00764"></a><a class="code" href="classvector_1_1bid__vector.html#a0280063fee7ceee0c214f533969f81ea">00764</a>         <a class="code" href="classvector_1_1bid__vector.html#a0280063fee7ceee0c214f533969f81ea">bid_vector</a>(<a class="code" href="classvector_1_1bid__vector.html#a7ab1cec499de77fff1848a7a018ae63d">size_type</a> sz) : <a class="code" href="classvector_1_1bid__vector.html#a1458e7ab3aa61ac515ac985cbc261597">super_type</a>(sz) {
<a name="l00765"></a>00765         }
<a name="l00766"></a>00766     };
<a name="l00767"></a>00767 
<a name="l00768"></a><a class="code" href="classvector.html#a25bfe9d7656c553c9e003e709a857227">00768</a>     <span class="keyword">typedef</span> <a class="code" href="classvector_1_1bid__vector.html">bid_vector</a> <a class="code" href="classvector.html#a25bfe9d7656c553c9e003e709a857227">bids_container_type</a>;
<a name="l00769"></a><a class="code" href="classvector.html#a81fede0a4a86f8e21370dee34ddebdf0">00769</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> bids_container_type::iterator <a class="code" href="classvector.html#a81fede0a4a86f8e21370dee34ddebdf0">bids_container_iterator</a>;
<a name="l00770"></a><a class="code" href="classvector.html#affc6a4bd1a628053afe7d10226fc9e2e">00770</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> bids_container_type::const_iterator <a class="code" href="classvector.html#affc6a4bd1a628053afe7d10226fc9e2e">const_bids_container_iterator</a>;
<a name="l00771"></a>00771 <span class="comment"></span>
<a name="l00772"></a>00772 <span class="comment">    //! type of the block used in disk-memory transfers</span>
<a name="l00773"></a><a class="code" href="classvector.html#a202563e16860bc03b8fa49b7f9b1e244">00773</a> <span class="comment"></span>    <span class="keyword">typedef</span> stxxl::typed_block&lt;BlockSize, ValueType&gt; <a class="code" href="classvector.html#a202563e16860bc03b8fa49b7f9b1e244" title="type of the block used in disk-memory transfers">block_type</a>;<span class="comment"></span>
<a name="l00774"></a>00774 <span class="comment">    //! double-index type to reference individual elements in a block</span>
<a name="l00775"></a><a class="code" href="classvector.html#a9df497483a4b73a4f7c94b51396495ef">00775</a> <span class="comment"></span>    <span class="keyword">typedef</span> <a class="code" href="classdouble__blocked__index.html">double_blocked_index&lt;SizeType, PageSize, block_type::size&gt;</a> <a class="code" href="classvector.html#a9df497483a4b73a4f7c94b51396495ef" title="double-index type to reference individual elements in a block">blocked_index_type</a>;
<a name="l00776"></a>00776 <span class="comment"></span>
<a name="l00777"></a>00777 <span class="comment">    //! \}</span>
<a name="l00778"></a>00778 <span class="comment"></span>
<a name="l00779"></a>00779 <span class="keyword">private</span>:
<a name="l00780"></a><a class="code" href="classvector.html#a091ea919a4b861bfc822757f6b223407">00780</a>     <a class="code" href="classvector.html#a361ba78ad3101dcb3fd2f2aef77dc6fc">alloc_strategy_type</a> <a class="code" href="classvector.html#a091ea919a4b861bfc822757f6b223407">m_alloc_strategy</a>;
<a name="l00781"></a><a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">00781</a>     <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> <a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a>;
<a name="l00782"></a><a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">00782</a>     <a class="code" href="classvector_1_1bid__vector.html">bids_container_type</a> <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>;
<a name="l00783"></a><a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">00783</a>     <span class="keyword">mutable</span> <a class="code" href="classvector.html#a536cc2505df2fd69a3c035fbfe069df2">pager_type</a> <a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">m_pager</a>;
<a name="l00784"></a>00784 
<a name="l00785"></a>00785     <span class="comment">// enum specifying status of a page of the vector</span>
<a name="l00786"></a>00786     <span class="keyword">enum</span> {
<a name="l00787"></a><a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7ae7dfa2765991ce5aeb5428648c9bf816">00787</a>         <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7ae7dfa2765991ce5aeb5428648c9bf816">valid_on_disk</a> = 0, <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7a47756c13e50315322ce75879b7f92fa9">uninitialized</a> = 1, <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7ac8164fa4d1dbfc53d3afde2702df77ae">dirty</a> = 2
<a name="l00788"></a>00788     };<span class="comment"></span>
<a name="l00789"></a>00789 <span class="comment">    //! status of each page (valid_on_disk, uninitialized or dirty)</span>
<a name="l00790"></a><a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed">00790</a> <span class="comment"></span>    <span class="keyword">mutable</span> std::vector&lt;unsigned char&gt; <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>;
<a name="l00791"></a><a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">00791</a>     <span class="keyword">mutable</span> std::vector&lt;stxxl::int_type&gt; <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>;
<a name="l00792"></a><a class="code" href="classvector.html#a91e85df3c4867d28367bdaadc6dad0b9">00792</a>     <span class="keyword">mutable</span> stxxl::simple_vector&lt;stxxl::int_type&gt; <a class="code" href="classvector.html#a91e85df3c4867d28367bdaadc6dad0b9">m_slot_to_page</a>;
<a name="l00793"></a><a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">00793</a>     <span class="keyword">mutable</span> std::queue&lt;stxxl::int_type&gt; <a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>;
<a name="l00794"></a><a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">00794</a>     <span class="keyword">mutable</span> stxxl::simple_vector&lt;block_type&gt;* <a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a>;
<a name="l00795"></a><a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">00795</a>     stxxl::file* <a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">m_from</a>;
<a name="l00796"></a><a class="code" href="classvector.html#a5b450d62462ada69c9708680b4fa24ae">00796</a>     stxxl::block_manager* <a class="code" href="classvector.html#a5b450d62462ada69c9708680b4fa24ae">m_bm</a>;
<a name="l00797"></a><a class="code" href="classvector.html#a77523b724b9cf2f3707abfd3d74dd721">00797</a>     <span class="keywordtype">bool</span> <a class="code" href="classvector.html#a77523b724b9cf2f3707abfd3d74dd721">m_exported</a>;
<a name="l00798"></a><a class="code" href="classvector.html#a9c46a6e6001e5e41d4de7939f3a2b8bb">00798</a>     <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> <a class="code" href="classvector.html#a9c46a6e6001e5e41d4de7939f3a2b8bb">size_from_file_length</a>(stxxl::uint64 <a class="code" href="classvector.html#a43dcb975091d8c1bb4f1f08d05e0651e">file_length</a>)<span class="keyword"> const </span>{
<a name="l00799"></a>00799         stxxl::uint64 blocks_fit = file_length / stxxl::uint64(block_type::raw_size);
<a name="l00800"></a>00800         <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> cur_size = blocks_fit * stxxl::uint64(block_type::size);
<a name="l00801"></a>00801         stxxl::uint64 rest = file_length - blocks_fit * stxxl::uint64(block_type::raw_size);
<a name="l00802"></a>00802         <span class="keywordflow">return</span> (cur_size + rest / stxxl::uint64(<span class="keyword">sizeof</span> (<a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">value_type</a>)));
<a name="l00803"></a>00803     }
<a name="l00804"></a><a class="code" href="classvector.html#a43dcb975091d8c1bb4f1f08d05e0651e">00804</a>     stxxl::uint64 <a class="code" href="classvector.html#a43dcb975091d8c1bb4f1f08d05e0651e">file_length</a>()<span class="keyword"> const </span>{
<a name="l00805"></a>00805         <span class="keyword">typedef</span> stxxl::uint64 file_size_type;
<a name="l00806"></a>00806         <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> cur_size = <a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>();
<a name="l00807"></a>00807         <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> num_full_blocks = cur_size / <a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">block_type::size</a>;
<a name="l00808"></a>00808         <span class="keywordflow">if</span> (cur_size % block_type::size != 0) {
<a name="l00809"></a>00809             <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> rest = cur_size - num_full_blocks * <a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">block_type::size</a>;
<a name="l00810"></a>00810             <span class="keywordflow">return</span> file_size_type(num_full_blocks) * block_type::raw_size + rest * <span class="keyword">sizeof</span> (<a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">value_type</a>);
<a name="l00811"></a>00811         }
<a name="l00812"></a>00812         <span class="keywordflow">return</span> file_size_type(num_full_blocks) * block_type::raw_size;
<a name="l00813"></a>00813     }
<a name="l00814"></a>00814 
<a name="l00815"></a>00815 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l00816"></a>00816 <span class="comment">    //! \name Constructors/Destructors</span>
<a name="l00817"></a>00817 <span class="comment">    //! \{</span>
<a name="l00818"></a>00818 <span class="comment"></span><span class="comment"></span>
<a name="l00819"></a>00819 <span class="comment">    //! Constructs external vector with n elements.</span>
<a name="l00820"></a>00820 <span class="comment">    //!</span>
<a name="l00821"></a>00821 <span class="comment">    //! \param n Number of elements.</span>
<a name="l00822"></a>00822 <span class="comment">    //! \param npages Number of cached pages.</span>
<a name="l00823"></a><a class="code" href="classvector.html#a1f627c65adea6c62adf96e234be745b3">00823</a> <span class="comment"></span>    <a class="code" href="classvector.html#a1f627c65adea6c62adf96e234be745b3" title="Constructs external vector with n elements.">vector</a>(<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> n = 0, stxxl::unsigned_type npages = <a class="code" href="classvector.html#a536cc2505df2fd69a3c035fbfe069df2">pager_type</a>().<a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>())
<a name="l00824"></a>00824     : <a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a>(n),
<a name="l00825"></a>00825     <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>((size_t) stxxl::div_ceil(n, <a class="code" href="classvector.html#a202563e16860bc03b8fa49b7f9b1e244" title="type of the block used in disk-memory transfers">block_type</a>::<a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>)),
<a name="l00826"></a>00826     <a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">m_pager</a>(npages),
<a name="l00827"></a>00827     <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>(stxxl::div_ceil(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.<a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>(), <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>)),
<a name="l00828"></a>00828     <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>(stxxl::div_ceil(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.<a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>(), <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>)),
<a name="l00829"></a>00829     <a class="code" href="classvector.html#a91e85df3c4867d28367bdaadc6dad0b9">m_slot_to_page</a>(npages),
<a name="l00830"></a>00830     <a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a>(NULL),
<a name="l00831"></a>00831     <a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">m_from</a>(NULL),
<a name="l00832"></a>00832     <a class="code" href="classvector.html#a77523b724b9cf2f3707abfd3d74dd721">m_exported</a>(false) {
<a name="l00833"></a>00833         <span class="comment">//            DEBUG(&quot;Im Called... :D&quot;);</span>
<a name="l00834"></a>00834         <a class="code" href="classvector.html#a5b450d62462ada69c9708680b4fa24ae">m_bm</a> = stxxl::block_manager::get_instance();
<a name="l00835"></a>00835 
<a name="l00836"></a>00836         <a class="code" href="classvector.html#a18012e17cb6b5ab9bc54088be0511f6f" title="Allocate page cache, must be called to allow access to elements.">allocate_page_cache</a>();
<a name="l00837"></a>00837 
<a name="l00838"></a>00838         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>.size(); ++i) {
<a name="l00839"></a>00839             <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>[i] = <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7a47756c13e50315322ce75879b7f92fa9">uninitialized</a>;
<a name="l00840"></a>00840             <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[i] = <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a86d6dc0e6dae77e956822ccd989c8e75">on_disk</a>;
<a name="l00841"></a>00841         }
<a name="l00842"></a>00842 
<a name="l00843"></a>00843         <span class="keywordflow">for</span> (stxxl::unsigned_type i = 0; i &lt; <a class="code" href="classvector.html#a647786c3a0b78901bd5aa4b64d0bd851" title="Number of pages used by the pager.">numpages</a>(); ++i)
<a name="l00844"></a>00844             <a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.push(i);
<a name="l00845"></a>00845 
<a name="l00846"></a>00846         <a class="code" href="classvector.html#a5b450d62462ada69c9708680b4fa24ae">m_bm</a>-&gt;new_blocks(<a class="code" href="classvector.html#a091ea919a4b861bfc822757f6b223407">m_alloc_strategy</a>, <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.begin(), <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.end(), 0);
<a name="l00847"></a>00847     }
<a name="l00848"></a>00848 <span class="comment"></span>
<a name="l00849"></a>00849 <span class="comment">    //! \}</span>
<a name="l00850"></a>00850 <span class="comment"></span><span class="comment"></span>
<a name="l00851"></a>00851 <span class="comment">    //! \name Modifier</span>
<a name="l00852"></a>00852 <span class="comment">    //! \{</span>
<a name="l00853"></a>00853 <span class="comment"></span><span class="comment"></span>
<a name="l00854"></a>00854 <span class="comment">    //! swap content</span>
<a name="l00855"></a><a class="code" href="classvector.html#a17b575354c01530cfce68efe6a35cf1b">00855</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector.html#a17b575354c01530cfce68efe6a35cf1b" title="swap content">swap</a>(<a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector</a>&amp; obj) {
<a name="l00856"></a>00856         <a class="code" href="classvector.html#a17b575354c01530cfce68efe6a35cf1b" title="swap content">std::swap</a>(<a class="code" href="classvector.html#a091ea919a4b861bfc822757f6b223407">m_alloc_strategy</a>, obj.<a class="code" href="classvector.html#a091ea919a4b861bfc822757f6b223407">m_alloc_strategy</a>);
<a name="l00857"></a>00857         <a class="code" href="classvector.html#a17b575354c01530cfce68efe6a35cf1b" title="swap content">std::swap</a>(<a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a>, obj.<a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a>);
<a name="l00858"></a>00858         <a class="code" href="classvector.html#a17b575354c01530cfce68efe6a35cf1b" title="swap content">std::swap</a>(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>, obj.<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>);
<a name="l00859"></a>00859         <a class="code" href="classvector.html#a17b575354c01530cfce68efe6a35cf1b" title="swap content">std::swap</a>(<a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">m_pager</a>, obj.<a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">m_pager</a>);
<a name="l00860"></a>00860         <a class="code" href="classvector.html#a17b575354c01530cfce68efe6a35cf1b" title="swap content">std::swap</a>(<a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>, obj.<a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>);
<a name="l00861"></a>00861         <a class="code" href="classvector.html#a17b575354c01530cfce68efe6a35cf1b" title="swap content">std::swap</a>(<a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>, obj.<a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>);
<a name="l00862"></a>00862         <a class="code" href="classvector.html#a17b575354c01530cfce68efe6a35cf1b" title="swap content">std::swap</a>(<a class="code" href="classvector.html#a91e85df3c4867d28367bdaadc6dad0b9">m_slot_to_page</a>, obj.<a class="code" href="classvector.html#a91e85df3c4867d28367bdaadc6dad0b9">m_slot_to_page</a>);
<a name="l00863"></a>00863         <a class="code" href="classvector.html#a17b575354c01530cfce68efe6a35cf1b" title="swap content">std::swap</a>(<a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>, obj.<a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>);
<a name="l00864"></a>00864         <a class="code" href="classvector.html#a17b575354c01530cfce68efe6a35cf1b" title="swap content">std::swap</a>(<a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a>, obj.<a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a>);
<a name="l00865"></a>00865         <a class="code" href="classvector.html#a17b575354c01530cfce68efe6a35cf1b" title="swap content">std::swap</a>(<a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">m_from</a>, obj.<a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">m_from</a>);
<a name="l00866"></a>00866         <a class="code" href="classvector.html#a17b575354c01530cfce68efe6a35cf1b" title="swap content">std::swap</a>(<a class="code" href="classvector.html#a77523b724b9cf2f3707abfd3d74dd721">m_exported</a>, obj.<a class="code" href="classvector.html#a77523b724b9cf2f3707abfd3d74dd721">m_exported</a>);
<a name="l00867"></a>00867     }
<a name="l00868"></a>00868 <span class="comment"></span>
<a name="l00869"></a>00869 <span class="comment">    //! \}</span>
<a name="l00870"></a>00870 <span class="comment"></span><span class="comment"></span>
<a name="l00871"></a>00871 <span class="comment">    //! \name Miscellaneous</span>
<a name="l00872"></a>00872 <span class="comment">    //! \{</span>
<a name="l00873"></a>00873 <span class="comment"></span><span class="comment"></span>
<a name="l00874"></a>00874 <span class="comment">    //! Allocate page cache, must be called to allow access to elements.</span>
<a name="l00875"></a><a class="code" href="classvector.html#a18012e17cb6b5ab9bc54088be0511f6f">00875</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector.html#a18012e17cb6b5ab9bc54088be0511f6f" title="Allocate page cache, must be called to allow access to elements.">allocate_page_cache</a>()<span class="keyword"> const </span>{
<a name="l00876"></a>00876         <span class="comment">//  numpages() might be zero</span>
<a name="l00877"></a>00877         <span class="keywordflow">if</span> (!<a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a> &amp;&amp; <a class="code" href="classvector.html#a647786c3a0b78901bd5aa4b64d0bd851" title="Number of pages used by the pager.">numpages</a>() &gt; 0)
<a name="l00878"></a>00878             <a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a> = <span class="keyword">new</span> stxxl::simple_vector&lt;block_type&gt;(<a class="code" href="classvector.html#a647786c3a0b78901bd5aa4b64d0bd851" title="Number of pages used by the pager.">numpages</a>() * <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>);
<a name="l00879"></a>00879     }
<a name="l00880"></a>00880 <span class="comment"></span>
<a name="l00881"></a>00881 <span class="comment">    //! allows to free the cache, but you may not access any element until call</span>
<a name="l00882"></a>00882 <span class="comment">    //! allocate_page_cache() again</span>
<a name="l00883"></a><a class="code" href="classvector.html#ae9a81f76ddce7243abf7606e888a43d7">00883</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector.html#ae9a81f76ddce7243abf7606e888a43d7" title="allows to free the cache, but you may not access any element until call allocate_page_cache() again...">deallocate_page_cache</a>()<span class="keyword"> const </span>{
<a name="l00884"></a>00884         <a class="code" href="classvector.html#a08276777f1d54845546843d77f402904" title="Flushes the cache pages to the external memory.">flush</a>();
<a name="l00885"></a>00885         <span class="keyword">delete</span> <a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a>;
<a name="l00886"></a>00886         <a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a> = NULL;
<a name="l00887"></a>00887     }
<a name="l00888"></a>00888 <span class="comment"></span>
<a name="l00889"></a>00889 <span class="comment">    //! \name Size and Capacity</span>
<a name="l00890"></a>00890 <span class="comment">    //! \{</span>
<a name="l00891"></a>00891 <span class="comment"></span><span class="comment"></span>
<a name="l00892"></a>00892 <span class="comment">    //! return the size of the vector.</span>
<a name="l00893"></a><a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17">00893</a> <span class="comment"></span>    <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> <a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>()<span class="keyword"> const </span>{
<a name="l00894"></a>00894         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a>;
<a name="l00895"></a>00895     }<span class="comment"></span>
<a name="l00896"></a>00896 <span class="comment">    //! true if the vector&#39;s size is zero.</span>
<a name="l00897"></a><a class="code" href="classvector.html#aa690778074b5c3429ae5fa4948317d23">00897</a> <span class="comment"></span>    <span class="keywordtype">bool</span> <a class="code" href="classvector.html#aa690778074b5c3429ae5fa4948317d23" title="true if the vector&#39;s size is zero.">empty</a>()<span class="keyword"> const </span>{
<a name="l00898"></a>00898         <span class="keywordflow">return</span> (!<a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a>);
<a name="l00899"></a>00899     }
<a name="l00900"></a>00900 <span class="comment"></span>
<a name="l00901"></a>00901 <span class="comment">    //! Return the number of elelemtsn for which \a external memory has been</span>
<a name="l00902"></a>00902 <span class="comment">    //! allocated. capacity() is always greator than or equal to size().</span>
<a name="l00903"></a><a class="code" href="classvector.html#ad5ac97fe424e748e592023e57627afe9">00903</a> <span class="comment"></span>    <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> <a class="code" href="classvector.html#ad5ac97fe424e748e592023e57627afe9" title="Return the number of elelemtsn for which external memory has been allocated. capacity() is always gre...">capacity</a>()<span class="keyword"> const </span>{
<a name="l00904"></a>00904         <span class="keywordflow">return</span> <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.size()) * block_type::size;
<a name="l00905"></a>00905     }<span class="comment"></span>
<a name="l00906"></a>00906 <span class="comment">    //! Returns the number of bytes that the vector has allocated on disks.</span>
<a name="l00907"></a><a class="code" href="classvector.html#a7adb0f62c5a9a3c43861403573541300">00907</a> <span class="comment"></span>    <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> <a class="code" href="classvector.html#a7adb0f62c5a9a3c43861403573541300" title="Returns the number of bytes that the vector has allocated on disks.">raw_capacity</a>()<span class="keyword"> const </span>{
<a name="l00908"></a>00908         <span class="keywordflow">return</span> <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.size()) * block_type::raw_size;
<a name="l00909"></a>00909     }<span class="comment"></span>
<a name="l00910"></a>00910 <span class="comment">    /*! \brief Reserves at least n elements in external memory.</span>
<a name="l00911"></a>00911 <span class="comment">     *</span>
<a name="l00912"></a>00912 <span class="comment">     * If n is less than or equal to capacity(), this call has no</span>
<a name="l00913"></a>00913 <span class="comment">     * effect. Otherwise, it is a request for allocation of additional \b</span>
<a name="l00914"></a>00914 <span class="comment">     * external memory. If the request is successful, then capacity() is</span>
<a name="l00915"></a>00915 <span class="comment">     * greater than or equal to n; otherwise capacity() is unchanged. In either</span>
<a name="l00916"></a>00916 <span class="comment">     * case, size() is unchanged.</span>
<a name="l00917"></a>00917 <span class="comment">     */</span>
<a name="l00918"></a><a class="code" href="classvector.html#aa903f8415685176a0026ed5808c38123">00918</a>     <span class="keywordtype">void</span> <a class="code" href="classvector.html#aa903f8415685176a0026ed5808c38123" title="Reserves at least n elements in external memory.">reserve</a>(<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> n) {
<a name="l00919"></a>00919         <span class="keywordflow">if</span> (n &lt;= <a class="code" href="classvector.html#ad5ac97fe424e748e592023e57627afe9" title="Return the number of elelemtsn for which external memory has been allocated. capacity() is always gre...">capacity</a>())
<a name="l00920"></a>00920             <span class="keywordflow">return</span>;
<a name="l00921"></a>00921 
<a name="l00922"></a>00922         stxxl::unsigned_type old_bids_size = <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.size();
<a name="l00923"></a>00923         stxxl::unsigned_type new_bids_size = (stxxl::unsigned_type)div_ceil(n, block_type::size);
<a name="l00924"></a>00924         stxxl::unsigned_type new_pages = stxxl::div_ceil(new_bids_size, <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>);
<a name="l00925"></a>00925         <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>.resize(new_pages, <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7a47756c13e50315322ce75879b7f92fa9">uninitialized</a>);
<a name="l00926"></a>00926         <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>.resize(new_pages, <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a86d6dc0e6dae77e956822ccd989c8e75">on_disk</a>);
<a name="l00927"></a>00927 
<a name="l00928"></a>00928         <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.resize(new_bids_size);
<a name="l00929"></a>00929         <span class="keywordflow">if</span> (<a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">m_from</a> == NULL) {
<a name="l00930"></a>00930             <a class="code" href="classvector.html#a5b450d62462ada69c9708680b4fa24ae">m_bm</a>-&gt;new_blocks(<a class="code" href="classvector.html#a091ea919a4b861bfc822757f6b223407">m_alloc_strategy</a>,
<a name="l00931"></a>00931                     <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.begin() + old_bids_size, <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.end(),
<a name="l00932"></a>00932                     old_bids_size);
<a name="l00933"></a>00933         } <span class="keywordflow">else</span> {
<a name="l00934"></a>00934             <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> offset = <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>(old_bids_size) * <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>(block_type::raw_size);
<a name="l00935"></a>00935             <span class="keywordflow">for</span> (<a class="code" href="classvector.html#a81fede0a4a86f8e21370dee34ddebdf0">bids_container_iterator</a> it = <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.begin() + old_bids_size;
<a name="l00936"></a>00936                     it != <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.end(); ++it, offset += <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>(block_type::raw_size)) {
<a name="l00937"></a>00937                 (*it).storage = <a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">m_from</a>;
<a name="l00938"></a>00938                 (*it).offset = offset;
<a name="l00939"></a>00939             }
<a name="l00940"></a>00940             <a class="code" href="ExtStxxlVector_8h.html#adce24d9daba86c6533c3ade041e3da39">STXXL_VERBOSE_VECTOR</a>(<span class="stringliteral">&quot;reserve(): Changing size of file &quot;</span> &lt;&lt;
<a name="l00941"></a>00941                     ((<span class="keywordtype">void</span>*) <a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">m_from</a>) &lt;&lt; <span class="stringliteral">&quot; to &quot;</span> &lt;&lt; offset);
<a name="l00942"></a>00942             m_from-&gt;set_size(offset);
<a name="l00943"></a>00943         }
<a name="l00944"></a>00944     }
<a name="l00945"></a>00945 <span class="comment"></span>
<a name="l00946"></a>00946 <span class="comment">    //! Resize vector contents to n items.</span>
<a name="l00947"></a>00947 <span class="comment">    //! \warning this will not call the constructor of objects in external memory!</span>
<a name="l00948"></a><a class="code" href="classvector.html#afca54b197dbf17561dd8c6c715b21f51">00948</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector.html#afca54b197dbf17561dd8c6c715b21f51" title="Resize vector contents to n items.">resize</a>(<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> n) {
<a name="l00949"></a>00949         <a class="code" href="classvector.html#a1bcc7a57dbf7074a2613bcf43a62a7d7" title="Resize vector, only allow capacity growth.">_resize</a>(n);
<a name="l00950"></a>00950     }
<a name="l00951"></a>00951 <span class="comment"></span>
<a name="l00952"></a>00952 <span class="comment">    //! Resize vector contents to n items, and allow the allocated external</span>
<a name="l00953"></a>00953 <span class="comment">    //! memory to shrink. Internal memory allocation remains unchanged.</span>
<a name="l00954"></a>00954 <span class="comment">    //! \warning this will not call the constructor of objects in external memory!</span>
<a name="l00955"></a><a class="code" href="classvector.html#a30d90837c5001179387148129bf9df57">00955</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector.html#a30d90837c5001179387148129bf9df57" title="Resize vector contents to n items, and allow the allocated external memory to shrink. Internal memory allocation remains unchanged.">resize</a>(<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> n, <span class="keywordtype">bool</span> shrink_capacity) {
<a name="l00956"></a>00956         <span class="keywordflow">if</span> (shrink_capacity)
<a name="l00957"></a>00957             <a class="code" href="classvector.html#ac326e6a59f50edaa8219ffefa03461b8" title="Resize vector, also allow reduction of external memory capacity.">_resize_shrink_capacity</a>(n);
<a name="l00958"></a>00958         <span class="keywordflow">else</span>
<a name="l00959"></a>00959             <a class="code" href="classvector.html#a1bcc7a57dbf7074a2613bcf43a62a7d7" title="Resize vector, only allow capacity growth.">_resize</a>(n);
<a name="l00960"></a>00960     }
<a name="l00961"></a>00961 <span class="comment"></span>
<a name="l00962"></a>00962 <span class="comment">    //! \}</span>
<a name="l00963"></a>00963 <span class="comment"></span>
<a name="l00964"></a>00964 <span class="keyword">private</span>:<span class="comment"></span>
<a name="l00965"></a>00965 <span class="comment">    //! Resize vector, only allow capacity growth.</span>
<a name="l00966"></a><a class="code" href="classvector.html#a1bcc7a57dbf7074a2613bcf43a62a7d7">00966</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector.html#a1bcc7a57dbf7074a2613bcf43a62a7d7" title="Resize vector, only allow capacity growth.">_resize</a>(<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> n) {
<a name="l00967"></a>00967         <a class="code" href="classvector.html#aa903f8415685176a0026ed5808c38123" title="Reserves at least n elements in external memory.">reserve</a>(n);
<a name="l00968"></a>00968         <span class="keywordflow">if</span> (n &lt; <a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a>) {
<a name="l00969"></a>00969             <span class="comment">// mark excess pages as uninitialized and evict them from cache</span>
<a name="l00970"></a>00970             stxxl::unsigned_type first_page_to_evict = (stxxl::unsigned_type)stxxl::div_ceil(n, block_type::size * <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>);
<a name="l00971"></a>00971             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = first_page_to_evict; i &lt; <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>.size(); ++i) {
<a name="l00972"></a>00972                 <span class="keywordflow">if</span> (<a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[i] != <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a86d6dc0e6dae77e956822ccd989c8e75">on_disk</a>) {
<a name="l00973"></a>00973                     <a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.push(<a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[i]);
<a name="l00974"></a>00974                     <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[i] = <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a86d6dc0e6dae77e956822ccd989c8e75">on_disk</a>;
<a name="l00975"></a>00975                 }
<a name="l00976"></a>00976                 <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>[i] = <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7a47756c13e50315322ce75879b7f92fa9">uninitialized</a>;
<a name="l00977"></a>00977             }
<a name="l00978"></a>00978         }
<a name="l00979"></a>00979         <a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a> = n;
<a name="l00980"></a>00980     }
<a name="l00981"></a>00981 <span class="comment"></span>
<a name="l00982"></a>00982 <span class="comment">    //! Resize vector, also allow reduction of external memory capacity.</span>
<a name="l00983"></a><a class="code" href="classvector.html#ac326e6a59f50edaa8219ffefa03461b8">00983</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector.html#ac326e6a59f50edaa8219ffefa03461b8" title="Resize vector, also allow reduction of external memory capacity.">_resize_shrink_capacity</a>(<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> n) {
<a name="l00984"></a>00984         stxxl::unsigned_type old_bids_size = <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.size();
<a name="l00985"></a>00985         stxxl::unsigned_type new_bids_size = div_ceil(n, block_type::size);
<a name="l00986"></a>00986 
<a name="l00987"></a>00987         <span class="keywordflow">if</span> (new_bids_size &gt; old_bids_size) {
<a name="l00988"></a>00988             <a class="code" href="classvector.html#aa903f8415685176a0026ed5808c38123" title="Reserves at least n elements in external memory.">reserve</a>(n);
<a name="l00989"></a>00989         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (new_bids_size &lt; old_bids_size) {
<a name="l00990"></a>00990             stxxl::unsigned_type new_pages_size = stxxl::div_ceil(new_bids_size, <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>);
<a name="l00991"></a>00991 
<a name="l00992"></a>00992             <a class="code" href="ExtStxxlVector_8h.html#adce24d9daba86c6533c3ade041e3da39">STXXL_VERBOSE_VECTOR</a>(<span class="stringliteral">&quot;shrinking from &quot;</span> &lt;&lt; old_bids_size &lt;&lt; <span class="stringliteral">&quot; to &quot;</span> &lt;&lt;
<a name="l00993"></a>00993                     new_bids_size &lt;&lt; <span class="stringliteral">&quot; blocks = from &quot;</span> &lt;&lt;
<a name="l00994"></a>00994                     <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>.size() &lt;&lt; <span class="stringliteral">&quot; to &quot;</span> &lt;&lt;
<a name="l00995"></a>00995                     new_pages_size &lt;&lt; <span class="stringliteral">&quot; pages&quot;</span>);
<a name="l00996"></a>00996 
<a name="l00997"></a>00997             <span class="comment">// release blocks</span>
<a name="l00998"></a>00998             <span class="keywordflow">if</span> (<a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">m_from</a> != NULL)
<a name="l00999"></a>00999                 <a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">m_from</a>-&gt;set_size(new_bids_size * block_type::raw_size);
<a name="l01000"></a>01000             <span class="keywordflow">else</span>
<a name="l01001"></a>01001                 <a class="code" href="classvector.html#a5b450d62462ada69c9708680b4fa24ae">m_bm</a>-&gt;delete_blocks(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.begin() + old_bids_size, <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.end());
<a name="l01002"></a>01002 
<a name="l01003"></a>01003             <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.resize(new_bids_size);
<a name="l01004"></a>01004 
<a name="l01005"></a>01005             <span class="comment">// don&#39;t resize m_page_to_slot or m_page_status, because it is</span>
<a name="l01006"></a>01006             <span class="comment">// still needed to check page status and match the mapping</span>
<a name="l01007"></a>01007             <span class="comment">// m_slot_to_page</span>
<a name="l01008"></a>01008 
<a name="l01009"></a>01009             <span class="comment">// clear dirty flag, so these pages will be never written</span>
<a name="l01010"></a>01010             std::fill(<a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>.begin() + new_pages_size,
<a name="l01011"></a>01011                     <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>.end(), (<span class="keywordtype">unsigned</span> char) <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7ae7dfa2765991ce5aeb5428648c9bf816">valid_on_disk</a>);
<a name="l01012"></a>01012         }
<a name="l01013"></a>01013 
<a name="l01014"></a>01014         <a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a> = n;
<a name="l01015"></a>01015     }
<a name="l01016"></a>01016 
<a name="l01017"></a>01017 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l01018"></a>01018 <span class="comment">    //! \name Modifiers</span>
<a name="l01019"></a>01019 <span class="comment">    //! \{</span>
<a name="l01020"></a>01020 <span class="comment"></span><span class="comment"></span>
<a name="l01021"></a>01021 <span class="comment">    //! Erases all of the elements and deallocates all external memory that is</span>
<a name="l01022"></a>01022 <span class="comment">    //! occupied.</span>
<a name="l01023"></a><a class="code" href="classvector.html#ac2c75402358c393e7cb7a4485f9bc81e">01023</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector.html#ac2c75402358c393e7cb7a4485f9bc81e" title="Erases all of the elements and deallocates all external memory that is occupied.">clear</a>() {
<a name="l01024"></a>01024         <a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a> = 0;
<a name="l01025"></a>01025         <span class="keywordflow">if</span> (<a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">m_from</a> == NULL)
<a name="l01026"></a>01026             <a class="code" href="classvector.html#a5b450d62462ada69c9708680b4fa24ae">m_bm</a>-&gt;delete_blocks(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.begin(), <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.end());
<a name="l01027"></a>01027 
<a name="l01028"></a>01028         <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.clear();
<a name="l01029"></a>01029         <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>.clear();
<a name="l01030"></a>01030         <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>.clear();
<a name="l01031"></a>01031         <span class="keywordflow">while</span> (!<a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.empty())
<a name="l01032"></a>01032             <a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.pop();
<a name="l01033"></a>01033 
<a name="l01034"></a>01034         <span class="keywordflow">for</span> (stxxl::unsigned_type i = 0; i &lt; <a class="code" href="classvector.html#a647786c3a0b78901bd5aa4b64d0bd851" title="Number of pages used by the pager.">numpages</a>(); ++i)
<a name="l01035"></a>01035             <a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.push(i);
<a name="l01036"></a>01036     }
<a name="l01037"></a>01037 <span class="comment"></span>
<a name="l01038"></a>01038 <span class="comment">    //! \name Front and Back Access</span>
<a name="l01039"></a>01039 <span class="comment">    //! \{</span>
<a name="l01040"></a>01040 <span class="comment"></span><span class="comment"></span>
<a name="l01041"></a>01041 <span class="comment">    //! Append a new element at the end.</span>
<a name="l01042"></a><a class="code" href="classvector.html#a8b1329950ac9770608f47fe29ad384ff">01042</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector.html#a8b1329950ac9770608f47fe29ad384ff" title="Append a new element at the end.">push_back</a>(<a class="code" href="classvector.html#ab1387877afd358151c6b6b8867d40fa6" title="constant reference to value_type">const_reference</a> obj) {
<a name="l01043"></a>01043         <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> old_size = <a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a>;
<a name="l01044"></a>01044         <a class="code" href="classvector.html#afca54b197dbf17561dd8c6c715b21f51" title="Resize vector contents to n items.">resize</a>(old_size + 1);
<a name="l01045"></a>01045         <a class="code" href="classvector.html#a675d7bf74bd470ba56b7105531825255">element</a>(old_size) = obj;
<a name="l01046"></a>01046     }<span class="comment"></span>
<a name="l01047"></a>01047 <span class="comment">    //! Removes the last element (without returning it, see back()).</span>
<a name="l01048"></a><a class="code" href="classvector.html#a6670794a20dd6d865b37118087077cd8">01048</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector.html#a6670794a20dd6d865b37118087077cd8" title="Removes the last element (without returning it, see back()).">pop_back</a>() {
<a name="l01049"></a>01049         <a class="code" href="classvector.html#afca54b197dbf17561dd8c6c715b21f51" title="Resize vector contents to n items.">resize</a>(<a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a> - 1);
<a name="l01050"></a>01050     }
<a name="l01051"></a>01051 <span class="comment"></span>
<a name="l01052"></a>01052 <span class="comment">    //! \}</span>
<a name="l01053"></a>01053 <span class="comment"></span><span class="comment"></span>
<a name="l01054"></a>01054 <span class="comment">    //! \name Operators</span>
<a name="l01055"></a>01055 <span class="comment">    //! \{</span>
<a name="l01056"></a>01056 <span class="comment"></span><span class="comment"></span>
<a name="l01057"></a>01057 <span class="comment">    //! Returns a reference to the last element, see \ref design_vector_notes.</span>
<a name="l01058"></a><a class="code" href="classvector.html#a34871ce8e44e900f538ab508618a6b4c">01058</a> <span class="comment"></span>    <a class="code" href="classvector.html#a7d234f8da8ce66aacfe18001d887e4cf" title="reference to value_type">reference</a> <a class="code" href="classvector.html#a34871ce8e44e900f538ab508618a6b4c" title="Returns a reference to the last element, see More Notes.">back</a>() {
<a name="l01059"></a>01059         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a675d7bf74bd470ba56b7105531825255">element</a>(<a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a> - 1);
<a name="l01060"></a>01060     }<span class="comment"></span>
<a name="l01061"></a>01061 <span class="comment">    //! Returns a reference to the first element, see \ref design_vector_notes.</span>
<a name="l01062"></a><a class="code" href="classvector.html#a9b5c3ec56e67002573f0eae4c5f9b967">01062</a> <span class="comment"></span>    <a class="code" href="classvector.html#a7d234f8da8ce66aacfe18001d887e4cf" title="reference to value_type">reference</a> <a class="code" href="classvector.html#a9b5c3ec56e67002573f0eae4c5f9b967" title="Returns a reference to the first element, see More Notes.">front</a>() {
<a name="l01063"></a>01063         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a675d7bf74bd470ba56b7105531825255">element</a>(0);
<a name="l01064"></a>01064     }<span class="comment"></span>
<a name="l01065"></a>01065 <span class="comment">    //! Returns a constant reference to the last element, see \ref design_vector_notes.</span>
<a name="l01066"></a><a class="code" href="classvector.html#afadbd9268b9916a313417e233e73389c">01066</a> <span class="comment"></span>    <a class="code" href="classvector.html#ab1387877afd358151c6b6b8867d40fa6" title="constant reference to value_type">const_reference</a> <a class="code" href="classvector.html#afadbd9268b9916a313417e233e73389c" title="Returns a constant reference to the last element, see More Notes.">back</a>()<span class="keyword"> const </span>{
<a name="l01067"></a>01067         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a606834d73c078850aba1ce9f750a3ac7">const_element</a>(<a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a> - 1);
<a name="l01068"></a>01068     }<span class="comment"></span>
<a name="l01069"></a>01069 <span class="comment">    //! Returns a constant reference to the first element, see \ref design_vector_notes.</span>
<a name="l01070"></a><a class="code" href="classvector.html#abb9d5891147a13ff0d0f5ae20d71a551">01070</a> <span class="comment"></span>    <a class="code" href="classvector.html#ab1387877afd358151c6b6b8867d40fa6" title="constant reference to value_type">const_reference</a> <a class="code" href="classvector.html#abb9d5891147a13ff0d0f5ae20d71a551" title="Returns a constant reference to the first element, see More Notes.">front</a>()<span class="keyword"> const </span>{
<a name="l01071"></a>01071         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a606834d73c078850aba1ce9f750a3ac7">const_element</a>(0);
<a name="l01072"></a>01072     }
<a name="l01073"></a>01073 <span class="comment"></span>
<a name="l01074"></a>01074 <span class="comment">    //! \}</span>
<a name="l01075"></a>01075 <span class="comment"></span><span class="comment"></span>
<a name="l01076"></a>01076 <span class="comment">    //! \name Constructors/Destructors</span>
<a name="l01077"></a>01077 <span class="comment">    //! \{</span>
<a name="l01078"></a>01078 <span class="comment"></span><span class="comment"></span>
<a name="l01079"></a>01079 <span class="comment">    //! Construct vector from a file.</span>
<a name="l01080"></a>01080 <span class="comment">    //! \param from file to be constructed from</span>
<a name="l01081"></a>01081 <span class="comment">    //! \param size Number of elements.</span>
<a name="l01082"></a>01082 <span class="comment">    //! \param npages Number of cached pages.</span>
<a name="l01083"></a>01083 <span class="comment">    //! \warning Only one \c vector can be assigned to a particular (physical) file.</span>
<a name="l01084"></a>01084 <span class="comment">    //! The block size of the vector must be a multiple of the element size</span>
<a name="l01085"></a>01085 <span class="comment">    //! \c sizeof(ValueType) and the page size (4096).</span>
<a name="l01086"></a><a class="code" href="classvector.html#a5d6dd48c32c828831bb0753e9096c781">01086</a> <span class="comment"></span>    <a class="code" href="classvector.html#a1f627c65adea6c62adf96e234be745b3" title="Constructs external vector with n elements.">vector</a>(stxxl::file* from, <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> <a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a> = <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>(-1), stxxl::unsigned_type npages = <a class="code" href="classvector.html#a536cc2505df2fd69a3c035fbfe069df2">pager_type</a>().<a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>())
<a name="l01087"></a>01087     : <a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a>((<a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a> == <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>(-1)) ? <a class="code" href="classvector.html#a9c46a6e6001e5e41d4de7939f3a2b8bb">size_from_file_length</a>(from-&gt;<a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>()) : <a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>),
<a name="l01088"></a>01088     <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>((size_t) div_ceil(<a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a>, <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>(<a class="code" href="classvector.html#a202563e16860bc03b8fa49b7f9b1e244" title="type of the block used in disk-memory transfers">block_type</a>::<a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>))),
<a name="l01089"></a>01089     <a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">m_pager</a>(npages),
<a name="l01090"></a>01090     <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>(div_ceil(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.<a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>(), <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>)),
<a name="l01091"></a>01091     <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>(div_ceil(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.<a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>(), <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>)),
<a name="l01092"></a>01092     <a class="code" href="classvector.html#a91e85df3c4867d28367bdaadc6dad0b9">m_slot_to_page</a>(npages),
<a name="l01093"></a>01093     <a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a>(NULL),
<a name="l01094"></a>01094     <a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">m_from</a>(from),
<a name="l01095"></a>01095     <a class="code" href="classvector.html#a77523b724b9cf2f3707abfd3d74dd721">m_exported</a>(false) {
<a name="l01096"></a>01096         <span class="comment">// initialize from file</span>
<a name="l01097"></a>01097         <span class="keywordflow">if</span> (!block_type::has_only_data) {
<a name="l01098"></a>01098             std::ostringstream str;
<a name="l01099"></a>01099             str &lt;&lt; <span class="stringliteral">&quot;The block size for a vector that is mapped to a file must be a multiple of the element size (&quot;</span> &lt;&lt;
<a name="l01100"></a>01100                     <span class="keyword">sizeof</span> (<a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">value_type</a>) &lt;&lt; <span class="stringliteral">&quot;) and the page size (4096).&quot;</span>;
<a name="l01101"></a>01101             <span class="keywordflow">throw</span> std::runtime_error(str.str());
<a name="l01102"></a>01102         }
<a name="l01103"></a>01103 
<a name="l01104"></a>01104         <a class="code" href="classvector.html#a5b450d62462ada69c9708680b4fa24ae">m_bm</a> = stxxl::block_manager::get_instance();
<a name="l01105"></a>01105 
<a name="l01106"></a>01106         <a class="code" href="classvector.html#a18012e17cb6b5ab9bc54088be0511f6f" title="Allocate page cache, must be called to allow access to elements.">allocate_page_cache</a>();
<a name="l01107"></a>01107 
<a name="l01108"></a>01108         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>.size(); ++i) {
<a name="l01109"></a>01109             <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>[i] = <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7ae7dfa2765991ce5aeb5428648c9bf816">valid_on_disk</a>;
<a name="l01110"></a>01110             <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[i] = <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a86d6dc0e6dae77e956822ccd989c8e75">on_disk</a>;
<a name="l01111"></a>01111         }
<a name="l01112"></a>01112 
<a name="l01113"></a>01113         <span class="keywordflow">for</span> (stxxl::unsigned_type i = 0; i &lt; <a class="code" href="classvector.html#a647786c3a0b78901bd5aa4b64d0bd851" title="Number of pages used by the pager.">numpages</a>(); ++i)
<a name="l01114"></a>01114             <a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.push(i);
<a name="l01115"></a>01115 
<a name="l01116"></a>01116 
<a name="l01117"></a>01117         <span class="comment">// allocate blocks equidistantly and in-order</span>
<a name="l01118"></a>01118         <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> offset = 0;
<a name="l01119"></a>01119         <span class="keywordflow">for</span> (<a class="code" href="classvector.html#a81fede0a4a86f8e21370dee34ddebdf0">bids_container_iterator</a> it = <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.begin();
<a name="l01120"></a>01120                 it != <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.end(); ++it, offset += <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>(block_type::raw_size)) {
<a name="l01121"></a>01121             (*it).storage = from;
<a name="l01122"></a>01122             (*it).offset = offset;
<a name="l01123"></a>01123         }
<a name="l01124"></a>01124         from-&gt;set_size(offset);
<a name="l01125"></a>01125     }
<a name="l01126"></a>01126 <span class="comment"></span>
<a name="l01127"></a>01127 <span class="comment">    //! copy-constructor</span>
<a name="l01128"></a><a class="code" href="classvector.html#a638a9b12c11d32e7352399039c461158">01128</a> <span class="comment"></span>    <a class="code" href="classvector.html#a1f627c65adea6c62adf96e234be745b3" title="Constructs external vector with n elements.">vector</a>(<span class="keyword">const</span> <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector</a>&amp; obj)
<a name="l01129"></a>01129     : <a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a>(obj.<a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>()),
<a name="l01130"></a>01130     <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>((size_t) div_ceil(obj.<a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>(), <a class="code" href="classvector.html#a202563e16860bc03b8fa49b7f9b1e244" title="type of the block used in disk-memory transfers">block_type</a>::<a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>)),
<a name="l01131"></a>01131     <a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">m_pager</a>(obj.<a class="code" href="classvector.html#a647786c3a0b78901bd5aa4b64d0bd851" title="Number of pages used by the pager.">numpages</a>()),
<a name="l01132"></a>01132     <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>(stxxl::div_ceil(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.<a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>(), <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>)),
<a name="l01133"></a>01133     <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>(stxxl::div_ceil(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.<a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>(), <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>)),
<a name="l01134"></a>01134     <a class="code" href="classvector.html#a91e85df3c4867d28367bdaadc6dad0b9">m_slot_to_page</a>(obj.<a class="code" href="classvector.html#a647786c3a0b78901bd5aa4b64d0bd851" title="Number of pages used by the pager.">numpages</a>()),
<a name="l01135"></a>01135     <a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a>(NULL),
<a name="l01136"></a>01136     <a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">m_from</a>(NULL),
<a name="l01137"></a>01137     <a class="code" href="classvector.html#a77523b724b9cf2f3707abfd3d74dd721">m_exported</a>(false) {
<a name="l01138"></a>01138         assert(!obj.<a class="code" href="classvector.html#a77523b724b9cf2f3707abfd3d74dd721">m_exported</a>);
<a name="l01139"></a>01139         <a class="code" href="classvector.html#a5b450d62462ada69c9708680b4fa24ae">m_bm</a> = stxxl::block_manager::get_instance();
<a name="l01140"></a>01140 
<a name="l01141"></a>01141         <a class="code" href="classvector.html#a18012e17cb6b5ab9bc54088be0511f6f" title="Allocate page cache, must be called to allow access to elements.">allocate_page_cache</a>();
<a name="l01142"></a>01142 
<a name="l01143"></a>01143         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>.size(); ++i) {
<a name="l01144"></a>01144             <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>[i] = <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7a47756c13e50315322ce75879b7f92fa9">uninitialized</a>;
<a name="l01145"></a>01145             <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[i] = <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a86d6dc0e6dae77e956822ccd989c8e75">on_disk</a>;
<a name="l01146"></a>01146         }
<a name="l01147"></a>01147 
<a name="l01148"></a>01148         <span class="keywordflow">for</span> (stxxl::unsigned_type i = 0; i &lt; <a class="code" href="classvector.html#a647786c3a0b78901bd5aa4b64d0bd851" title="Number of pages used by the pager.">numpages</a>(); ++i)
<a name="l01149"></a>01149             <a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.push(i);
<a name="l01150"></a>01150 
<a name="l01151"></a>01151         <a class="code" href="classvector.html#a5b450d62462ada69c9708680b4fa24ae">m_bm</a>-&gt;new_blocks(<a class="code" href="classvector.html#a091ea919a4b861bfc822757f6b223407">m_alloc_strategy</a>, <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.begin(), <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.end(), 0);
<a name="l01152"></a>01152 
<a name="l01153"></a>01153         <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_iterator</a> inbegin = obj.<a class="code" href="classvector.html#a1816375aa4c8841be2dee870a9c69854" title="returns an iterator pointing to the beginning of the vector, see More Notes.">begin</a>();
<a name="l01154"></a>01154         <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_iterator</a> inend = obj.<a class="code" href="classvector.html#ad24f3779644689f762786930e1b1a0bb" title="returns an iterator pointing beyond the end of the vector, see More Notes.">end</a>();
<a name="l01155"></a>01155         std::copy(inbegin, inend, <a class="code" href="classvector.html#a1816375aa4c8841be2dee870a9c69854" title="returns an iterator pointing to the beginning of the vector, see More Notes.">begin</a>());
<a name="l01156"></a>01156     }
<a name="l01157"></a>01157 <span class="comment"></span>
<a name="l01158"></a>01158 <span class="comment">    //! \}</span>
<a name="l01159"></a>01159 <span class="comment"></span><span class="comment"></span>
<a name="l01160"></a>01160 <span class="comment">    //! \name Operators</span>
<a name="l01161"></a>01161 <span class="comment">    //! \{</span>
<a name="l01162"></a>01162 <span class="comment"></span><span class="comment"></span>
<a name="l01163"></a>01163 <span class="comment">    //! assignment operator</span>
<a name="l01164"></a><a class="code" href="classvector.html#aaab503e8fc863e7a9144302dfa74650e">01164</a> <span class="comment"></span>    <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector</a>&amp; <a class="code" href="classvector.html#aaab503e8fc863e7a9144302dfa74650e" title="assignment operator">operator =</a>(<span class="keyword">const</span> <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector</a>&amp; obj) {
<a name="l01165"></a>01165         <span class="keywordflow">if</span> (&amp;obj != <span class="keyword">this</span>) {
<a name="l01166"></a>01166             <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector</a> tmp(obj);
<a name="l01167"></a>01167             this-&gt;<a class="code" href="classvector.html#a17b575354c01530cfce68efe6a35cf1b" title="swap content">swap</a>(tmp);
<a name="l01168"></a>01168         }
<a name="l01169"></a>01169         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01170"></a>01170     }
<a name="l01171"></a>01171 <span class="comment"></span>
<a name="l01172"></a>01172 <span class="comment">    //! \}</span>
<a name="l01173"></a>01173 <span class="comment"></span><span class="comment"></span>
<a name="l01174"></a>01174 <span class="comment">    //! \name Iterator Construction</span>
<a name="l01175"></a>01175 <span class="comment">    //! \{</span>
<a name="l01176"></a>01176 <span class="comment"></span><span class="comment"></span>
<a name="l01177"></a>01177 <span class="comment">    //! returns an iterator pointing to the beginning of the vector, see \ref design_vector_notes.</span>
<a name="l01178"></a><a class="code" href="classvector.html#a1816375aa4c8841be2dee870a9c69854">01178</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">iterator</a> <a class="code" href="classvector.html#a1816375aa4c8841be2dee870a9c69854" title="returns an iterator pointing to the beginning of the vector, see More Notes.">begin</a>() {
<a name="l01179"></a>01179         <span class="keywordflow">return</span> <a class="code" href="classvector.html#ad44a127aabeaa7a573f0c193b9f1b093" title="iterator used to iterate through a vector, see More Notes.">iterator</a>(<span class="keyword">this</span>, 0);
<a name="l01180"></a>01180     }<span class="comment"></span>
<a name="l01181"></a>01181 <span class="comment">    //! returns a const_iterator pointing to the beginning of the vector, see \ref design_vector_notes.</span>
<a name="l01182"></a><a class="code" href="classvector.html#a459d0a0aeeeccab5f826586fd95ae5db">01182</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_iterator</a> <a class="code" href="classvector.html#a459d0a0aeeeccab5f826586fd95ae5db" title="returns a const_iterator pointing to the beginning of the vector, see More Notes.">begin</a>()<span class="keyword"> const </span>{
<a name="l01183"></a>01183         <span class="keywordflow">return</span> <a class="code" href="classvector.html#aa4028dfad10b3ba6322ed5ad588f2713" title="constant iterator used to iterate through a vector, see More Notes.">const_iterator</a>(<span class="keyword">this</span>, 0);
<a name="l01184"></a>01184     }<span class="comment"></span>
<a name="l01185"></a>01185 <span class="comment">    //! returns a const_iterator pointing to the beginning of the vector, see \ref design_vector_notes.</span>
<a name="l01186"></a><a class="code" href="classvector.html#a133cc5992610eb78756c9d65eecd92f2">01186</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_iterator</a> <a class="code" href="classvector.html#a133cc5992610eb78756c9d65eecd92f2" title="returns a const_iterator pointing to the beginning of the vector, see More Notes.">cbegin</a>()<span class="keyword"> const </span>{
<a name="l01187"></a>01187         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a1816375aa4c8841be2dee870a9c69854" title="returns an iterator pointing to the beginning of the vector, see More Notes.">begin</a>();
<a name="l01188"></a>01188     }<span class="comment"></span>
<a name="l01189"></a>01189 <span class="comment">    //! returns an iterator pointing beyond the end of the vector, see \ref design_vector_notes.</span>
<a name="l01190"></a><a class="code" href="classvector.html#ad24f3779644689f762786930e1b1a0bb">01190</a> <span class="comment"></span>    <a class="code" href="classvector__iterator.html" title="External vector iterator, model of ext_random_access_iterator concept.">iterator</a> <a class="code" href="classvector.html#ad24f3779644689f762786930e1b1a0bb" title="returns an iterator pointing beyond the end of the vector, see More Notes.">end</a>() {
<a name="l01191"></a>01191         <span class="keywordflow">return</span> <a class="code" href="classvector.html#ad44a127aabeaa7a573f0c193b9f1b093" title="iterator used to iterate through a vector, see More Notes.">iterator</a>(<span class="keyword">this</span>, <a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a>);
<a name="l01192"></a>01192     }<span class="comment"></span>
<a name="l01193"></a>01193 <span class="comment">    //! returns a const_iterator pointing beyond the end of the vector, see \ref design_vector_notes.</span>
<a name="l01194"></a><a class="code" href="classvector.html#a24f11419dd6f6e78506e629cf3f211eb">01194</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_iterator</a> <a class="code" href="classvector.html#a24f11419dd6f6e78506e629cf3f211eb" title="returns a const_iterator pointing beyond the end of the vector, see More Notes.">end</a>()<span class="keyword"> const </span>{
<a name="l01195"></a>01195         <span class="keywordflow">return</span> <a class="code" href="classvector.html#aa4028dfad10b3ba6322ed5ad588f2713" title="constant iterator used to iterate through a vector, see More Notes.">const_iterator</a>(<span class="keyword">this</span>, <a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a>);
<a name="l01196"></a>01196     }<span class="comment"></span>
<a name="l01197"></a>01197 <span class="comment">    //! returns a const_iterator pointing beyond the end of the vector, see \ref design_vector_notes.</span>
<a name="l01198"></a><a class="code" href="classvector.html#a3f5eb4d62b1e30cf4b4a7b9208de63e6">01198</a> <span class="comment"></span>    <a class="code" href="classconst__vector__iterator.html" title="Const external vector iterator, model of ext_random_access_iterator concept.">const_iterator</a> <a class="code" href="classvector.html#a3f5eb4d62b1e30cf4b4a7b9208de63e6" title="returns a const_iterator pointing beyond the end of the vector, see More Notes.">cend</a>()<span class="keyword"> const </span>{
<a name="l01199"></a>01199         <span class="keywordflow">return</span> <a class="code" href="classvector.html#ad24f3779644689f762786930e1b1a0bb" title="returns an iterator pointing beyond the end of the vector, see More Notes.">end</a>();
<a name="l01200"></a>01200     }
<a name="l01201"></a>01201 <span class="comment"></span>
<a name="l01202"></a>01202 <span class="comment">    //! returns a reverse_iterator pointing to the end of the vector.</span>
<a name="l01203"></a><a class="code" href="classvector.html#a0461ed56ac87eef5dc09471e07ff18b4">01203</a> <span class="comment"></span>    <a class="code" href="classvector.html#aa339b04394662dd990f847148927e08e">reverse_iterator</a> <a class="code" href="classvector.html#a0461ed56ac87eef5dc09471e07ff18b4" title="returns a reverse_iterator pointing to the end of the vector.">rbegin</a>() {
<a name="l01204"></a>01204         <span class="keywordflow">return</span> <a class="code" href="classvector.html#aa339b04394662dd990f847148927e08e">reverse_iterator</a>(<a class="code" href="classvector.html#ad24f3779644689f762786930e1b1a0bb" title="returns an iterator pointing beyond the end of the vector, see More Notes.">end</a>());
<a name="l01205"></a>01205     }<span class="comment"></span>
<a name="l01206"></a>01206 <span class="comment">    //! returns a reverse_iterator pointing to the end of the vector.</span>
<a name="l01207"></a><a class="code" href="classvector.html#a39b895a22fc4ed88bdc00645d902b75e">01207</a> <span class="comment"></span>    <a class="code" href="classvector.html#a1d133685550d866a9bf624c2098cfb2d">const_reverse_iterator</a> <a class="code" href="classvector.html#a39b895a22fc4ed88bdc00645d902b75e" title="returns a reverse_iterator pointing to the end of the vector.">rbegin</a>()<span class="keyword"> const </span>{
<a name="l01208"></a>01208         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a1d133685550d866a9bf624c2098cfb2d">const_reverse_iterator</a>(<a class="code" href="classvector.html#ad24f3779644689f762786930e1b1a0bb" title="returns an iterator pointing beyond the end of the vector, see More Notes.">end</a>());
<a name="l01209"></a>01209     }<span class="comment"></span>
<a name="l01210"></a>01210 <span class="comment">    //! returns a reverse_iterator pointing to the end of the vector.</span>
<a name="l01211"></a><a class="code" href="classvector.html#a285ca0b051ece55aba221f0c1fd19fa3">01211</a> <span class="comment"></span>    <a class="code" href="classvector.html#a1d133685550d866a9bf624c2098cfb2d">const_reverse_iterator</a> <a class="code" href="classvector.html#a285ca0b051ece55aba221f0c1fd19fa3" title="returns a reverse_iterator pointing to the end of the vector.">crbegin</a>()<span class="keyword"> const </span>{
<a name="l01212"></a>01212         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a1d133685550d866a9bf624c2098cfb2d">const_reverse_iterator</a>(<a class="code" href="classvector.html#ad24f3779644689f762786930e1b1a0bb" title="returns an iterator pointing beyond the end of the vector, see More Notes.">end</a>());
<a name="l01213"></a>01213     }<span class="comment"></span>
<a name="l01214"></a>01214 <span class="comment">    //! returns a reverse_iterator pointing beyond the beginning of the vector.</span>
<a name="l01215"></a><a class="code" href="classvector.html#a98a0b552d25b4975a17cfb8358dcb07a">01215</a> <span class="comment"></span>    <a class="code" href="classvector.html#aa339b04394662dd990f847148927e08e">reverse_iterator</a> <a class="code" href="classvector.html#a98a0b552d25b4975a17cfb8358dcb07a" title="returns a reverse_iterator pointing beyond the beginning of the vector.">rend</a>() {
<a name="l01216"></a>01216         <span class="keywordflow">return</span> <a class="code" href="classvector.html#aa339b04394662dd990f847148927e08e">reverse_iterator</a>(<a class="code" href="classvector.html#a1816375aa4c8841be2dee870a9c69854" title="returns an iterator pointing to the beginning of the vector, see More Notes.">begin</a>());
<a name="l01217"></a>01217     }<span class="comment"></span>
<a name="l01218"></a>01218 <span class="comment">    //! returns a reverse_iterator pointing beyond the beginning of the vector.</span>
<a name="l01219"></a><a class="code" href="classvector.html#a38619543971b1e102e2dab2168d93426">01219</a> <span class="comment"></span>    <a class="code" href="classvector.html#a1d133685550d866a9bf624c2098cfb2d">const_reverse_iterator</a> <a class="code" href="classvector.html#a38619543971b1e102e2dab2168d93426" title="returns a reverse_iterator pointing beyond the beginning of the vector.">rend</a>()<span class="keyword"> const </span>{
<a name="l01220"></a>01220         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a1d133685550d866a9bf624c2098cfb2d">const_reverse_iterator</a>(<a class="code" href="classvector.html#a1816375aa4c8841be2dee870a9c69854" title="returns an iterator pointing to the beginning of the vector, see More Notes.">begin</a>());
<a name="l01221"></a>01221     }<span class="comment"></span>
<a name="l01222"></a>01222 <span class="comment">    //! returns a reverse_iterator pointing beyond the beginning of the vector.</span>
<a name="l01223"></a><a class="code" href="classvector.html#a889866e1bfb45e4d75f9ac2ada225249">01223</a> <span class="comment"></span>    <a class="code" href="classvector.html#a1d133685550d866a9bf624c2098cfb2d">const_reverse_iterator</a> <a class="code" href="classvector.html#a889866e1bfb45e4d75f9ac2ada225249" title="returns a reverse_iterator pointing beyond the beginning of the vector.">crend</a>()<span class="keyword"> const </span>{
<a name="l01224"></a>01224         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a1d133685550d866a9bf624c2098cfb2d">const_reverse_iterator</a>(<a class="code" href="classvector.html#a1816375aa4c8841be2dee870a9c69854" title="returns an iterator pointing to the beginning of the vector, see More Notes.">begin</a>());
<a name="l01225"></a>01225     }
<a name="l01226"></a>01226 <span class="comment"></span>
<a name="l01227"></a>01227 <span class="comment">    //! \}</span>
<a name="l01228"></a>01228 <span class="comment"></span><span class="comment"></span>
<a name="l01229"></a>01229 <span class="comment">    //! \name Direct Element Access</span>
<a name="l01230"></a>01230 <span class="comment">    //! \{</span>
<a name="l01231"></a>01231 <span class="comment"></span><span class="comment"></span>
<a name="l01232"></a>01232 <span class="comment">    //! access the element at the given vector&#39;s offset</span>
<a name="l01233"></a><a class="code" href="classvector.html#a9e5a9186ab9e8a3c869c599619f3a753">01233</a> <span class="comment"></span>    <a class="code" href="classvector.html#a7d234f8da8ce66aacfe18001d887e4cf" title="reference to value_type">reference</a> <a class="code" href="classvector.html#a9e5a9186ab9e8a3c869c599619f3a753" title="access the element at the given vector&#39;s offset">operator [] </a>(<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> offset) {
<a name="l01234"></a>01234         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a675d7bf74bd470ba56b7105531825255">element</a>(offset);
<a name="l01235"></a>01235     }<span class="comment"></span>
<a name="l01236"></a>01236 <span class="comment">    //! access the element at the given vector&#39;s offset</span>
<a name="l01237"></a><a class="code" href="classvector.html#a738fa1e69ee0a30eca312c892c511ff5">01237</a> <span class="comment"></span>    <a class="code" href="classvector.html#ab1387877afd358151c6b6b8867d40fa6" title="constant reference to value_type">const_reference</a> <a class="code" href="classvector.html#a9e5a9186ab9e8a3c869c599619f3a753" title="access the element at the given vector&#39;s offset">operator [] </a>(<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> offset)<span class="keyword"> const </span>{
<a name="l01238"></a>01238         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a606834d73c078850aba1ce9f750a3ac7">const_element</a>(offset);
<a name="l01239"></a>01239     }
<a name="l01240"></a>01240 <span class="comment"></span>
<a name="l01241"></a>01241 <span class="comment">    //! access the element at the given vector&#39;s offset</span>
<a name="l01242"></a><a class="code" href="classvector.html#a75e0ae7d170cafba9e2882d9cc8f05eb">01242</a> <span class="comment"></span>    <a class="code" href="classvector.html#a7d234f8da8ce66aacfe18001d887e4cf" title="reference to value_type">reference</a> <a class="code" href="classvector.html#a75e0ae7d170cafba9e2882d9cc8f05eb" title="access the element at the given vector&#39;s offset">at</a>(<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> offset) {
<a name="l01243"></a>01243         assert(offset &lt; (<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>) <a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>());
<a name="l01244"></a>01244         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a675d7bf74bd470ba56b7105531825255">element</a>(offset);
<a name="l01245"></a>01245     }<span class="comment"></span>
<a name="l01246"></a>01246 <span class="comment">    //! access the element at the given vector&#39;s offset</span>
<a name="l01247"></a><a class="code" href="classvector.html#aeefc104bb0094bde3617042aa22dcfb0">01247</a> <span class="comment"></span>    <a class="code" href="classvector.html#ab1387877afd358151c6b6b8867d40fa6" title="constant reference to value_type">const_reference</a> <a class="code" href="classvector.html#aeefc104bb0094bde3617042aa22dcfb0" title="access the element at the given vector&#39;s offset">at</a>(<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> offset)<span class="keyword"> const </span>{
<a name="l01248"></a>01248         assert(offset &lt; (<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>) <a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>());
<a name="l01249"></a>01249         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a606834d73c078850aba1ce9f750a3ac7">const_element</a>(offset);
<a name="l01250"></a>01250     }
<a name="l01251"></a>01251 <span class="comment"></span>
<a name="l01252"></a>01252 <span class="comment">    //! return true if the given vector offset is in cache</span>
<a name="l01253"></a><a class="code" href="classvector.html#a63c2e648d9101073342522914e52e603">01253</a> <span class="comment"></span>    <span class="keywordtype">bool</span> <a class="code" href="classvector.html#a63c2e648d9101073342522914e52e603" title="return true if the given vector offset is in cache">is_element_cached</a>(<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> offset)<span class="keyword"> const </span>{
<a name="l01254"></a>01254         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a5652c9f6cc25abf15858393bd8ff8d61">is_page_cached</a>(<a class="code" href="classvector.html#a9df497483a4b73a4f7c94b51396495ef" title="double-index type to reference individual elements in a block">blocked_index_type</a>(offset));
<a name="l01255"></a>01255     }
<a name="l01256"></a>01256 <span class="comment"></span>
<a name="l01257"></a>01257 <span class="comment">    //! \}</span>
<a name="l01258"></a>01258 <span class="comment"></span><span class="comment"></span>
<a name="l01259"></a>01259 <span class="comment">    //! \name Modifiers</span>
<a name="l01260"></a>01260 <span class="comment">    //! \{</span>
<a name="l01261"></a>01261 <span class="comment"></span><span class="comment"></span>
<a name="l01262"></a>01262 <span class="comment">    //! Flushes the cache pages to the external memory.</span>
<a name="l01263"></a><a class="code" href="classvector.html#a08276777f1d54845546843d77f402904">01263</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector.html#a08276777f1d54845546843d77f402904" title="Flushes the cache pages to the external memory.">flush</a>()<span class="keyword"> const </span>{
<a name="l01264"></a>01264         stxxl::simple_vector&lt;bool&gt; non_free_slots(<a class="code" href="classvector.html#a647786c3a0b78901bd5aa4b64d0bd851" title="Number of pages used by the pager.">numpages</a>());
<a name="l01265"></a>01265 
<a name="l01266"></a>01266         <span class="keywordflow">for</span> (stxxl::unsigned_type i = 0; i &lt; <a class="code" href="classvector.html#a647786c3a0b78901bd5aa4b64d0bd851" title="Number of pages used by the pager.">numpages</a>(); i++)
<a name="l01267"></a>01267             non_free_slots[i] = <span class="keyword">true</span>;
<a name="l01268"></a>01268 
<a name="l01269"></a>01269         <span class="keywordflow">while</span> (!<a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.empty()) {
<a name="l01270"></a>01270             non_free_slots[<a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.front()] = <span class="keyword">false</span>;
<a name="l01271"></a>01271             <a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.pop();
<a name="l01272"></a>01272         }
<a name="l01273"></a>01273 
<a name="l01274"></a>01274         <span class="keywordflow">for</span> (stxxl::unsigned_type i = 0; i &lt; <a class="code" href="classvector.html#a647786c3a0b78901bd5aa4b64d0bd851" title="Number of pages used by the pager.">numpages</a>(); i++) {
<a name="l01275"></a>01275             <a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.push(i);
<a name="l01276"></a>01276             stxxl::int_type page_no = <a class="code" href="classvector.html#a91e85df3c4867d28367bdaadc6dad0b9">m_slot_to_page</a>[i];
<a name="l01277"></a>01277             <span class="keywordflow">if</span> (non_free_slots[i]) {
<a name="l01278"></a>01278                 <a class="code" href="ExtStxxlVector_8h.html#adce24d9daba86c6533c3ade041e3da39">STXXL_VERBOSE_VECTOR</a>(<span class="stringliteral">&quot;flush(): flushing page &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; at address &quot;</span> &lt;&lt;
<a name="l01279"></a>01279                         (int64(page_no) * int64(block_type::size) * int64(<a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>)));
<a name="l01280"></a>01280                 <a class="code" href="classvector.html#a0a454dc055a5e29480100b79a5e1b915">write_page</a>(page_no, i);
<a name="l01281"></a>01281 
<a name="l01282"></a>01282                 <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[page_no] = <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a86d6dc0e6dae77e956822ccd989c8e75">on_disk</a>;
<a name="l01283"></a>01283             }
<a name="l01284"></a>01284         }
<a name="l01285"></a>01285     }
<a name="l01286"></a>01286 <span class="comment"></span>
<a name="l01287"></a>01287 <span class="comment">    //! \}</span>
<a name="l01288"></a>01288 <span class="comment"></span><span class="comment"></span>
<a name="l01289"></a>01289 <span class="comment">    //! \name Constructors/Destructors</span>
<a name="l01290"></a>01290 <span class="comment">    //! \{</span>
<a name="l01291"></a><a class="code" href="classvector.html#a486d4b263ee9b76b0ff7fb82f96dfd18">01291</a> <span class="comment"></span>    <a class="code" href="classvector.html#a486d4b263ee9b76b0ff7fb82f96dfd18">~vector</a>() {
<a name="l01292"></a>01292         <a class="code" href="ExtStxxlVector_8h.html#adce24d9daba86c6533c3ade041e3da39">STXXL_VERBOSE_VECTOR</a>(<span class="stringliteral">&quot;~vector()&quot;</span>);
<a name="l01293"></a>01293         <span class="keywordflow">try</span> {
<a name="l01294"></a>01294             <a class="code" href="classvector.html#a08276777f1d54845546843d77f402904" title="Flushes the cache pages to the external memory.">flush</a>();
<a name="l01295"></a>01295         }        <span class="keywordflow">catch</span> (stxxl::io_error e) {
<a name="l01296"></a>01296             STXXL_ERRMSG(<span class="stringliteral">&quot;io_error thrown in ~vector(): &quot;</span> &lt;&lt; e.what());
<a name="l01297"></a>01297         }        <span class="keywordflow">catch</span> (...) {
<a name="l01298"></a>01298             STXXL_ERRMSG(<span class="stringliteral">&quot;Exception thrown in ~vector()&quot;</span>);
<a name="l01299"></a>01299         }
<a name="l01300"></a>01300 
<a name="l01301"></a>01301         <span class="keywordflow">if</span> (!<a class="code" href="classvector.html#a77523b724b9cf2f3707abfd3d74dd721">m_exported</a>) {
<a name="l01302"></a>01302             <span class="keywordflow">if</span> (<a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">m_from</a> == NULL) {
<a name="l01303"></a>01303                 <a class="code" href="classvector.html#a5b450d62462ada69c9708680b4fa24ae">m_bm</a>-&gt;delete_blocks(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.begin(), <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.end());
<a name="l01304"></a>01304             } <span class="keywordflow">else</span> <span class="comment">// file must be truncated</span>
<a name="l01305"></a>01305             {
<a name="l01306"></a>01306                 <a class="code" href="ExtStxxlVector_8h.html#adce24d9daba86c6533c3ade041e3da39">STXXL_VERBOSE_VECTOR</a>(<span class="stringliteral">&quot;~vector(): Changing size of file &quot;</span> &lt;&lt;
<a name="l01307"></a>01307                         ((<span class="keywordtype">void</span>*) <a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">m_from</a>) &lt;&lt; <span class="stringliteral">&quot; to &quot;</span> &lt;&lt; <a class="code" href="classvector.html#a43dcb975091d8c1bb4f1f08d05e0651e">file_length</a>());
<a name="l01308"></a>01308                 <a class="code" href="ExtStxxlVector_8h.html#adce24d9daba86c6533c3ade041e3da39">STXXL_VERBOSE_VECTOR</a>(<span class="stringliteral">&quot;~vector(): size of the vector is &quot;</span> &lt;&lt; <a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>());
<a name="l01309"></a>01309                 <span class="keywordflow">try</span> {
<a name="l01310"></a>01310                     m_from-&gt;set_size(<a class="code" href="classvector.html#a43dcb975091d8c1bb4f1f08d05e0651e">file_length</a>());
<a name="l01311"></a>01311                 }                <span class="keywordflow">catch</span> (...) {
<a name="l01312"></a>01312                     STXXL_ERRMSG(<span class="stringliteral">&quot;Exception thrown in ~vector()...set_size()&quot;</span>);
<a name="l01313"></a>01313                 }
<a name="l01314"></a>01314             }
<a name="l01315"></a>01315         }
<a name="l01316"></a>01316         <span class="keyword">delete</span> <a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a>;
<a name="l01317"></a>01317     }
<a name="l01318"></a>01318 <span class="comment"></span>
<a name="l01319"></a>01319 <span class="comment">    //! \}</span>
<a name="l01320"></a>01320 <span class="comment"></span><span class="comment"></span>
<a name="l01321"></a>01321 <span class="comment">    //! \name Miscellaneous</span>
<a name="l01322"></a>01322 <span class="comment">    //! \{</span>
<a name="l01323"></a>01323 <span class="comment"></span><span class="comment"></span>
<a name="l01324"></a>01324 <span class="comment">    //! Export data such that it is persistent on the file system. Resulting</span>
<a name="l01325"></a>01325 <span class="comment">    //! files will be numbered ascending.</span>
<a name="l01326"></a><a class="code" href="classvector.html#afa4e61c44fb118a6ea660801b08911a7">01326</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector.html#afa4e61c44fb118a6ea660801b08911a7" title="Export data such that it is persistent on the file system. Resulting files will be numbered ascending...">export_files</a>(std::string filename_prefix) {
<a name="l01327"></a>01327         stxxl::int64 no = 0;
<a name="l01328"></a>01328         <span class="keywordflow">for</span> (<a class="code" href="classvector.html#a81fede0a4a86f8e21370dee34ddebdf0">bids_container_iterator</a> i = <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.begin(); i != <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.end(); ++i) {
<a name="l01329"></a>01329             std::ostringstream number;
<a name="l01330"></a>01330             number &lt;&lt; std::setw(9) &lt;&lt; std::setfill(<span class="charliteral">&#39;0&#39;</span>) &lt;&lt; no;
<a name="l01331"></a>01331             <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> current_block_size =
<a name="l01332"></a>01332                     ((i + 1) == <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.end() &amp;&amp; <a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a> % block_type::size &gt; 0) ?
<a name="l01333"></a>01333                     (<a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a> % block_type::size) * <span class="keyword">sizeof</span> (<a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">value_type</a>) :
<a name="l01334"></a>01334                     block_type::size * <span class="keyword">sizeof</span> (<a class="code" href="classvector.html#afcb4d695424a2d91e5fa3fa08cf79029" title="The type of elements stored in the vector.">value_type</a>);
<a name="l01335"></a>01335             (*i).storage-&gt;export_files((*i).offset, current_block_size, filename_prefix + number.str());
<a name="l01336"></a>01336             ++no;
<a name="l01337"></a>01337         }
<a name="l01338"></a>01338         <a class="code" href="classvector.html#a77523b724b9cf2f3707abfd3d74dd721">m_exported</a> = <span class="keyword">true</span>;
<a name="l01339"></a>01339     }
<a name="l01340"></a>01340 <span class="comment"></span>
<a name="l01341"></a>01341 <span class="comment">    //! Get the file associated with this vector, or NULL.</span>
<a name="l01342"></a><a class="code" href="classvector.html#af56a25cc04479e1eacc74e2a8f6ddb8f">01342</a> <span class="comment"></span>    stxxl::file * <a class="code" href="classvector.html#af56a25cc04479e1eacc74e2a8f6ddb8f" title="Get the file associated with this vector, or NULL.">get_file</a>()<span class="keyword"> const </span>{
<a name="l01343"></a>01343         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a1cf8957409787db4b4e224bda9c523be">m_from</a>;
<a name="l01344"></a>01344     }
<a name="l01345"></a>01345 <span class="comment"></span>
<a name="l01346"></a>01346 <span class="comment">    //! \}</span>
<a name="l01347"></a>01347 <span class="comment"></span><span class="comment"></span>
<a name="l01348"></a>01348 <span class="comment">    //! \name Capacity</span>
<a name="l01349"></a>01349 <span class="comment">    //! \{</span>
<a name="l01350"></a>01350 <span class="comment"></span><span class="comment"></span>
<a name="l01351"></a>01351 <span class="comment">    //! Set the blocks and the size of this container explicitly.</span>
<a name="l01352"></a>01352 <span class="comment">    //! The vector must be completely empty before.</span>
<a name="l01353"></a>01353 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;
<a name="l01354"></a><a class="code" href="classvector.html#a27e8c1c6906463bbc247c5e76309458e">01354</a>     <span class="keywordtype">void</span> <a class="code" href="classvector.html#a27e8c1c6906463bbc247c5e76309458e" title="Set the blocks and the size of this container explicitly. The vector must be completely empty before...">set_content</a>(<span class="keyword">const</span> ForwardIterator&amp; bid_begin, <span class="keyword">const</span> ForwardIterator&amp; bid_end, <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> n) {
<a name="l01355"></a>01355         stxxl::unsigned_type new_bids_size = div_ceil(n, block_type::size);
<a name="l01356"></a>01356         <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.resize(new_bids_size);
<a name="l01357"></a>01357         std::copy(bid_begin, bid_end, <a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.begin());
<a name="l01358"></a>01358         stxxl::unsigned_type new_pages = div_ceil(new_bids_size, <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>);
<a name="l01359"></a>01359         <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>.resize(new_pages, <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7ae7dfa2765991ce5aeb5428648c9bf816">valid_on_disk</a>);
<a name="l01360"></a>01360         <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>.resize(new_pages, <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a86d6dc0e6dae77e956822ccd989c8e75">on_disk</a>);
<a name="l01361"></a>01361         <a class="code" href="classvector.html#a532eb14fd7ab98d54cfe324c4ad6b8f2">m_size</a> = n;
<a name="l01362"></a>01362     }
<a name="l01363"></a>01363 <span class="comment"></span>
<a name="l01364"></a>01364 <span class="comment">    //! Number of pages used by the pager.</span>
<a name="l01365"></a><a class="code" href="classvector.html#a647786c3a0b78901bd5aa4b64d0bd851">01365</a> <span class="comment"></span>    <span class="keyword">inline</span> stxxl::unsigned_type <a class="code" href="classvector.html#a647786c3a0b78901bd5aa4b64d0bd851" title="Number of pages used by the pager.">numpages</a>()<span class="keyword"> const </span>{
<a name="l01366"></a>01366         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">m_pager</a>.size();
<a name="l01367"></a>01367     }
<a name="l01368"></a>01368 <span class="comment"></span>
<a name="l01369"></a>01369 <span class="comment">    //! \}</span>
<a name="l01370"></a>01370 <span class="comment"></span>
<a name="l01371"></a>01371 <span class="keyword">protected</span>: <span class="comment">// Shifted from private to protected for overloading operators</span>
<a name="l01372"></a><a class="code" href="classvector.html#afc255367efd086550c9d14dfaf525e2f">01372</a>     <a class="code" href="classvector.html#a81fede0a4a86f8e21370dee34ddebdf0">bids_container_iterator</a> <a class="code" href="classvector.html#afc255367efd086550c9d14dfaf525e2f">bid</a>(<span class="keyword">const</span> <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>&amp; offset) {
<a name="l01373"></a>01373         <span class="keywordflow">return</span> (<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.begin() +
<a name="l01374"></a>01374                 <span class="keyword">static_cast&lt;</span>typename <a class="code" href="classvector_1_1bid__vector.html#a7ab1cec499de77fff1848a7a018ae63d">bids_container_type::size_type</a><span class="keyword">&gt;</span>
<a name="l01375"></a>01375                 (offset / <a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">block_type::size</a>));
<a name="l01376"></a>01376     }
<a name="l01377"></a><a class="code" href="classvector.html#a013714e32733d3535a1e22e15125bae4">01377</a>     <a class="code" href="classvector.html#a81fede0a4a86f8e21370dee34ddebdf0">bids_container_iterator</a> <a class="code" href="classvector.html#a013714e32733d3535a1e22e15125bae4">bid</a>(<span class="keyword">const</span> <a class="code" href="classdouble__blocked__index.html">blocked_index_type</a>&amp; offset) {
<a name="l01378"></a>01378         <span class="keywordflow">return</span> (<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.begin() +
<a name="l01379"></a>01379                 <span class="keyword">static_cast&lt;</span>typename <a class="code" href="classvector_1_1bid__vector.html#a7ab1cec499de77fff1848a7a018ae63d">bids_container_type::size_type</a><span class="keyword">&gt;</span>
<a name="l01380"></a>01380                 (offset.<a class="code" href="classdouble__blocked__index.html#a009424151b91d062eae3de2f6f2348e0">get_block2</a>() * PageSize + offset.<a class="code" href="classdouble__blocked__index.html#aafdf535df1c21633f37dae5e67868cd4">get_block1</a>()));
<a name="l01381"></a>01381     }
<a name="l01382"></a><a class="code" href="classvector.html#a954fed8fee38ed29794e828c996d9813">01382</a>     <a class="code" href="classvector.html#affc6a4bd1a628053afe7d10226fc9e2e">const_bids_container_iterator</a> <a class="code" href="classvector.html#a954fed8fee38ed29794e828c996d9813">bid</a>(<span class="keyword">const</span> <a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>&amp; offset)<span class="keyword"> const </span>{
<a name="l01383"></a>01383         <span class="keywordflow">return</span> (<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.begin() +
<a name="l01384"></a>01384                 <span class="keyword">static_cast&lt;</span>typename <a class="code" href="classvector_1_1bid__vector.html#a7ab1cec499de77fff1848a7a018ae63d">bids_container_type::size_type</a><span class="keyword">&gt;</span>
<a name="l01385"></a>01385                 (offset / <a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">block_type::size</a>));
<a name="l01386"></a>01386     }
<a name="l01387"></a><a class="code" href="classvector.html#a60dbc03fc181f438128286b8eedb3bb9">01387</a>     <a class="code" href="classvector.html#affc6a4bd1a628053afe7d10226fc9e2e">const_bids_container_iterator</a> <a class="code" href="classvector.html#a60dbc03fc181f438128286b8eedb3bb9">bid</a>(<span class="keyword">const</span> <a class="code" href="classdouble__blocked__index.html">blocked_index_type</a>&amp; offset)<span class="keyword"> const </span>{
<a name="l01388"></a>01388         <span class="keywordflow">return</span> (<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.begin() +
<a name="l01389"></a>01389                 <span class="keyword">static_cast&lt;</span>typename <a class="code" href="classvector_1_1bid__vector.html#a7ab1cec499de77fff1848a7a018ae63d">bids_container_type::size_type</a><span class="keyword">&gt;</span>
<a name="l01390"></a>01390                 (offset.<a class="code" href="classdouble__blocked__index.html#a009424151b91d062eae3de2f6f2348e0">get_block2</a>() * PageSize + offset.<a class="code" href="classdouble__blocked__index.html#aafdf535df1c21633f37dae5e67868cd4">get_block1</a>()));
<a name="l01391"></a>01391     }
<a name="l01392"></a><a class="code" href="classvector.html#adab50b72b2e942572862afe45baf4267">01392</a>     <span class="keywordtype">void</span> <a class="code" href="classvector.html#adab50b72b2e942572862afe45baf4267">read_page</a>(stxxl::int_type page_no, stxxl::int_type cache_slot)<span class="keyword"> const </span>{
<a name="l01393"></a>01393         assert(page_no &lt; (stxxl::int_type)<a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>.size());
<a name="l01394"></a>01394         <span class="keywordflow">if</span> (<a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>[page_no] == <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7a47756c13e50315322ce75879b7f92fa9">uninitialized</a>)
<a name="l01395"></a>01395             <span class="keywordflow">return</span>;
<a name="l01396"></a>01396         <a class="code" href="ExtStxxlVector_8h.html#adce24d9daba86c6533c3ade041e3da39">STXXL_VERBOSE_VECTOR</a>(<span class="stringliteral">&quot;read_page(): page_no=&quot;</span> &lt;&lt; page_no &lt;&lt; <span class="stringliteral">&quot; cache_slot=&quot;</span> &lt;&lt; cache_slot);
<a name="l01397"></a>01397         stxxl::request_ptr* reqs = <span class="keyword">new</span> stxxl::request_ptr[<a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>];
<a name="l01398"></a>01398         stxxl::int_type block_no = page_no * <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>;
<a name="l01399"></a>01399         stxxl::int_type last_block = stxxl::STXXL_MIN(block_no + page_size, stxxl::int_type(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.size()));
<a name="l01400"></a>01400         stxxl::int_type i = cache_slot * <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>, j = 0;
<a name="l01401"></a>01401         <span class="keywordflow">for</span> (; block_no &lt; last_block; ++block_no, ++i, ++j) {
<a name="l01402"></a>01402             reqs[j] = (*m_cache)[i].read(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>[block_no]);
<a name="l01403"></a>01403         }
<a name="l01404"></a>01404         assert(last_block - page_no * page_size &gt; 0);
<a name="l01405"></a>01405         wait_all(reqs, last_block - page_no * page_size);
<a name="l01406"></a>01406         <span class="keyword">delete</span>[] reqs;
<a name="l01407"></a>01407     }
<a name="l01408"></a><a class="code" href="classvector.html#a0a454dc055a5e29480100b79a5e1b915">01408</a>     <span class="keywordtype">void</span> <a class="code" href="classvector.html#a0a454dc055a5e29480100b79a5e1b915">write_page</a>(stxxl::int_type page_no, stxxl::int_type cache_slot)<span class="keyword"> const </span>{
<a name="l01409"></a>01409         assert(page_no &lt; (stxxl::int_type)<a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>.size());
<a name="l01410"></a>01410         <span class="keywordflow">if</span> (!(<a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>[page_no] &amp; <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7ac8164fa4d1dbfc53d3afde2702df77ae">dirty</a>))
<a name="l01411"></a>01411             <span class="keywordflow">return</span>;
<a name="l01412"></a>01412         <a class="code" href="ExtStxxlVector_8h.html#adce24d9daba86c6533c3ade041e3da39">STXXL_VERBOSE_VECTOR</a>(<span class="stringliteral">&quot;write_page(): page_no=&quot;</span> &lt;&lt; page_no &lt;&lt; <span class="stringliteral">&quot; cache_slot=&quot;</span> &lt;&lt; cache_slot);
<a name="l01413"></a>01413         stxxl::request_ptr* reqs = <span class="keyword">new</span> stxxl::request_ptr[<a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>];
<a name="l01414"></a>01414         stxxl::int_type block_no = page_no * <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>;
<a name="l01415"></a>01415         stxxl::int_type last_block = stxxl::STXXL_MIN(block_no + page_size, stxxl::int_type(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>.size()));
<a name="l01416"></a>01416         assert(block_no &lt; last_block);
<a name="l01417"></a>01417         stxxl::int_type i = cache_slot * <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>, j = 0;
<a name="l01418"></a>01418         <span class="keywordflow">for</span> (; block_no &lt; last_block; ++block_no, ++i, ++j) {
<a name="l01419"></a>01419             reqs[j] = (*m_cache)[i].write(<a class="code" href="classvector.html#a3396b2792d93cb2fc907f275ae27ee70">m_bids</a>[block_no]);
<a name="l01420"></a>01420         }
<a name="l01421"></a>01421         <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>[page_no] = <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7ae7dfa2765991ce5aeb5428648c9bf816">valid_on_disk</a>;
<a name="l01422"></a>01422         assert(last_block - page_no * page_size &gt; 0);
<a name="l01423"></a>01423         wait_all(reqs, last_block - page_no * page_size);
<a name="l01424"></a>01424         <span class="keyword">delete</span>[] reqs;
<a name="l01425"></a>01425     }
<a name="l01426"></a><a class="code" href="classvector.html#a675d7bf74bd470ba56b7105531825255">01426</a>     <a class="code" href="classvector.html#a7d234f8da8ce66aacfe18001d887e4cf" title="reference to value_type">reference</a> <a class="code" href="classvector.html#a675d7bf74bd470ba56b7105531825255">element</a>(<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> offset) {
<a name="l01427"></a>01427 <span class="preprocessor">#ifdef STXXL_RANGE_CHECK</span>
<a name="l01428"></a>01428 <span class="preprocessor"></span>        assert(offset &lt; (<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a>) <a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>());
<a name="l01429"></a>01429 <span class="preprocessor">#endif</span>
<a name="l01430"></a>01430 <span class="preprocessor"></span>        <span class="keywordflow">return</span> <a class="code" href="classvector.html#a675d7bf74bd470ba56b7105531825255">element</a>(<a class="code" href="classvector.html#a9df497483a4b73a4f7c94b51396495ef" title="double-index type to reference individual elements in a block">blocked_index_type</a>(offset));
<a name="l01431"></a>01431     }
<a name="l01432"></a><a class="code" href="classvector.html#ac6938160f736a298ca971ad8c5a960b2">01432</a>     <a class="code" href="classvector.html#a7d234f8da8ce66aacfe18001d887e4cf" title="reference to value_type">reference</a> <a class="code" href="classvector.html#ac6938160f736a298ca971ad8c5a960b2">element</a>(<span class="keyword">const</span> <a class="code" href="classdouble__blocked__index.html">blocked_index_type</a>&amp; offset) {
<a name="l01433"></a>01433 <span class="preprocessor">#ifdef STXXL_RANGE_CHECK</span>
<a name="l01434"></a>01434 <span class="preprocessor"></span>        assert(offset.<a class="code" href="classdouble__blocked__index.html#a7060ab1819ce0b998152781efc863ea9">get_pos</a>() &lt; <a class="code" href="classvector.html#a7733a3fa8bdfc01a3b722c78b8e0dc17" title="return the size of the vector.">size</a>());
<a name="l01435"></a>01435 <span class="preprocessor">#endif</span>
<a name="l01436"></a>01436 <span class="preprocessor"></span>        stxxl::unsigned_type page_no = offset.<a class="code" href="classdouble__blocked__index.html#a009424151b91d062eae3de2f6f2348e0">get_block2</a>();
<a name="l01437"></a>01437         assert(page_no &lt; <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>.size()); <span class="comment">// fails if offset is too large, out of bound access</span>
<a name="l01438"></a>01438         stxxl::int_type cache_slot = <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[page_no];
<a name="l01439"></a>01439         <span class="keywordflow">if</span> (cache_slot &lt; 0) <span class="comment">// == on_disk</span>
<a name="l01440"></a>01440         {
<a name="l01441"></a>01441             <span class="keywordflow">if</span> (<a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.empty()) <span class="comment">// has to kick</span>
<a name="l01442"></a>01442             {
<a name="l01443"></a>01443                 stxxl::int_type kicked_slot = <a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">m_pager</a>.kick();
<a name="l01444"></a>01444                 <a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">m_pager</a>.hit(kicked_slot);
<a name="l01445"></a>01445                 stxxl::int_type old_page_no = <a class="code" href="classvector.html#a91e85df3c4867d28367bdaadc6dad0b9">m_slot_to_page</a>[kicked_slot];
<a name="l01446"></a>01446                 <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[page_no] = kicked_slot;
<a name="l01447"></a>01447                 <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[old_page_no] = <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a86d6dc0e6dae77e956822ccd989c8e75">on_disk</a>;
<a name="l01448"></a>01448                 <a class="code" href="classvector.html#a91e85df3c4867d28367bdaadc6dad0b9">m_slot_to_page</a>[kicked_slot] = page_no;
<a name="l01449"></a>01449 
<a name="l01450"></a>01450                 <a class="code" href="classvector.html#a0a454dc055a5e29480100b79a5e1b915">write_page</a>(old_page_no, kicked_slot);
<a name="l01451"></a>01451                 <a class="code" href="classvector.html#adab50b72b2e942572862afe45baf4267">read_page</a>(page_no, kicked_slot);
<a name="l01452"></a>01452 
<a name="l01453"></a>01453                 <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>[page_no] = <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7ac8164fa4d1dbfc53d3afde2702df77ae">dirty</a>;
<a name="l01454"></a>01454 
<a name="l01455"></a>01455                 <span class="keywordflow">return</span> (*<a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a>)[kicked_slot * <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a> + offset.<a class="code" href="classdouble__blocked__index.html#aafdf535df1c21633f37dae5e67868cd4">get_block1</a>()][offset.<a class="code" href="classdouble__blocked__index.html#ab2aae63d414d2b771b3cb6fff9f279cc">get_offset</a>()];
<a name="l01456"></a>01456             } <span class="keywordflow">else</span> {
<a name="l01457"></a>01457                 stxxl::int_type free_slot = <a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.front();
<a name="l01458"></a>01458                 <a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.pop();
<a name="l01459"></a>01459                 <a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">m_pager</a>.hit(free_slot);
<a name="l01460"></a>01460                 <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[page_no] = free_slot;
<a name="l01461"></a>01461                 <a class="code" href="classvector.html#a91e85df3c4867d28367bdaadc6dad0b9">m_slot_to_page</a>[free_slot] = page_no;
<a name="l01462"></a>01462 
<a name="l01463"></a>01463                 <a class="code" href="classvector.html#adab50b72b2e942572862afe45baf4267">read_page</a>(page_no, free_slot);
<a name="l01464"></a>01464 
<a name="l01465"></a>01465                 <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>[page_no] = <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7ac8164fa4d1dbfc53d3afde2702df77ae">dirty</a>;
<a name="l01466"></a>01466 
<a name="l01467"></a>01467                 <span class="keywordflow">return</span> (*<a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a>)[free_slot * <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a> + offset.<a class="code" href="classdouble__blocked__index.html#aafdf535df1c21633f37dae5e67868cd4">get_block1</a>()][offset.<a class="code" href="classdouble__blocked__index.html#ab2aae63d414d2b771b3cb6fff9f279cc">get_offset</a>()];
<a name="l01468"></a>01468             }
<a name="l01469"></a>01469         } <span class="keywordflow">else</span> {
<a name="l01470"></a>01470             <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>[page_no] = <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7ac8164fa4d1dbfc53d3afde2702df77ae">dirty</a>;
<a name="l01471"></a>01471             <a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">m_pager</a>.hit(cache_slot);
<a name="l01472"></a>01472             <span class="keywordflow">return</span> (*<a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a>)[cache_slot * <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a> + offset.<a class="code" href="classdouble__blocked__index.html#aafdf535df1c21633f37dae5e67868cd4">get_block1</a>()][offset.<a class="code" href="classdouble__blocked__index.html#ab2aae63d414d2b771b3cb6fff9f279cc">get_offset</a>()];
<a name="l01473"></a>01473         }
<a name="l01474"></a>01474     }
<a name="l01475"></a>01475 
<a name="l01476"></a>01476     <span class="comment">// don&#39;t forget to first flush() the vector&#39;s cache before updating pages externally</span>
<a name="l01477"></a><a class="code" href="classvector.html#a9f5ef7073809ec9605f1bcb7a674a547">01477</a>     <span class="keywordtype">void</span> <a class="code" href="classvector.html#a9f5ef7073809ec9605f1bcb7a674a547">page_externally_updated</a>(stxxl::unsigned_type page_no)<span class="keyword"> const </span>{
<a name="l01478"></a>01478         <span class="comment">// fails if offset is too large, out of bound access</span>
<a name="l01479"></a>01479         assert(page_no &lt; <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>.size());
<a name="l01480"></a>01480         <span class="comment">// &quot;A dirty page has been marked as newly initialized. The page content will be lost.&quot;</span>
<a name="l01481"></a>01481         assert(!(<a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>[page_no] &amp; <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7ac8164fa4d1dbfc53d3afde2702df77ae">dirty</a>));
<a name="l01482"></a>01482         <span class="keywordflow">if</span> (<a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[page_no] != <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a86d6dc0e6dae77e956822ccd989c8e75">on_disk</a>) {
<a name="l01483"></a>01483             <span class="comment">// remove page from cache</span>
<a name="l01484"></a>01484             <a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.push(<a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[page_no]);
<a name="l01485"></a>01485             <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[page_no] = <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a86d6dc0e6dae77e956822ccd989c8e75">on_disk</a>;
<a name="l01486"></a>01486             <a class="code" href="ExtStxxlVector_8h.html#adce24d9daba86c6533c3ade041e3da39">STXXL_VERBOSE_VECTOR</a>(<span class="stringliteral">&quot;page_externally_updated(): page_no=&quot;</span> &lt;&lt; page_no &lt;&lt; <span class="stringliteral">&quot; flushed from cache.&quot;</span>);
<a name="l01487"></a>01487         } <span class="keywordflow">else</span> {
<a name="l01488"></a>01488             <a class="code" href="ExtStxxlVector_8h.html#adce24d9daba86c6533c3ade041e3da39">STXXL_VERBOSE_VECTOR</a>(<span class="stringliteral">&quot;page_externally_updated(): page_no=&quot;</span> &lt;&lt; page_no &lt;&lt; <span class="stringliteral">&quot; no need to flush.&quot;</span>);
<a name="l01489"></a>01489         }
<a name="l01490"></a>01490         <a class="code" href="classvector.html#a79325af4ed62485d144bb28f167ae0ed" title="status of each page (valid_on_disk, uninitialized or dirty)">m_page_status</a>[page_no] = <a class="code" href="classvector.html#ac77a4b25b1b7b819208e79c5c52857c7ae7dfa2765991ce5aeb5428648c9bf816">valid_on_disk</a>;
<a name="l01491"></a>01491     }
<a name="l01492"></a><a class="code" href="classvector.html#a4b2645e4c1afd03149aeb7b8975a2e17">01492</a>     <span class="keywordtype">void</span> <a class="code" href="classvector.html#a4b2645e4c1afd03149aeb7b8975a2e17">block_externally_updated</a>(<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> offset)<span class="keyword"> const </span>{
<a name="l01493"></a>01493         <a class="code" href="classvector.html#a9f5ef7073809ec9605f1bcb7a674a547">page_externally_updated</a>(offset / (block_type::size * <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a>));
<a name="l01494"></a>01494     }
<a name="l01495"></a><a class="code" href="classvector.html#a506540f4cf6fff6e634c79277497d461">01495</a>     <span class="keywordtype">void</span> <a class="code" href="classvector.html#a506540f4cf6fff6e634c79277497d461">block_externally_updated</a>(<span class="keyword">const</span> <a class="code" href="classdouble__blocked__index.html">blocked_index_type</a>&amp; offset)<span class="keyword"> const </span>{
<a name="l01496"></a>01496         <a class="code" href="classvector.html#a9f5ef7073809ec9605f1bcb7a674a547">page_externally_updated</a>(offset.<a class="code" href="classdouble__blocked__index.html#a009424151b91d062eae3de2f6f2348e0">get_block2</a>());
<a name="l01497"></a>01497     }
<a name="l01498"></a><a class="code" href="classvector.html#a606834d73c078850aba1ce9f750a3ac7">01498</a>     <a class="code" href="classvector.html#ab1387877afd358151c6b6b8867d40fa6" title="constant reference to value_type">const_reference</a> <a class="code" href="classvector.html#a606834d73c078850aba1ce9f750a3ac7">const_element</a>(<a class="code" href="classvector.html#ab21d3d2fc68f1cb9929d297132fe5ab3" title="an unsigned 64-bit integral type">size_type</a> offset)<span class="keyword"> const </span>{
<a name="l01499"></a>01499         <span class="keywordflow">return</span> <a class="code" href="classvector.html#a606834d73c078850aba1ce9f750a3ac7">const_element</a>(<a class="code" href="classvector.html#a9df497483a4b73a4f7c94b51396495ef" title="double-index type to reference individual elements in a block">blocked_index_type</a>(offset));
<a name="l01500"></a>01500     }
<a name="l01501"></a><a class="code" href="classvector.html#a1cc7d92c77ecbff8a7ee98e9612ef57b">01501</a>     <a class="code" href="classvector.html#ab1387877afd358151c6b6b8867d40fa6" title="constant reference to value_type">const_reference</a> <a class="code" href="classvector.html#a1cc7d92c77ecbff8a7ee98e9612ef57b">const_element</a>(<span class="keyword">const</span> <a class="code" href="classdouble__blocked__index.html">blocked_index_type</a>&amp; offset)<span class="keyword"> const </span>{
<a name="l01502"></a>01502         stxxl::unsigned_type page_no = offset.<a class="code" href="classdouble__blocked__index.html#a009424151b91d062eae3de2f6f2348e0">get_block2</a>();
<a name="l01503"></a>01503         assert(page_no &lt; <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>.size()); <span class="comment">// fails if offset is too large, out of bound access</span>
<a name="l01504"></a>01504         stxxl::int_type cache_slot = <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[page_no];
<a name="l01505"></a>01505         <span class="keywordflow">if</span> (cache_slot &lt; 0) <span class="comment">// == on_disk</span>
<a name="l01506"></a>01506         {
<a name="l01507"></a>01507             <span class="keywordflow">if</span> (<a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.empty()) <span class="comment">// has to kick</span>
<a name="l01508"></a>01508             {
<a name="l01509"></a>01509                 stxxl::int_type kicked_slot = <a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">m_pager</a>.kick();
<a name="l01510"></a>01510                 <a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">m_pager</a>.hit(kicked_slot);
<a name="l01511"></a>01511                 stxxl::int_type old_page_no = <a class="code" href="classvector.html#a91e85df3c4867d28367bdaadc6dad0b9">m_slot_to_page</a>[kicked_slot];
<a name="l01512"></a>01512                 <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[page_no] = kicked_slot;
<a name="l01513"></a>01513                 <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[old_page_no] = <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a86d6dc0e6dae77e956822ccd989c8e75">on_disk</a>;
<a name="l01514"></a>01514                 <a class="code" href="classvector.html#a91e85df3c4867d28367bdaadc6dad0b9">m_slot_to_page</a>[kicked_slot] = page_no;
<a name="l01515"></a>01515 
<a name="l01516"></a>01516                 <a class="code" href="classvector.html#a0a454dc055a5e29480100b79a5e1b915">write_page</a>(old_page_no, kicked_slot);
<a name="l01517"></a>01517                 <a class="code" href="classvector.html#adab50b72b2e942572862afe45baf4267">read_page</a>(page_no, kicked_slot);
<a name="l01518"></a>01518 
<a name="l01519"></a>01519                 <span class="keywordflow">return</span> (*<a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a>)[kicked_slot * <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a> + offset.<a class="code" href="classdouble__blocked__index.html#aafdf535df1c21633f37dae5e67868cd4">get_block1</a>()][offset.<a class="code" href="classdouble__blocked__index.html#ab2aae63d414d2b771b3cb6fff9f279cc">get_offset</a>()];
<a name="l01520"></a>01520             } <span class="keywordflow">else</span> {
<a name="l01521"></a>01521                 stxxl::int_type free_slot = <a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.front();
<a name="l01522"></a>01522                 <a class="code" href="classvector.html#ab4e478a7df3aa77b066d2cb938badafb">m_free_slots</a>.pop();
<a name="l01523"></a>01523                 <a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">m_pager</a>.hit(free_slot);
<a name="l01524"></a>01524                 <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[page_no] = free_slot;
<a name="l01525"></a>01525                 <a class="code" href="classvector.html#a91e85df3c4867d28367bdaadc6dad0b9">m_slot_to_page</a>[free_slot] = page_no;
<a name="l01526"></a>01526 
<a name="l01527"></a>01527                 <a class="code" href="classvector.html#adab50b72b2e942572862afe45baf4267">read_page</a>(page_no, free_slot);
<a name="l01528"></a>01528 
<a name="l01529"></a>01529                 <span class="keywordflow">return</span> (*<a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a>)[free_slot * <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a> + offset.<a class="code" href="classdouble__blocked__index.html#aafdf535df1c21633f37dae5e67868cd4">get_block1</a>()][offset.<a class="code" href="classdouble__blocked__index.html#ab2aae63d414d2b771b3cb6fff9f279cc">get_offset</a>()];
<a name="l01530"></a>01530             }
<a name="l01531"></a>01531         } <span class="keywordflow">else</span> {
<a name="l01532"></a>01532             <a class="code" href="classvector.html#a4a3ad66827ee0e3aba42559e9fc62d01">m_pager</a>.hit(cache_slot);
<a name="l01533"></a>01533             <span class="keywordflow">return</span> (*<a class="code" href="classvector.html#a19fd5a714319927bc52645bf46fe99fc">m_cache</a>)[cache_slot * <a class="code" href="classvector.html#af93b7c2c989d4d4e2906bca62007a352a6ad8c95a06a2d75ee99e55efa90cec5b">page_size</a> + offset.<a class="code" href="classdouble__blocked__index.html#aafdf535df1c21633f37dae5e67868cd4">get_block1</a>()][offset.<a class="code" href="classdouble__blocked__index.html#ab2aae63d414d2b771b3cb6fff9f279cc">get_offset</a>()];
<a name="l01534"></a>01534         }
<a name="l01535"></a>01535     }
<a name="l01536"></a><a class="code" href="classvector.html#a5652c9f6cc25abf15858393bd8ff8d61">01536</a>     <span class="keywordtype">bool</span> <a class="code" href="classvector.html#a5652c9f6cc25abf15858393bd8ff8d61">is_page_cached</a>(<span class="keyword">const</span> <a class="code" href="classdouble__blocked__index.html">blocked_index_type</a>&amp; offset)<span class="keyword"> const </span>{
<a name="l01537"></a>01537         stxxl::unsigned_type page_no = offset.<a class="code" href="classdouble__blocked__index.html#a009424151b91d062eae3de2f6f2348e0">get_block2</a>();
<a name="l01538"></a>01538         assert(page_no &lt; <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>.size()); <span class="comment">// fails if offset is too large, out of bound access</span>
<a name="l01539"></a>01539         stxxl::int_type cache_slot = <a class="code" href="classvector.html#ae8591a16cb034604331430fc4e07668e">m_page_to_slot</a>[page_no];
<a name="l01540"></a>01540         <span class="keywordflow">return</span> (cache_slot &gt;= 0); <span class="comment">// on_disk == -1</span>
<a name="l01541"></a>01541     }
<a name="l01542"></a>01542 };
<a name="l01543"></a>01543 <span class="keyword">template</span> &lt;
<a name="l01544"></a>01544 <span class="keyword">typename</span> ValueType,
<a name="l01545"></a>01545 <span class="keywordtype">unsigned</span> PageSize,
<a name="l01546"></a>01546 <span class="keyword">typename</span> PagerType,
<a name="l01547"></a>01547 <span class="keywordtype">unsigned</span> BlockSize,
<a name="l01548"></a>01548 <span class="keyword">typename</span> AllocStr,
<a name="l01549"></a>01549 <span class="keyword">typename</span> SizeType&gt;
<a name="l01550"></a><a class="code" href="group__stlcont__vector.html#ga46ffdcb7d5820e4d71a8cd65a2940834">01550</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="group__stlcont__vector.html#ga46ffdcb7d5820e4d71a8cd65a2940834">operator ==</a>(stxxl::vector&lt;ValueType, PageSize, PagerType, BlockSize,
<a name="l01551"></a>01551         AllocStr, SizeType&gt;&amp; a,
<a name="l01552"></a>01552         stxxl::vector&lt;ValueType, PageSize, PagerType, BlockSize,
<a name="l01553"></a>01553         AllocStr, SizeType&gt;&amp; b) {
<a name="l01554"></a>01554     <span class="keywordflow">return</span> a.size() == b.size() &amp;&amp; std::equal(a.begin(), a.end(), b.begin());
<a name="l01555"></a>01555 }
<a name="l01556"></a>01556 <span class="keyword">template</span> &lt;
<a name="l01557"></a>01557 <span class="keyword">typename</span> ValueType,
<a name="l01558"></a>01558 <span class="keywordtype">unsigned</span> PageSize,
<a name="l01559"></a>01559 <span class="keyword">typename</span> PagerType,
<a name="l01560"></a>01560 <span class="keywordtype">unsigned</span> BlockSize,
<a name="l01561"></a>01561 <span class="keyword">typename</span> AllocStr,
<a name="l01562"></a>01562 <span class="keyword">typename</span> SizeType&gt;
<a name="l01563"></a><a class="code" href="group__stlcont__vector.html#ga0062056ae1dedc2afee535f24905cf2e">01563</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="group__stlcont__vector.html#ga0062056ae1dedc2afee535f24905cf2e">operator !=</a>(stxxl::vector&lt;ValueType, PageSize, PagerType, BlockSize,
<a name="l01564"></a>01564         AllocStr, SizeType&gt;&amp; a,
<a name="l01565"></a>01565         stxxl::vector&lt;ValueType, PageSize, PagerType, BlockSize,
<a name="l01566"></a>01566         AllocStr, SizeType&gt;&amp; b) {
<a name="l01567"></a>01567     <span class="keywordflow">return</span> !(a == b);
<a name="l01568"></a>01568 }
<a name="l01569"></a>01569 <span class="keyword">template</span> &lt;
<a name="l01570"></a>01570 <span class="keyword">typename</span> ValueType,
<a name="l01571"></a>01571 <span class="keywordtype">unsigned</span> PageSize,
<a name="l01572"></a>01572 <span class="keyword">typename</span> PagerType,
<a name="l01573"></a>01573 <span class="keywordtype">unsigned</span> BlockSize,
<a name="l01574"></a>01574 <span class="keyword">typename</span> AllocStr,
<a name="l01575"></a>01575 <span class="keyword">typename</span> SizeType&gt;
<a name="l01576"></a><a class="code" href="group__stlcont__vector.html#ga4cb86e9d068f04000829ea3bff363fb9">01576</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="group__stlcont__vector.html#ga4cb86e9d068f04000829ea3bff363fb9">operator&lt;</a>(stxxl::vector&lt;ValueType, PageSize, PagerType, BlockSize,
<a name="l01577"></a>01577         AllocStr, SizeType&gt;&amp; a,
<a name="l01578"></a>01578         stxxl::vector&lt;ValueType, PageSize, PagerType, BlockSize,
<a name="l01579"></a>01579         AllocStr, SizeType&gt;&amp; b) {
<a name="l01580"></a>01580     <span class="keywordflow">return</span> std::lexicographical_compare(a.begin(), a.end(), b.begin(), b.end());
<a name="l01581"></a>01581 }
<a name="l01582"></a>01582 <span class="keyword">template</span> &lt;
<a name="l01583"></a>01583 <span class="keyword">typename</span> ValueType,
<a name="l01584"></a>01584 <span class="keywordtype">unsigned</span> PageSize,
<a name="l01585"></a>01585 <span class="keyword">typename</span> PagerType,
<a name="l01586"></a>01586 <span class="keywordtype">unsigned</span> BlockSize,
<a name="l01587"></a>01587 <span class="keyword">typename</span> AllocStr,
<a name="l01588"></a>01588 <span class="keyword">typename</span> SizeType&gt;
<a name="l01589"></a><a class="code" href="group__stlcont__vector.html#gaf07b64de3c4c979839c2bc96a5f54c12">01589</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="group__stlcont__vector.html#gaf07b64de3c4c979839c2bc96a5f54c12">operator&gt;</a>(stxxl::vector&lt;ValueType, PageSize, PagerType, BlockSize,
<a name="l01590"></a>01590         AllocStr, SizeType&gt;&amp; a,
<a name="l01591"></a>01591         stxxl::vector&lt;ValueType, PageSize, PagerType, BlockSize,
<a name="l01592"></a>01592         AllocStr, SizeType&gt;&amp; b) {
<a name="l01593"></a>01593     <span class="keywordflow">return</span> b &lt; a;
<a name="l01594"></a>01594 }
<a name="l01595"></a>01595 <span class="keyword">template</span> &lt;
<a name="l01596"></a>01596 <span class="keyword">typename</span> ValueType,
<a name="l01597"></a>01597 <span class="keywordtype">unsigned</span> PageSize,
<a name="l01598"></a>01598 <span class="keyword">typename</span> PagerType,
<a name="l01599"></a>01599 <span class="keywordtype">unsigned</span> BlockSize,
<a name="l01600"></a>01600 <span class="keyword">typename</span> AllocStr,
<a name="l01601"></a>01601 <span class="keyword">typename</span> SizeType&gt;
<a name="l01602"></a><a class="code" href="group__stlcont__vector.html#ga8b0d1440f683a1a7d1eeae6d988b050e">01602</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="group__stlcont__vector.html#ga8b0d1440f683a1a7d1eeae6d988b050e">operator &lt;=</a>(stxxl::vector&lt;ValueType, PageSize, PagerType, BlockSize,
<a name="l01603"></a>01603         AllocStr, SizeType&gt;&amp; a,
<a name="l01604"></a>01604         stxxl::vector&lt;ValueType, PageSize, PagerType, BlockSize,
<a name="l01605"></a>01605         AllocStr, SizeType&gt;&amp; b) {
<a name="l01606"></a>01606     <span class="keywordflow">return</span> !(b &lt; a);
<a name="l01607"></a>01607 }
<a name="l01608"></a>01608 <span class="keyword">template</span> &lt;
<a name="l01609"></a>01609 <span class="keyword">typename</span> ValueType,
<a name="l01610"></a>01610 <span class="keywordtype">unsigned</span> PageSize,
<a name="l01611"></a>01611 <span class="keyword">typename</span> PagerType,
<a name="l01612"></a>01612 <span class="keywordtype">unsigned</span> BlockSize,
<a name="l01613"></a>01613 <span class="keyword">typename</span> AllocStr,
<a name="l01614"></a>01614 <span class="keyword">typename</span> SizeType&gt;
<a name="l01615"></a><a class="code" href="group__stlcont__vector.html#ga5b654f07a94bfb5b05fd50cde022c5a6">01615</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="group__stlcont__vector.html#ga5b654f07a94bfb5b05fd50cde022c5a6">operator &gt;=</a>(stxxl::vector&lt;ValueType, PageSize, PagerType, BlockSize,
<a name="l01616"></a>01616         AllocStr, SizeType&gt;&amp; a,
<a name="l01617"></a>01617         stxxl::vector&lt;ValueType, PageSize, PagerType, BlockSize,
<a name="l01618"></a>01618         AllocStr, SizeType&gt;&amp; b) {
<a name="l01619"></a>01619     <span class="keywordflow">return</span> !(a &lt; b);
<a name="l01620"></a>01620 }
<a name="l01621"></a>01621 <span class="comment"></span>
<a name="l01622"></a>01622 <span class="comment">////////////////////////////////////////////////////////////////////////////</span>
<a name="l01623"></a>01623 <span class="comment"></span>
<a name="l01624"></a>01624 <span class="comment">// specialization for stxxl::vector, to use only const_iterators</span>
<a name="l01625"></a>01625 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> AllocStr, <span class="keyword">typename</span> SizeType, <span class="keyword">typename</span> DiffType,
<a name="l01626"></a>01626 <span class="keywordtype">unsigned</span> BlockSize, <span class="keyword">typename</span> PagerType, <span class="keywordtype">unsigned</span> PageSize&gt;
<a name="l01627"></a><a class="code" href="group__stlcont__vector.html#gaf562c19f359e04af3067dc1ed1bc4e3e">01627</a> <span class="keywordtype">bool</span> <a class="code" href="group__stlcont__vector.html#gaf562c19f359e04af3067dc1ed1bc4e3e">is_sorted</a>(
<a name="l01628"></a>01628         stxxl::vector_iterator&lt;ValueType, AllocStr, SizeType, DiffType, BlockSize, PagerType, PageSize&gt; __first,
<a name="l01629"></a>01629         stxxl::vector_iterator&lt;ValueType, AllocStr, SizeType, DiffType, BlockSize, PagerType, PageSize&gt; __last) {
<a name="l01630"></a>01630     <span class="keywordflow">return</span> is_sorted_helper(
<a name="l01631"></a>01631             stxxl::const_vector_iterator&lt;ValueType, AllocStr, SizeType, DiffType, BlockSize, PagerType, PageSize&gt;(__first),
<a name="l01632"></a>01632             stxxl::const_vector_iterator&lt;ValueType, AllocStr, SizeType, DiffType, BlockSize, PagerType, PageSize&gt;(__last));
<a name="l01633"></a>01633 }
<a name="l01634"></a>01634 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> AllocStr, <span class="keyword">typename</span> SizeType, <span class="keyword">typename</span> DiffType,
<a name="l01635"></a>01635 <span class="keywordtype">unsigned</span> BlockSize, <span class="keyword">typename</span> PagerType, <span class="keywordtype">unsigned</span> PageSize, <span class="keyword">typename</span> _StrictWeakOrdering&gt;
<a name="l01636"></a><a class="code" href="group__stlcont__vector.html#ga73af64df540bbb897bd6e4eeb7c18b46">01636</a> <span class="keywordtype">bool</span> <a class="code" href="group__stlcont__vector.html#gaf562c19f359e04af3067dc1ed1bc4e3e">is_sorted</a>(
<a name="l01637"></a>01637         stxxl::vector_iterator&lt;ValueType, AllocStr, SizeType, DiffType, BlockSize, PagerType, PageSize&gt; __first,
<a name="l01638"></a>01638         stxxl::vector_iterator&lt;ValueType, AllocStr, SizeType, DiffType, BlockSize, PagerType, PageSize&gt; __last,
<a name="l01639"></a>01639         _StrictWeakOrdering __comp) {
<a name="l01640"></a>01640     <span class="keywordflow">return</span> is_sorted_helper(
<a name="l01641"></a>01641             stxxl::const_vector_iterator&lt;ValueType, AllocStr, SizeType, DiffType, BlockSize, PagerType, PageSize&gt;(__first),
<a name="l01642"></a>01642             stxxl::const_vector_iterator&lt;ValueType, AllocStr, SizeType, DiffType, BlockSize, PagerType, PageSize&gt;(__last),
<a name="l01643"></a>01643             __comp);
<a name="l01644"></a>01644 }
<a name="l01645"></a>01645 <span class="comment"></span>
<a name="l01646"></a>01646 <span class="comment">////////////////////////////////////////////////////////////////////////////</span>
<a name="l01647"></a>01647 <span class="comment"></span>
<a name="l01648"></a>01648 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorBufReaderType&gt;
<a name="l01649"></a>01649 <span class="keyword">class </span><a class="code" href="classvector__bufreader__iterator.html" title="Adapter for vector_bufreader to match iterator requirements of C++11 range-based loop construct...">vector_bufreader_iterator</a>;<span class="comment"></span>
<a name="l01650"></a>01650 <span class="comment">/*!</span>
<a name="l01651"></a>01651 <span class="comment"> * Buffered sequential reader from a vector using overlapped I/O.</span>
<a name="l01652"></a>01652 <span class="comment"> *</span>
<a name="l01653"></a>01653 <span class="comment"> * This buffered reader can be used to read a large sequential region of a</span>
<a name="l01654"></a>01654 <span class="comment"> * vector using overlapped I/O. The object is created from an iterator range,</span>
<a name="l01655"></a>01655 <span class="comment"> * which can then be read to using operator&lt;&lt;(), or with operator*() and</span>
<a name="l01656"></a>01656 <span class="comment"> * operator++().</span>
<a name="l01657"></a>01657 <span class="comment"> *</span>
<a name="l01658"></a>01658 <span class="comment"> * The interface also fulfills all requirements of a stream. Actually most of</span>
<a name="l01659"></a>01659 <span class="comment"> * the code is identical to stream::vector_iterator2stream.</span>
<a name="l01660"></a>01660 <span class="comment"> *</span>
<a name="l01661"></a>01661 <span class="comment"> * Note that this buffered reader is inefficient for reading small ranges. This</span>
<a name="l01662"></a>01662 <span class="comment"> * is intentional, as one can just use operator[] on the vector for that.</span>
<a name="l01663"></a>01663 <span class="comment"> *</span>
<a name="l01664"></a>01664 <span class="comment"> * See \ref tutorial_vector_buf</span>
<a name="l01665"></a>01665 <span class="comment"> */</span>
<a name="l01666"></a>01666 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorIterator&gt;
<a name="l01667"></a><a class="code" href="classvector__bufreader.html">01667</a> <span class="keyword">class </span><a class="code" href="classvector__bufreader.html" title="Buffered sequential reader from a vector using overlapped I/O.">vector_bufreader</a> : <span class="keyword">public</span> stxxl::noncopyable {
<a name="l01668"></a>01668 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l01669"></a>01669 <span class="comment">    //! template parameter: the vector iterator type</span>
<a name="l01670"></a><a class="code" href="classvector__bufreader.html#ab34a8b4e04a6ee16f8eabdd542783ada">01670</a> <span class="comment"></span>    <span class="keyword">typedef</span> VectorIterator <a class="code" href="classvector__bufreader.html#ab34a8b4e04a6ee16f8eabdd542783ada" title="template parameter: the vector iterator type">vector_iterator</a>;
<a name="l01671"></a>01671 <span class="comment"></span>
<a name="l01672"></a>01672 <span class="comment">    //! value type of the output vector</span>
<a name="l01673"></a><a class="code" href="classvector__bufreader.html#a3954718654b10b36e49a88a8e0bf535e">01673</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector__iterator.html#aa16ec4422db7d2291bdffc67fdec9863">vector_iterator::value_type</a> <a class="code" href="classvector__bufreader.html#a3954718654b10b36e49a88a8e0bf535e" title="value type of the output vector">value_type</a>;
<a name="l01674"></a>01674 <span class="comment"></span>
<a name="l01675"></a>01675 <span class="comment">    //! block type used in the vector</span>
<a name="l01676"></a><a class="code" href="classvector__bufreader.html#ad70c0cc4eacb81f10ea837a57d2ffd7d">01676</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector__iterator.html#aa8bad0dbea2f07e71cd709281215e692">vector_iterator::block_type</a> <a class="code" href="classvector__bufreader.html#ad70c0cc4eacb81f10ea837a57d2ffd7d" title="block type used in the vector">block_type</a>;
<a name="l01677"></a>01677 <span class="comment"></span>
<a name="l01678"></a>01678 <span class="comment">    //! type of the input vector</span>
<a name="l01679"></a><a class="code" href="classvector__bufreader.html#a009c95af47c7d4df4b0974330ee26188">01679</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector_iterator::vector_type</a> <a class="code" href="classvector__bufreader.html#a009c95af47c7d4df4b0974330ee26188" title="type of the input vector">vector_type</a>;
<a name="l01680"></a>01680 <span class="comment"></span>
<a name="l01681"></a>01681 <span class="comment">    //! block identifier iterator of the vector</span>
<a name="l01682"></a><a class="code" href="classvector__bufreader.html#a0ce669c5dc999e4032558bcf99e7a473">01682</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector__iterator.html#a340cc826e811035e2026f7ff171ebcf4">vector_iterator::bids_container_iterator</a> <a class="code" href="classvector__bufreader.html#a0ce669c5dc999e4032558bcf99e7a473" title="block identifier iterator of the vector">bids_container_iterator</a>;
<a name="l01683"></a>01683 <span class="comment"></span>
<a name="l01684"></a>01684 <span class="comment">    //! construct output buffered stream used for overlapped reading</span>
<a name="l01685"></a><a class="code" href="classvector__bufreader.html#ab664a9f0ed1ad646692454cb31180dd8">01685</a> <span class="comment"></span>    <span class="keyword">typedef</span> stxxl::buf_istream&lt;block_type, bids_container_iterator&gt; <a class="code" href="classvector__bufreader.html#ab664a9f0ed1ad646692454cb31180dd8" title="construct output buffered stream used for overlapped reading">buf_istream_type</a>;
<a name="l01686"></a>01686 <span class="comment"></span>
<a name="l01687"></a>01687 <span class="comment">    //! construct an iterator for vector_bufreader (for C++11 range-based for loop)</span>
<a name="l01688"></a><a class="code" href="classvector__bufreader.html#a768406feb43a712bd4864ffcad3e46e2">01688</a> <span class="comment"></span>    <span class="keyword">typedef</span> <a class="code" href="classvector__bufreader__iterator.html" title="Adapter for vector_bufreader to match iterator requirements of C++11 range-based loop construct...">vector_bufreader_iterator&lt;vector_bufreader&gt;</a> <a class="code" href="classvector__bufreader.html#a768406feb43a712bd4864ffcad3e46e2" title="construct an iterator for vector_bufreader (for C++11 range-based for loop)">bufreader_iterator</a>;
<a name="l01689"></a>01689 
<a name="l01690"></a>01690 <span class="keyword">protected</span>:<span class="comment"></span>
<a name="l01691"></a>01691 <span class="comment">    //! iterator to the beginning of the range.</span>
<a name="l01692"></a><a class="code" href="classvector__bufreader.html#ab0db7b6184a412da7a0df5f739c321ab">01692</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader.html#ab34a8b4e04a6ee16f8eabdd542783ada" title="template parameter: the vector iterator type">vector_iterator</a> <a class="code" href="classvector__bufreader.html#ab0db7b6184a412da7a0df5f739c321ab" title="iterator to the beginning of the range.">m_begin</a>;
<a name="l01693"></a>01693 <span class="comment"></span>
<a name="l01694"></a>01694 <span class="comment">    //! internal &quot;current&quot; iterator into the vector.</span>
<a name="l01695"></a><a class="code" href="classvector__bufreader.html#aa3e6d1542178a838e0d0670adf2f9b0c">01695</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader.html#ab34a8b4e04a6ee16f8eabdd542783ada" title="template parameter: the vector iterator type">vector_iterator</a> <a class="code" href="classvector__bufreader.html#aa3e6d1542178a838e0d0670adf2f9b0c" title="internal &quot;current&quot; iterator into the vector.">m_iter</a>;
<a name="l01696"></a>01696 <span class="comment"></span>
<a name="l01697"></a>01697 <span class="comment">    //! iterator to the end of the range.</span>
<a name="l01698"></a><a class="code" href="classvector__bufreader.html#a64c78741ba8d470e720ca235e07634a6">01698</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader.html#ab34a8b4e04a6ee16f8eabdd542783ada" title="template parameter: the vector iterator type">vector_iterator</a> <a class="code" href="classvector__bufreader.html#a64c78741ba8d470e720ca235e07634a6" title="iterator to the end of the range.">m_end</a>;
<a name="l01699"></a>01699 <span class="comment"></span>
<a name="l01700"></a>01700 <span class="comment">    //! buffered input stream used to overlapped I/O.</span>
<a name="l01701"></a><a class="code" href="classvector__bufreader.html#aee6ccd9880fe2e839ee08bd8f710bc1e">01701</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader.html#ab664a9f0ed1ad646692454cb31180dd8" title="construct output buffered stream used for overlapped reading">buf_istream_type</a>* <a class="code" href="classvector__bufreader.html#aee6ccd9880fe2e839ee08bd8f710bc1e" title="buffered input stream used to overlapped I/O.">m_bufin</a>;
<a name="l01702"></a>01702 <span class="comment"></span>
<a name="l01703"></a>01703 <span class="comment">    //! number of blocks to use as buffers.</span>
<a name="l01704"></a><a class="code" href="classvector__bufreader.html#a12ba8be7ad4b6a5fda992474d2bb99de">01704</a> <span class="comment"></span>    stxxl::unsigned_type <a class="code" href="classvector__bufreader.html#a12ba8be7ad4b6a5fda992474d2bb99de" title="number of blocks to use as buffers.">m_nbuffers</a>;
<a name="l01705"></a>01705 <span class="comment"></span>
<a name="l01706"></a>01706 <span class="comment">    //! allow vector_bufreader_iterator to check m_iter against its current value</span>
<a name="l01707"></a><a class="code" href="classvector__bufreader.html#aeaa7aa3dd279854ed15101af2397990b">01707</a> <span class="comment"></span>    <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classvector__bufreader__iterator.html" title="Adapter for vector_bufreader to match iterator requirements of C++11 range-based loop construct...">vector_bufreader_iterator</a>&lt;<a class="code" href="classvector__bufreader.html" title="Buffered sequential reader from a vector using overlapped I/O.">vector_bufreader</a>&gt;;
<a name="l01708"></a>01708 
<a name="l01709"></a>01709 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l01710"></a>01710 <span class="comment">    //! Create overlapped reader for the given iterator range.</span>
<a name="l01711"></a>01711 <span class="comment">    //! \param begin iterator to position were to start reading in vector</span>
<a name="l01712"></a>01712 <span class="comment">    //! \param end iterator to position were to end reading in vector</span>
<a name="l01713"></a>01713 <span class="comment">    //! \param nbuffers number of buffers used for overlapped I/O (&gt;= 2*D recommended)</span>
<a name="l01714"></a><a class="code" href="classvector__bufreader.html#a333e536c45b0ccec024db1fccbd27c8c">01714</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader.html#a333e536c45b0ccec024db1fccbd27c8c" title="Create overlapped reader for the given iterator range.">vector_bufreader</a>(<a class="code" href="classvector__bufreader.html#ab34a8b4e04a6ee16f8eabdd542783ada" title="template parameter: the vector iterator type">vector_iterator</a> <a class="code" href="classvector__bufreader.html#a1a200a6be8cc8c7c343001945a47d76c" title="Return vector_bufreader_iterator for C++11 range-based for loop.">begin</a>, <a class="code" href="classvector__bufreader.html#ab34a8b4e04a6ee16f8eabdd542783ada" title="template parameter: the vector iterator type">vector_iterator</a> <a class="code" href="classvector__bufreader.html#a4d675b0b7d5ab2ef45e5b4beece519f7" title="Return vector_bufreader_iterator for C++11 range-based for loop.">end</a>, stxxl::unsigned_type nbuffers = 0)
<a name="l01715"></a>01715     : <a class="code" href="classvector__bufreader.html#ab0db7b6184a412da7a0df5f739c321ab" title="iterator to the beginning of the range.">m_begin</a>(begin), <a class="code" href="classvector__bufreader.html#a64c78741ba8d470e720ca235e07634a6" title="iterator to the end of the range.">m_end</a>(end),
<a name="l01716"></a>01716     <a class="code" href="classvector__bufreader.html#aee6ccd9880fe2e839ee08bd8f710bc1e" title="buffered input stream used to overlapped I/O.">m_bufin</a>(NULL),
<a name="l01717"></a>01717     <a class="code" href="classvector__bufreader.html#a12ba8be7ad4b6a5fda992474d2bb99de" title="number of blocks to use as buffers.">m_nbuffers</a>(nbuffers) {
<a name="l01718"></a>01718         <a class="code" href="classvector__bufreader.html#ab0db7b6184a412da7a0df5f739c321ab" title="iterator to the beginning of the range.">m_begin</a>.flush(); <span class="comment">// flush container</span>
<a name="l01719"></a>01719 
<a name="l01720"></a>01720         <span class="keywordflow">if</span> (<a class="code" href="classvector__bufreader.html#a12ba8be7ad4b6a5fda992474d2bb99de" title="number of blocks to use as buffers.">m_nbuffers</a> == 0)
<a name="l01721"></a>01721             <a class="code" href="classvector__bufreader.html#a12ba8be7ad4b6a5fda992474d2bb99de" title="number of blocks to use as buffers.">m_nbuffers</a> = 2 * stxxl::config::get_instance()-&gt;disks_number();
<a name="l01722"></a>01722 
<a name="l01723"></a>01723         <a class="code" href="classvector__bufreader.html#a75f7d4dea94a713dd0c89c53a46523d5" title="Rewind stream back to begin. Note that this recreates the buffered reader and is thus not cheap...">rewind</a>();
<a name="l01724"></a>01724     }
<a name="l01725"></a>01725 <span class="comment"></span>
<a name="l01726"></a>01726 <span class="comment">    //! Create overlapped reader for the whole vector&#39;s content.</span>
<a name="l01727"></a>01727 <span class="comment">    //! \param vec vector to read</span>
<a name="l01728"></a>01728 <span class="comment">    //! \param nbuffers number of buffers used for overlapped I/O (&gt;= 2*D recommended)</span>
<a name="l01729"></a><a class="code" href="classvector__bufreader.html#a4ec68ee26c0c03dc7efe757e7d808278">01729</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader.html#a333e536c45b0ccec024db1fccbd27c8c" title="Create overlapped reader for the given iterator range.">vector_bufreader</a>(<span class="keyword">const</span> <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector_type</a>&amp; vec, stxxl::unsigned_type nbuffers = 0)
<a name="l01730"></a>01730     : <a class="code" href="classvector__bufreader.html#ab0db7b6184a412da7a0df5f739c321ab" title="iterator to the beginning of the range.">m_begin</a>(vec.<a class="code" href="classvector__bufreader.html#a1a200a6be8cc8c7c343001945a47d76c" title="Return vector_bufreader_iterator for C++11 range-based for loop.">begin</a>()), <a class="code" href="classvector__bufreader.html#a64c78741ba8d470e720ca235e07634a6" title="iterator to the end of the range.">m_end</a>(vec.<a class="code" href="classvector__bufreader.html#a4d675b0b7d5ab2ef45e5b4beece519f7" title="Return vector_bufreader_iterator for C++11 range-based for loop.">end</a>()),
<a name="l01731"></a>01731     <a class="code" href="classvector__bufreader.html#aee6ccd9880fe2e839ee08bd8f710bc1e" title="buffered input stream used to overlapped I/O.">m_bufin</a>(NULL),
<a name="l01732"></a>01732     <a class="code" href="classvector__bufreader.html#a12ba8be7ad4b6a5fda992474d2bb99de" title="number of blocks to use as buffers.">m_nbuffers</a>(nbuffers) {
<a name="l01733"></a>01733         <a class="code" href="classvector__bufreader.html#ab0db7b6184a412da7a0df5f739c321ab" title="iterator to the beginning of the range.">m_begin</a>.flush(); <span class="comment">// flush container</span>
<a name="l01734"></a>01734 
<a name="l01735"></a>01735         <span class="keywordflow">if</span> (<a class="code" href="classvector__bufreader.html#a12ba8be7ad4b6a5fda992474d2bb99de" title="number of blocks to use as buffers.">m_nbuffers</a> == 0)
<a name="l01736"></a>01736             <a class="code" href="classvector__bufreader.html#a12ba8be7ad4b6a5fda992474d2bb99de" title="number of blocks to use as buffers.">m_nbuffers</a> = 2 * stxxl::config::get_instance()-&gt;disks_number();
<a name="l01737"></a>01737 
<a name="l01738"></a>01738         <a class="code" href="classvector__bufreader.html#a75f7d4dea94a713dd0c89c53a46523d5" title="Rewind stream back to begin. Note that this recreates the buffered reader and is thus not cheap...">rewind</a>();
<a name="l01739"></a>01739     }
<a name="l01740"></a>01740 <span class="comment"></span>
<a name="l01741"></a>01741 <span class="comment">    //! Rewind stream back to begin. Note that this recreates the buffered</span>
<a name="l01742"></a>01742 <span class="comment">    //! reader and is thus not cheap.</span>
<a name="l01743"></a><a class="code" href="classvector__bufreader.html#a75f7d4dea94a713dd0c89c53a46523d5">01743</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector__bufreader.html#a75f7d4dea94a713dd0c89c53a46523d5" title="Rewind stream back to begin. Note that this recreates the buffered reader and is thus not cheap...">rewind</a>() {
<a name="l01744"></a>01744         <a class="code" href="classvector__bufreader.html#aa3e6d1542178a838e0d0670adf2f9b0c" title="internal &quot;current&quot; iterator into the vector.">m_iter</a> = <a class="code" href="classvector__bufreader.html#ab0db7b6184a412da7a0df5f739c321ab" title="iterator to the beginning of the range.">m_begin</a>;
<a name="l01745"></a>01745         <span class="keywordflow">if</span> (<a class="code" href="classvector__bufreader.html#a100cbefb8d82116f38ca281bbd98952d" title="Returns true once the whole range has been read.">empty</a>()) <span class="keywordflow">return</span>;
<a name="l01746"></a>01746 
<a name="l01747"></a>01747         <span class="keywordflow">if</span> (<a class="code" href="classvector__bufreader.html#aee6ccd9880fe2e839ee08bd8f710bc1e" title="buffered input stream used to overlapped I/O.">m_bufin</a>) <span class="keyword">delete</span> <a class="code" href="classvector__bufreader.html#aee6ccd9880fe2e839ee08bd8f710bc1e" title="buffered input stream used to overlapped I/O.">m_bufin</a>;
<a name="l01748"></a>01748 
<a name="l01749"></a>01749         <span class="comment">// find last bid to read</span>
<a name="l01750"></a>01750         <a class="code" href="classvector__bufreader.html#a0ce669c5dc999e4032558bcf99e7a473" title="block identifier iterator of the vector">bids_container_iterator</a> end_bid = <a class="code" href="classvector__bufreader.html#a64c78741ba8d470e720ca235e07634a6" title="iterator to the end of the range.">m_end</a>.bid() + (<a class="code" href="classvector__bufreader.html#a64c78741ba8d470e720ca235e07634a6" title="iterator to the end of the range.">m_end</a>.block_offset() ? 1 : 0);
<a name="l01751"></a>01751 
<a name="l01752"></a>01752         <span class="comment">// construct buffered istream for range</span>
<a name="l01753"></a>01753         <a class="code" href="classvector__bufreader.html#aee6ccd9880fe2e839ee08bd8f710bc1e" title="buffered input stream used to overlapped I/O.">m_bufin</a> = <span class="keyword">new</span> <a class="code" href="classvector__bufreader.html#ab664a9f0ed1ad646692454cb31180dd8" title="construct output buffered stream used for overlapped reading">buf_istream_type</a>(<a class="code" href="classvector__bufreader.html#ab0db7b6184a412da7a0df5f739c321ab" title="iterator to the beginning of the range.">m_begin</a>.bid(), end_bid, <a class="code" href="classvector__bufreader.html#a12ba8be7ad4b6a5fda992474d2bb99de" title="number of blocks to use as buffers.">m_nbuffers</a>);
<a name="l01754"></a>01754 
<a name="l01755"></a>01755         <span class="comment">// skip the beginning of the block, up to real beginning</span>
<a name="l01756"></a>01756         <a class="code" href="classvector__bufreader.html#ab34a8b4e04a6ee16f8eabdd542783ada" title="template parameter: the vector iterator type">vector_iterator</a> curr = <a class="code" href="classvector__bufreader.html#ab0db7b6184a412da7a0df5f739c321ab" title="iterator to the beginning of the range.">m_begin</a> - <a class="code" href="classvector__bufreader.html#ab0db7b6184a412da7a0df5f739c321ab" title="iterator to the beginning of the range.">m_begin</a>.block_offset();
<a name="l01757"></a>01757 
<a name="l01758"></a>01758         <span class="keywordflow">for</span> (; curr != <a class="code" href="classvector__bufreader.html#ab0db7b6184a412da7a0df5f739c321ab" title="iterator to the beginning of the range.">m_begin</a>; ++curr)
<a name="l01759"></a>01759             ++(*<a class="code" href="classvector__bufreader.html#aee6ccd9880fe2e839ee08bd8f710bc1e" title="buffered input stream used to overlapped I/O.">m_bufin</a>);
<a name="l01760"></a>01760     }
<a name="l01761"></a>01761 <span class="comment"></span>
<a name="l01762"></a>01762 <span class="comment">    //! Finish reading and free buffered reader.</span>
<a name="l01763"></a><a class="code" href="classvector__bufreader.html#a50a3daba2b556985ec267e5784b5174d">01763</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader.html#a50a3daba2b556985ec267e5784b5174d" title="Finish reading and free buffered reader.">~vector_bufreader</a>() {
<a name="l01764"></a>01764         <span class="keywordflow">if</span> (<a class="code" href="classvector__bufreader.html#aee6ccd9880fe2e839ee08bd8f710bc1e" title="buffered input stream used to overlapped I/O.">m_bufin</a>) <span class="keyword">delete</span> <a class="code" href="classvector__bufreader.html#aee6ccd9880fe2e839ee08bd8f710bc1e" title="buffered input stream used to overlapped I/O.">m_bufin</a>;
<a name="l01765"></a>01765     }
<a name="l01766"></a>01766 <span class="comment"></span>
<a name="l01767"></a>01767 <span class="comment">    //! Return constant reference to current item</span>
<a name="l01768"></a><a class="code" href="classvector__bufreader.html#adbe33f1817f43456e5d334fafd0261e8">01768</a> <span class="comment"></span>    <span class="keyword">const</span> <a class="code" href="classvector__bufreader.html#a3954718654b10b36e49a88a8e0bf535e" title="value type of the output vector">value_type</a>&amp; <a class="code" href="classvector__bufreader.html#adbe33f1817f43456e5d334fafd0261e8" title="Return constant reference to current item.">operator *</a>()<span class="keyword"> const </span>{
<a name="l01769"></a>01769         <span class="keywordflow">return</span> *(*m_bufin);
<a name="l01770"></a>01770     }
<a name="l01771"></a>01771 <span class="comment"></span>
<a name="l01772"></a>01772 <span class="comment">    //! Return constant pointer to current item</span>
<a name="l01773"></a><a class="code" href="classvector__bufreader.html#a6572b8d365f73ce4661e82dc84d38b80">01773</a> <span class="comment"></span>    <span class="keyword">const</span> <a class="code" href="classvector__bufreader.html#a3954718654b10b36e49a88a8e0bf535e" title="value type of the output vector">value_type</a>* <a class="code" href="classvector__bufreader.html#a6572b8d365f73ce4661e82dc84d38b80" title="Return constant pointer to current item.">operator -&gt; </a>()<span class="keyword"> const </span>{
<a name="l01774"></a>01774         <span class="keywordflow">return</span> &amp;(*(*m_bufin));
<a name="l01775"></a>01775     }
<a name="l01776"></a>01776 <span class="comment"></span>
<a name="l01777"></a>01777 <span class="comment">    //! Advance to next item (asserts if !empty()).</span>
<a name="l01778"></a><a class="code" href="classvector__bufreader.html#ac530b72bea7a2fd6d815b382384265c2">01778</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader.html" title="Buffered sequential reader from a vector using overlapped I/O.">vector_bufreader</a>&amp; <a class="code" href="classvector__bufreader.html#ac530b72bea7a2fd6d815b382384265c2" title="Advance to next item (asserts if !empty()).">operator ++</a>() {
<a name="l01779"></a>01779         assert(!<a class="code" href="classvector__bufreader.html#a100cbefb8d82116f38ca281bbd98952d" title="Returns true once the whole range has been read.">empty</a>());
<a name="l01780"></a>01780         ++<a class="code" href="classvector__bufreader.html#aa3e6d1542178a838e0d0670adf2f9b0c" title="internal &quot;current&quot; iterator into the vector.">m_iter</a>;
<a name="l01781"></a>01781         ++(*m_bufin);
<a name="l01782"></a>01782 
<a name="l01783"></a>01783         <span class="keywordflow">if</span> (UNLIKELY(<a class="code" href="classvector__bufreader.html#a100cbefb8d82116f38ca281bbd98952d" title="Returns true once the whole range has been read.">empty</a>())) {
<a name="l01784"></a>01784             <span class="keyword">delete</span> <a class="code" href="classvector__bufreader.html#aee6ccd9880fe2e839ee08bd8f710bc1e" title="buffered input stream used to overlapped I/O.">m_bufin</a>;
<a name="l01785"></a>01785             <a class="code" href="classvector__bufreader.html#aee6ccd9880fe2e839ee08bd8f710bc1e" title="buffered input stream used to overlapped I/O.">m_bufin</a> = NULL;
<a name="l01786"></a>01786         }
<a name="l01787"></a>01787 
<a name="l01788"></a>01788         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01789"></a>01789     }
<a name="l01790"></a>01790 <span class="comment"></span>
<a name="l01791"></a>01791 <span class="comment">    //! Read current item into variable and advance to next one.</span>
<a name="l01792"></a><a class="code" href="classvector__bufreader.html#ab673a8fb6af5ad7c167c7dd6b8837cbb">01792</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader.html" title="Buffered sequential reader from a vector using overlapped I/O.">vector_bufreader</a>&amp; <a class="code" href="classvector__bufreader.html#ab673a8fb6af5ad7c167c7dd6b8837cbb" title="Read current item into variable and advance to next one.">operator &gt;&gt;</a>(<a class="code" href="classvector__bufreader.html#a3954718654b10b36e49a88a8e0bf535e" title="value type of the output vector">value_type</a>&amp; v) {
<a name="l01793"></a>01793         v = <a class="code" href="classvector__bufreader.html#adbe33f1817f43456e5d334fafd0261e8" title="Return constant reference to current item.">operator *</a>();
<a name="l01794"></a>01794         <a class="code" href="classvector__bufreader.html#ac530b72bea7a2fd6d815b382384265c2" title="Advance to next item (asserts if !empty()).">operator ++</a>();
<a name="l01795"></a>01795 
<a name="l01796"></a>01796         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01797"></a>01797     }
<a name="l01798"></a>01798 <span class="comment"></span>
<a name="l01799"></a>01799 <span class="comment">    //! Return remaining size.</span>
<a name="l01800"></a><a class="code" href="classvector__bufreader.html#ac93a4b807e0a8934a41e48ece8f723e6">01800</a> <span class="comment"></span>    <span class="keywordtype">size_t</span> <a class="code" href="classvector__bufreader.html#ac93a4b807e0a8934a41e48ece8f723e6" title="Return remaining size.">size</a>()<span class="keyword"> const </span>{
<a name="l01801"></a>01801         assert(<a class="code" href="classvector__bufreader.html#ab0db7b6184a412da7a0df5f739c321ab" title="iterator to the beginning of the range.">m_begin</a> &lt;= <a class="code" href="classvector__bufreader.html#aa3e6d1542178a838e0d0670adf2f9b0c" title="internal &quot;current&quot; iterator into the vector.">m_iter</a> &amp;&amp; <a class="code" href="classvector__bufreader.html#aa3e6d1542178a838e0d0670adf2f9b0c" title="internal &quot;current&quot; iterator into the vector.">m_iter</a> &lt;= <a class="code" href="classvector__bufreader.html#a64c78741ba8d470e720ca235e07634a6" title="iterator to the end of the range.">m_end</a>);
<a name="l01802"></a>01802         <span class="keywordflow">return</span> (<a class="code" href="classvector__bufreader.html#a64c78741ba8d470e720ca235e07634a6" title="iterator to the end of the range.">m_end</a> - <a class="code" href="classvector__bufreader.html#aa3e6d1542178a838e0d0670adf2f9b0c" title="internal &quot;current&quot; iterator into the vector.">m_iter</a>);
<a name="l01803"></a>01803     }
<a name="l01804"></a>01804 <span class="comment"></span>
<a name="l01805"></a>01805 <span class="comment">    //! Returns true once the whole range has been read.</span>
<a name="l01806"></a><a class="code" href="classvector__bufreader.html#a100cbefb8d82116f38ca281bbd98952d">01806</a> <span class="comment"></span>    <span class="keywordtype">bool</span> <a class="code" href="classvector__bufreader.html#a100cbefb8d82116f38ca281bbd98952d" title="Returns true once the whole range has been read.">empty</a>()<span class="keyword"> const </span>{
<a name="l01807"></a>01807         <span class="keywordflow">return</span> (<a class="code" href="classvector__bufreader.html#aa3e6d1542178a838e0d0670adf2f9b0c" title="internal &quot;current&quot; iterator into the vector.">m_iter</a> == <a class="code" href="classvector__bufreader.html#a64c78741ba8d470e720ca235e07634a6" title="iterator to the end of the range.">m_end</a>);
<a name="l01808"></a>01808     }
<a name="l01809"></a>01809 <span class="comment"></span>
<a name="l01810"></a>01810 <span class="comment">    //! Return vector_bufreader_iterator for C++11 range-based for loop</span>
<a name="l01811"></a><a class="code" href="classvector__bufreader.html#a1a200a6be8cc8c7c343001945a47d76c">01811</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader__iterator.html" title="Adapter for vector_bufreader to match iterator requirements of C++11 range-based loop construct...">bufreader_iterator</a> <a class="code" href="classvector__bufreader.html#a1a200a6be8cc8c7c343001945a47d76c" title="Return vector_bufreader_iterator for C++11 range-based for loop.">begin</a>() {
<a name="l01812"></a>01812         <span class="keywordflow">return</span> <a class="code" href="classvector__bufreader.html#a768406feb43a712bd4864ffcad3e46e2" title="construct an iterator for vector_bufreader (for C++11 range-based for loop)">bufreader_iterator</a>(*<span class="keyword">this</span>, <a class="code" href="classvector__bufreader.html#ab0db7b6184a412da7a0df5f739c321ab" title="iterator to the beginning of the range.">m_begin</a>);
<a name="l01813"></a>01813     }
<a name="l01814"></a>01814 <span class="comment"></span>
<a name="l01815"></a>01815 <span class="comment">    //! Return vector_bufreader_iterator for C++11 range-based for loop</span>
<a name="l01816"></a><a class="code" href="classvector__bufreader.html#a4d675b0b7d5ab2ef45e5b4beece519f7">01816</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader__iterator.html" title="Adapter for vector_bufreader to match iterator requirements of C++11 range-based loop construct...">bufreader_iterator</a> <a class="code" href="classvector__bufreader.html#a4d675b0b7d5ab2ef45e5b4beece519f7" title="Return vector_bufreader_iterator for C++11 range-based for loop.">end</a>() {
<a name="l01817"></a>01817         <span class="keywordflow">return</span> <a class="code" href="classvector__bufreader.html#a768406feb43a712bd4864ffcad3e46e2" title="construct an iterator for vector_bufreader (for C++11 range-based for loop)">bufreader_iterator</a>(*<span class="keyword">this</span>, <a class="code" href="classvector__bufreader.html#a64c78741ba8d470e720ca235e07634a6" title="iterator to the end of the range.">m_end</a>);
<a name="l01818"></a>01818     }
<a name="l01819"></a>01819 };
<a name="l01820"></a>01820 <span class="comment"></span>
<a name="l01821"></a>01821 <span class="comment">////////////////////////////////////////////////////////////////////////////</span>
<a name="l01822"></a>01822 <span class="comment"></span><span class="comment">/*!</span>
<a name="l01823"></a>01823 <span class="comment"> * Adapter for vector_bufreader to match iterator requirements of C++11</span>
<a name="l01824"></a>01824 <span class="comment"> * range-based loop construct.</span>
<a name="l01825"></a>01825 <span class="comment"> *</span>
<a name="l01826"></a>01826 <span class="comment"> * Since vector_bufreader itself points to only one specific item, this</span>
<a name="l01827"></a>01827 <span class="comment"> * iterator is merely a counter facade. The functions operator*() and</span>
<a name="l01828"></a>01828 <span class="comment"> * operator++() must only be called when it is in _sync_ with the bufreader</span>
<a name="l01829"></a>01829 <span class="comment"> * object. This is generally only the case for an iterator constructed with</span>
<a name="l01830"></a>01830 <span class="comment"> * begin() and then advanced with operator++(). The class checks this using</span>
<a name="l01831"></a>01831 <span class="comment"> * asserts(), the operators will fail if used wrong.</span>
<a name="l01832"></a>01832 <span class="comment"> *</span>
<a name="l01833"></a>01833 <span class="comment"> * See \ref tutorial_vector_buf</span>
<a name="l01834"></a>01834 <span class="comment"> */</span>
<a name="l01835"></a>01835 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorBufReaderType&gt;
<a name="l01836"></a><a class="code" href="classvector__bufreader__iterator.html">01836</a> <span class="keyword">class </span><a class="code" href="classvector__bufreader__iterator.html" title="Adapter for vector_bufreader to match iterator requirements of C++11 range-based loop construct...">vector_bufreader_iterator</a> {
<a name="l01837"></a>01837 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l01838"></a>01838 <span class="comment">    //! The underlying buffered reader type</span>
<a name="l01839"></a><a class="code" href="classvector__bufreader__iterator.html#ad5632022994e44ecaebc0c36f1b9134d">01839</a> <span class="comment"></span>    <span class="keyword">typedef</span> VectorBufReaderType <a class="code" href="classvector__bufreader__iterator.html#ad5632022994e44ecaebc0c36f1b9134d" title="The underlying buffered reader type.">vector_bufreader_type</a>;
<a name="l01840"></a>01840 <span class="comment"></span>
<a name="l01841"></a>01841 <span class="comment">    //! Value type of vector</span>
<a name="l01842"></a><a class="code" href="classvector__bufreader__iterator.html#aa719d8e379443ee40461b3d5a411f35e">01842</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_bufreader_type::value_type <a class="code" href="classvector__bufreader__iterator.html#aa719d8e379443ee40461b3d5a411f35e" title="Value type of vector.">value_type</a>;
<a name="l01843"></a>01843 <span class="comment"></span>
<a name="l01844"></a>01844 <span class="comment">    //! Use vector_iterator to reference a point in the vector.</span>
<a name="l01845"></a><a class="code" href="classvector__bufreader__iterator.html#ad8fba7b58089565f7d0d17ecf371eb0b">01845</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_bufreader_type::vector_iterator <a class="code" href="classvector__bufreader__iterator.html#ad8fba7b58089565f7d0d17ecf371eb0b" title="Use vector_iterator to reference a point in the vector.">vector_iterator</a>;
<a name="l01846"></a>01846 
<a name="l01847"></a>01847 <span class="keyword">protected</span>:<span class="comment"></span>
<a name="l01848"></a>01848 <span class="comment">    //! Buffered reader used to access elements in vector</span>
<a name="l01849"></a><a class="code" href="classvector__bufreader__iterator.html#a8753bdadd41e326fb00e25d50243e26c">01849</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader__iterator.html#ad5632022994e44ecaebc0c36f1b9134d" title="The underlying buffered reader type.">vector_bufreader_type</a>&amp; <a class="code" href="classvector__bufreader__iterator.html#a8753bdadd41e326fb00e25d50243e26c" title="Buffered reader used to access elements in vector.">m_bufreader</a>;
<a name="l01850"></a>01850 <span class="comment"></span>
<a name="l01851"></a>01851 <span class="comment">    //! Use vector_iterator to reference a point in the vector.</span>
<a name="l01852"></a><a class="code" href="classvector__bufreader__iterator.html#a2512da7acbbb0a43c1f3f92fbe52718f">01852</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader__iterator.html#ad8fba7b58089565f7d0d17ecf371eb0b" title="Use vector_iterator to reference a point in the vector.">vector_iterator</a> <a class="code" href="classvector__bufreader__iterator.html#a2512da7acbbb0a43c1f3f92fbe52718f" title="Use vector_iterator to reference a point in the vector.">m_iter</a>;
<a name="l01853"></a>01853 
<a name="l01854"></a>01854 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l01855"></a>01855 <span class="comment">    //! Construct iterator using vector_iterator</span>
<a name="l01856"></a><a class="code" href="classvector__bufreader__iterator.html#a92578a7d685b7612a32f833be5406db8">01856</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader__iterator.html#a92578a7d685b7612a32f833be5406db8" title="Construct iterator using vector_iterator.">vector_bufreader_iterator</a>(<a class="code" href="classvector__bufreader__iterator.html#ad5632022994e44ecaebc0c36f1b9134d" title="The underlying buffered reader type.">vector_bufreader_type</a>&amp; bufreader, <span class="keyword">const</span> <a class="code" href="classvector__bufreader__iterator.html#ad8fba7b58089565f7d0d17ecf371eb0b" title="Use vector_iterator to reference a point in the vector.">vector_iterator</a>&amp; iter)
<a name="l01857"></a>01857     : <a class="code" href="classvector__bufreader__iterator.html#a8753bdadd41e326fb00e25d50243e26c" title="Buffered reader used to access elements in vector.">m_bufreader</a>(bufreader), <a class="code" href="classvector__bufreader__iterator.html#a2512da7acbbb0a43c1f3f92fbe52718f" title="Use vector_iterator to reference a point in the vector.">m_iter</a>(iter) {
<a name="l01858"></a>01858     }
<a name="l01859"></a>01859 <span class="comment"></span>
<a name="l01860"></a>01860 <span class="comment">    //! Return constant reference to current item</span>
<a name="l01861"></a><a class="code" href="classvector__bufreader__iterator.html#a39b560d5f575a219390d2d15af3e3dcb">01861</a> <span class="comment"></span>    <span class="keyword">const</span> <a class="code" href="classvector__bufreader__iterator.html#aa719d8e379443ee40461b3d5a411f35e" title="Value type of vector.">value_type</a>&amp; <a class="code" href="classvector__bufreader__iterator.html#a39b560d5f575a219390d2d15af3e3dcb" title="Return constant reference to current item.">operator *</a>()<span class="keyword"> const </span>{
<a name="l01862"></a>01862         assert(<a class="code" href="classvector__bufreader__iterator.html#a8753bdadd41e326fb00e25d50243e26c" title="Buffered reader used to access elements in vector.">m_bufreader</a>.m_iter == <a class="code" href="classvector__bufreader__iterator.html#a2512da7acbbb0a43c1f3f92fbe52718f" title="Use vector_iterator to reference a point in the vector.">m_iter</a>);
<a name="l01863"></a>01863         <span class="keywordflow">return</span> <a class="code" href="classvector__bufreader__iterator.html#a8753bdadd41e326fb00e25d50243e26c" title="Buffered reader used to access elements in vector.">m_bufreader</a>.operator *();
<a name="l01864"></a>01864     }
<a name="l01865"></a>01865 <span class="comment"></span>
<a name="l01866"></a>01866 <span class="comment">    //! Return constant pointer to current item</span>
<a name="l01867"></a><a class="code" href="classvector__bufreader__iterator.html#a26b51e4655a8368f4f14ac68815225c0">01867</a> <span class="comment"></span>    <span class="keyword">const</span> <a class="code" href="classvector__bufreader__iterator.html#aa719d8e379443ee40461b3d5a411f35e" title="Value type of vector.">value_type</a>* <a class="code" href="classvector__bufreader__iterator.html#a26b51e4655a8368f4f14ac68815225c0" title="Return constant pointer to current item.">operator -&gt; </a>()<span class="keyword"> const </span>{
<a name="l01868"></a>01868         assert(<a class="code" href="classvector__bufreader__iterator.html#a8753bdadd41e326fb00e25d50243e26c" title="Buffered reader used to access elements in vector.">m_bufreader</a>.m_iter == <a class="code" href="classvector__bufreader__iterator.html#a2512da7acbbb0a43c1f3f92fbe52718f" title="Use vector_iterator to reference a point in the vector.">m_iter</a>);
<a name="l01869"></a>01869         <span class="keywordflow">return</span> <a class="code" href="classvector__bufreader__iterator.html#a8753bdadd41e326fb00e25d50243e26c" title="Buffered reader used to access elements in vector.">m_bufreader</a>.operator -&gt; ();
<a name="l01870"></a>01870     }
<a name="l01871"></a>01871 <span class="comment"></span>
<a name="l01872"></a>01872 <span class="comment">    //! Make bufreader advance to next item (asserts if !empty() or if iterator</span>
<a name="l01873"></a>01873 <span class="comment">    //! does not point to current).</span>
<a name="l01874"></a><a class="code" href="classvector__bufreader__iterator.html#ab129cbe055a5201cb4ef4d791959a72a">01874</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader__iterator.html" title="Adapter for vector_bufreader to match iterator requirements of C++11 range-based loop construct...">vector_bufreader_iterator</a>&amp; <a class="code" href="classvector__bufreader__iterator.html#ab129cbe055a5201cb4ef4d791959a72a" title="Make bufreader advance to next item (asserts if !empty() or if iterator does not point to current)...">operator ++</a>() {
<a name="l01875"></a>01875         assert(<a class="code" href="classvector__bufreader__iterator.html#a8753bdadd41e326fb00e25d50243e26c" title="Buffered reader used to access elements in vector.">m_bufreader</a>.m_iter == <a class="code" href="classvector__bufreader__iterator.html#a2512da7acbbb0a43c1f3f92fbe52718f" title="Use vector_iterator to reference a point in the vector.">m_iter</a>);
<a name="l01876"></a>01876         <a class="code" href="classvector__bufreader__iterator.html#a8753bdadd41e326fb00e25d50243e26c" title="Buffered reader used to access elements in vector.">m_bufreader</a>.operator ++();
<a name="l01877"></a>01877         <a class="code" href="classvector__bufreader__iterator.html#a2512da7acbbb0a43c1f3f92fbe52718f" title="Use vector_iterator to reference a point in the vector.">m_iter</a>++;
<a name="l01878"></a>01878         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01879"></a>01879     }
<a name="l01880"></a>01880 <span class="comment"></span>
<a name="l01881"></a>01881 <span class="comment">    //! Equality comparison operator</span>
<a name="l01882"></a><a class="code" href="classvector__bufreader__iterator.html#ac9c54ad32bc4363eb814a8c1f7da55c3">01882</a> <span class="comment"></span>    <span class="keywordtype">bool</span> <a class="code" href="classvector__bufreader__iterator.html#ac9c54ad32bc4363eb814a8c1f7da55c3" title="Equality comparison operator.">operator ==</a>(<span class="keyword">const</span> <a class="code" href="classvector__bufreader__iterator.html" title="Adapter for vector_bufreader to match iterator requirements of C++11 range-based loop construct...">vector_bufreader_iterator</a>&amp; vbi)<span class="keyword"> const </span>{
<a name="l01883"></a>01883         assert(&amp;<a class="code" href="classvector__bufreader__iterator.html#a8753bdadd41e326fb00e25d50243e26c" title="Buffered reader used to access elements in vector.">m_bufreader</a> == &amp;vbi.<a class="code" href="classvector__bufreader__iterator.html#a8753bdadd41e326fb00e25d50243e26c" title="Buffered reader used to access elements in vector.">m_bufreader</a>);
<a name="l01884"></a>01884         <span class="keywordflow">return</span> (<a class="code" href="classvector__bufreader__iterator.html#a2512da7acbbb0a43c1f3f92fbe52718f" title="Use vector_iterator to reference a point in the vector.">m_iter</a> == vbi.<a class="code" href="classvector__bufreader__iterator.html#a2512da7acbbb0a43c1f3f92fbe52718f" title="Use vector_iterator to reference a point in the vector.">m_iter</a>);
<a name="l01885"></a>01885     }
<a name="l01886"></a>01886 <span class="comment"></span>
<a name="l01887"></a>01887 <span class="comment">    //! Inequality comparison operator</span>
<a name="l01888"></a><a class="code" href="classvector__bufreader__iterator.html#af04de3ca8c2e77e24862c05c12f72f5f">01888</a> <span class="comment"></span>    <span class="keywordtype">bool</span> <a class="code" href="classvector__bufreader__iterator.html#af04de3ca8c2e77e24862c05c12f72f5f" title="Inequality comparison operator.">operator !=</a>(<span class="keyword">const</span> <a class="code" href="classvector__bufreader__iterator.html" title="Adapter for vector_bufreader to match iterator requirements of C++11 range-based loop construct...">vector_bufreader_iterator</a>&amp; vbi)<span class="keyword"> const </span>{
<a name="l01889"></a>01889         assert(&amp;<a class="code" href="classvector__bufreader__iterator.html#a8753bdadd41e326fb00e25d50243e26c" title="Buffered reader used to access elements in vector.">m_bufreader</a> == &amp;vbi.<a class="code" href="classvector__bufreader__iterator.html#a8753bdadd41e326fb00e25d50243e26c" title="Buffered reader used to access elements in vector.">m_bufreader</a>);
<a name="l01890"></a>01890         <span class="keywordflow">return</span> (<a class="code" href="classvector__bufreader__iterator.html#a2512da7acbbb0a43c1f3f92fbe52718f" title="Use vector_iterator to reference a point in the vector.">m_iter</a> != vbi.<a class="code" href="classvector__bufreader__iterator.html#a2512da7acbbb0a43c1f3f92fbe52718f" title="Use vector_iterator to reference a point in the vector.">m_iter</a>);
<a name="l01891"></a>01891     }
<a name="l01892"></a>01892 };
<a name="l01893"></a>01893 <span class="comment"></span>
<a name="l01894"></a>01894 <span class="comment">////////////////////////////////////////////////////////////////////////////</span>
<a name="l01895"></a>01895 <span class="comment"></span><span class="comment">/*!</span>
<a name="l01896"></a>01896 <span class="comment"> * Buffered sequential reverse reader from a vector using overlapped I/O.</span>
<a name="l01897"></a>01897 <span class="comment"> *</span>
<a name="l01898"></a>01898 <span class="comment"> * This buffered reader can be used to read a large sequential region of a</span>
<a name="l01899"></a>01899 <span class="comment"> * vector _in_reverse_ using overlapped I/O. The object is created from an</span>
<a name="l01900"></a>01900 <span class="comment"> * iterator range, which can then be read to using operator&lt;&lt;(), or with</span>
<a name="l01901"></a>01901 <span class="comment"> * operator*() and operator++(), where ++ actually goes to the preceding</span>
<a name="l01902"></a>01902 <span class="comment"> * element.</span>
<a name="l01903"></a>01903 <span class="comment"> *</span>
<a name="l01904"></a>01904 <span class="comment"> * The interface also fulfills all requirements of a stream. Actually most of</span>
<a name="l01905"></a>01905 <span class="comment"> * the code is identical to stream::vector_iterator2stream.</span>
<a name="l01906"></a>01906 <span class="comment"> *</span>
<a name="l01907"></a>01907 <span class="comment"> * Note that this buffered reader is inefficient for reading small ranges. This</span>
<a name="l01908"></a>01908 <span class="comment"> * is intentional, as one can just use operator[] on the vector for that.</span>
<a name="l01909"></a>01909 <span class="comment"> *</span>
<a name="l01910"></a>01910 <span class="comment"> * See \ref tutorial_vector_buf</span>
<a name="l01911"></a>01911 <span class="comment"> */</span>
<a name="l01912"></a>01912 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorIterator&gt;
<a name="l01913"></a><a class="code" href="classvector__bufreader__reverse.html">01913</a> <span class="keyword">class </span><a class="code" href="classvector__bufreader__reverse.html" title="Buffered sequential reverse reader from a vector using overlapped I/O.">vector_bufreader_reverse</a> : <span class="keyword">public</span> stxxl::noncopyable {
<a name="l01914"></a>01914 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l01915"></a>01915 <span class="comment">    //! template parameter: the vector iterator type</span>
<a name="l01916"></a><a class="code" href="classvector__bufreader__reverse.html#a32ab1fa102c57d0728864d03e02b58c1">01916</a> <span class="comment"></span>    <span class="keyword">typedef</span> VectorIterator <a class="code" href="classvector__bufreader__reverse.html#a32ab1fa102c57d0728864d03e02b58c1" title="template parameter: the vector iterator type">vector_iterator</a>;
<a name="l01917"></a>01917 <span class="comment"></span>
<a name="l01918"></a>01918 <span class="comment">    //! value type of the output vector</span>
<a name="l01919"></a><a class="code" href="classvector__bufreader__reverse.html#a35a0594d7204d80bd6a61ccf1d9ee9a9">01919</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector__iterator.html#aa16ec4422db7d2291bdffc67fdec9863">vector_iterator::value_type</a> <a class="code" href="classvector__bufreader__reverse.html#a35a0594d7204d80bd6a61ccf1d9ee9a9" title="value type of the output vector">value_type</a>;
<a name="l01920"></a>01920 <span class="comment"></span>
<a name="l01921"></a>01921 <span class="comment">    //! block type used in the vector</span>
<a name="l01922"></a><a class="code" href="classvector__bufreader__reverse.html#a35618047f43c396f21016d2609b1e7ca">01922</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector__iterator.html#aa8bad0dbea2f07e71cd709281215e692">vector_iterator::block_type</a> <a class="code" href="classvector__bufreader__reverse.html#a35618047f43c396f21016d2609b1e7ca" title="block type used in the vector">block_type</a>;
<a name="l01923"></a>01923 <span class="comment"></span>
<a name="l01924"></a>01924 <span class="comment">    //! type of the input vector</span>
<a name="l01925"></a><a class="code" href="classvector__bufreader__reverse.html#ab236383c7a0434a1c616c16a4f334902">01925</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector_iterator::vector_type</a> <a class="code" href="classvector__bufreader__reverse.html#ab236383c7a0434a1c616c16a4f334902" title="type of the input vector">vector_type</a>;
<a name="l01926"></a>01926 <span class="comment"></span>
<a name="l01927"></a>01927 <span class="comment">    //! block identifier iterator of the vector</span>
<a name="l01928"></a><a class="code" href="classvector__bufreader__reverse.html#a183d101942f9a003eecbe8158d85b007">01928</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvector__iterator.html#a340cc826e811035e2026f7ff171ebcf4">vector_iterator::bids_container_iterator</a> <a class="code" href="classvector__bufreader__reverse.html#a183d101942f9a003eecbe8158d85b007" title="block identifier iterator of the vector">bids_container_iterator</a>;
<a name="l01929"></a>01929 <span class="comment"></span>
<a name="l01930"></a>01930 <span class="comment">    //! construct output buffered stream used for overlapped reading</span>
<a name="l01931"></a><a class="code" href="classvector__bufreader__reverse.html#af98c8ab0cbb5693db55d2b63b73a1c4e">01931</a> <span class="comment"></span>    <span class="keyword">typedef</span> stxxl::buf_istream_reverse&lt;block_type, bids_container_iterator&gt; <a class="code" href="classvector__bufreader__reverse.html#af98c8ab0cbb5693db55d2b63b73a1c4e" title="construct output buffered stream used for overlapped reading">buf_istream_type</a>;
<a name="l01932"></a>01932 
<a name="l01933"></a>01933 <span class="keyword">protected</span>:<span class="comment"></span>
<a name="l01934"></a>01934 <span class="comment">    //! iterator to the beginning of the range.</span>
<a name="l01935"></a><a class="code" href="classvector__bufreader__reverse.html#acbee77a8ca1bc6314361a47f6aa8c6bf">01935</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader__reverse.html#a32ab1fa102c57d0728864d03e02b58c1" title="template parameter: the vector iterator type">vector_iterator</a> <a class="code" href="classvector__bufreader__reverse.html#acbee77a8ca1bc6314361a47f6aa8c6bf" title="iterator to the beginning of the range.">m_begin</a>;
<a name="l01936"></a>01936 <span class="comment"></span>
<a name="l01937"></a>01937 <span class="comment">    //! internal &quot;current&quot; iterator into the vector.</span>
<a name="l01938"></a><a class="code" href="classvector__bufreader__reverse.html#a04d604ba5983a18911c6064dde1cbd38">01938</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader__reverse.html#a32ab1fa102c57d0728864d03e02b58c1" title="template parameter: the vector iterator type">vector_iterator</a> <a class="code" href="classvector__bufreader__reverse.html#a04d604ba5983a18911c6064dde1cbd38" title="internal &quot;current&quot; iterator into the vector.">m_iter</a>;
<a name="l01939"></a>01939 <span class="comment"></span>
<a name="l01940"></a>01940 <span class="comment">    //! iterator to the end of the range.</span>
<a name="l01941"></a><a class="code" href="classvector__bufreader__reverse.html#a8ab90949ead2f8f8ca0cbdb0edcb4e2c">01941</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader__reverse.html#a32ab1fa102c57d0728864d03e02b58c1" title="template parameter: the vector iterator type">vector_iterator</a> <a class="code" href="classvector__bufreader__reverse.html#a8ab90949ead2f8f8ca0cbdb0edcb4e2c" title="iterator to the end of the range.">m_end</a>;
<a name="l01942"></a>01942 <span class="comment"></span>
<a name="l01943"></a>01943 <span class="comment">    //! buffered input stream used to overlapped I/O.</span>
<a name="l01944"></a><a class="code" href="classvector__bufreader__reverse.html#a7f0d381fef99d125d5286926d14b8710">01944</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader__reverse.html#af98c8ab0cbb5693db55d2b63b73a1c4e" title="construct output buffered stream used for overlapped reading">buf_istream_type</a>* <a class="code" href="classvector__bufreader__reverse.html#a7f0d381fef99d125d5286926d14b8710" title="buffered input stream used to overlapped I/O.">m_bufin</a>;
<a name="l01945"></a>01945 <span class="comment"></span>
<a name="l01946"></a>01946 <span class="comment">    //! number of blocks to use as buffers.</span>
<a name="l01947"></a><a class="code" href="classvector__bufreader__reverse.html#afc21b8821c55835a0d81035709e533fa">01947</a> <span class="comment"></span>    stxxl::unsigned_type <a class="code" href="classvector__bufreader__reverse.html#afc21b8821c55835a0d81035709e533fa" title="number of blocks to use as buffers.">m_nbuffers</a>;
<a name="l01948"></a>01948 
<a name="l01949"></a>01949 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l01950"></a>01950 <span class="comment">    //! Create overlapped reader for the given iterator range.</span>
<a name="l01951"></a>01951 <span class="comment">    //! \param begin iterator to position were to start reading in vector</span>
<a name="l01952"></a>01952 <span class="comment">    //! \param end iterator to position were to end reading in vector</span>
<a name="l01953"></a>01953 <span class="comment">    //! \param nbuffers number of buffers used for overlapped I/O (&gt;= 2*D recommended)</span>
<a name="l01954"></a><a class="code" href="classvector__bufreader__reverse.html#a1eb85dcb3ca9dae3eb0baab478d0288c">01954</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader__reverse.html#a1eb85dcb3ca9dae3eb0baab478d0288c" title="Create overlapped reader for the given iterator range.">vector_bufreader_reverse</a>(<a class="code" href="classvector__bufreader__reverse.html#a32ab1fa102c57d0728864d03e02b58c1" title="template parameter: the vector iterator type">vector_iterator</a> begin, <a class="code" href="classvector__bufreader__reverse.html#a32ab1fa102c57d0728864d03e02b58c1" title="template parameter: the vector iterator type">vector_iterator</a> end, stxxl::unsigned_type nbuffers = 0)
<a name="l01955"></a>01955     : <a class="code" href="classvector__bufreader__reverse.html#acbee77a8ca1bc6314361a47f6aa8c6bf" title="iterator to the beginning of the range.">m_begin</a>(begin), <a class="code" href="classvector__bufreader__reverse.html#a8ab90949ead2f8f8ca0cbdb0edcb4e2c" title="iterator to the end of the range.">m_end</a>(end),
<a name="l01956"></a>01956     <a class="code" href="classvector__bufreader__reverse.html#a7f0d381fef99d125d5286926d14b8710" title="buffered input stream used to overlapped I/O.">m_bufin</a>(NULL),
<a name="l01957"></a>01957     <a class="code" href="classvector__bufreader__reverse.html#afc21b8821c55835a0d81035709e533fa" title="number of blocks to use as buffers.">m_nbuffers</a>(nbuffers) {
<a name="l01958"></a>01958         <a class="code" href="classvector__bufreader__reverse.html#acbee77a8ca1bc6314361a47f6aa8c6bf" title="iterator to the beginning of the range.">m_begin</a>.flush(); <span class="comment">// flush container</span>
<a name="l01959"></a>01959 
<a name="l01960"></a>01960         <span class="keywordflow">if</span> (<a class="code" href="classvector__bufreader__reverse.html#afc21b8821c55835a0d81035709e533fa" title="number of blocks to use as buffers.">m_nbuffers</a> == 0)
<a name="l01961"></a>01961             <a class="code" href="classvector__bufreader__reverse.html#afc21b8821c55835a0d81035709e533fa" title="number of blocks to use as buffers.">m_nbuffers</a> = 2 * stxxl::config::get_instance()-&gt;disks_number();
<a name="l01962"></a>01962 
<a name="l01963"></a>01963         <a class="code" href="classvector__bufreader__reverse.html#ace8e34dcfea39f2923dd350669cd138b" title="Rewind stream back to begin. Note that this recreates the buffered reader and is thus not cheap...">rewind</a>();
<a name="l01964"></a>01964     }
<a name="l01965"></a>01965 <span class="comment"></span>
<a name="l01966"></a>01966 <span class="comment">    //! Create overlapped reader for the whole vector&#39;s content.</span>
<a name="l01967"></a>01967 <span class="comment">    //! \param vec vector to read</span>
<a name="l01968"></a>01968 <span class="comment">    //! \param nbuffers number of buffers used for overlapped I/O (&gt;= 2*D recommended)</span>
<a name="l01969"></a><a class="code" href="classvector__bufreader__reverse.html#a5ab801ad26c39644128c4513040e86f5">01969</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader__reverse.html#a1eb85dcb3ca9dae3eb0baab478d0288c" title="Create overlapped reader for the given iterator range.">vector_bufreader_reverse</a>(<span class="keyword">const</span> <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector_type</a>&amp; vec, stxxl::unsigned_type nbuffers = 0)
<a name="l01970"></a>01970     : <a class="code" href="classvector__bufreader__reverse.html#acbee77a8ca1bc6314361a47f6aa8c6bf" title="iterator to the beginning of the range.">m_begin</a>(vec.begin()), <a class="code" href="classvector__bufreader__reverse.html#a8ab90949ead2f8f8ca0cbdb0edcb4e2c" title="iterator to the end of the range.">m_end</a>(vec.end()),
<a name="l01971"></a>01971     <a class="code" href="classvector__bufreader__reverse.html#a7f0d381fef99d125d5286926d14b8710" title="buffered input stream used to overlapped I/O.">m_bufin</a>(NULL),
<a name="l01972"></a>01972     <a class="code" href="classvector__bufreader__reverse.html#afc21b8821c55835a0d81035709e533fa" title="number of blocks to use as buffers.">m_nbuffers</a>(nbuffers) {
<a name="l01973"></a>01973         <a class="code" href="classvector__bufreader__reverse.html#acbee77a8ca1bc6314361a47f6aa8c6bf" title="iterator to the beginning of the range.">m_begin</a>.flush(); <span class="comment">// flush container</span>
<a name="l01974"></a>01974 
<a name="l01975"></a>01975         <span class="keywordflow">if</span> (<a class="code" href="classvector__bufreader__reverse.html#afc21b8821c55835a0d81035709e533fa" title="number of blocks to use as buffers.">m_nbuffers</a> == 0)
<a name="l01976"></a>01976             <a class="code" href="classvector__bufreader__reverse.html#afc21b8821c55835a0d81035709e533fa" title="number of blocks to use as buffers.">m_nbuffers</a> = 2 * stxxl::config::get_instance()-&gt;disks_number();
<a name="l01977"></a>01977 
<a name="l01978"></a>01978         <a class="code" href="classvector__bufreader__reverse.html#ace8e34dcfea39f2923dd350669cd138b" title="Rewind stream back to begin. Note that this recreates the buffered reader and is thus not cheap...">rewind</a>();
<a name="l01979"></a>01979     }
<a name="l01980"></a>01980 <span class="comment"></span>
<a name="l01981"></a>01981 <span class="comment">    //! Rewind stream back to begin. Note that this recreates the buffered</span>
<a name="l01982"></a>01982 <span class="comment">    //! reader and is thus not cheap.</span>
<a name="l01983"></a><a class="code" href="classvector__bufreader__reverse.html#ace8e34dcfea39f2923dd350669cd138b">01983</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector__bufreader__reverse.html#ace8e34dcfea39f2923dd350669cd138b" title="Rewind stream back to begin. Note that this recreates the buffered reader and is thus not cheap...">rewind</a>() {
<a name="l01984"></a>01984         <a class="code" href="classvector__bufreader__reverse.html#a04d604ba5983a18911c6064dde1cbd38" title="internal &quot;current&quot; iterator into the vector.">m_iter</a> = <a class="code" href="classvector__bufreader__reverse.html#a8ab90949ead2f8f8ca0cbdb0edcb4e2c" title="iterator to the end of the range.">m_end</a>;
<a name="l01985"></a>01985         <span class="keywordflow">if</span> (<a class="code" href="classvector__bufreader__reverse.html#a379622bacb40542ca3425528a16755d2" title="Returns true once the whole range has been read.">empty</a>()) <span class="keywordflow">return</span>;
<a name="l01986"></a>01986 
<a name="l01987"></a>01987         <span class="keywordflow">if</span> (<a class="code" href="classvector__bufreader__reverse.html#a7f0d381fef99d125d5286926d14b8710" title="buffered input stream used to overlapped I/O.">m_bufin</a>) <span class="keyword">delete</span> <a class="code" href="classvector__bufreader__reverse.html#a7f0d381fef99d125d5286926d14b8710" title="buffered input stream used to overlapped I/O.">m_bufin</a>;
<a name="l01988"></a>01988 
<a name="l01989"></a>01989         <span class="comment">// find last bid to read</span>
<a name="l01990"></a>01990         <a class="code" href="classvector__bufreader__reverse.html#a183d101942f9a003eecbe8158d85b007" title="block identifier iterator of the vector">bids_container_iterator</a> end_bid = <a class="code" href="classvector__bufreader__reverse.html#a8ab90949ead2f8f8ca0cbdb0edcb4e2c" title="iterator to the end of the range.">m_end</a>.bid() + (<a class="code" href="classvector__bufreader__reverse.html#a8ab90949ead2f8f8ca0cbdb0edcb4e2c" title="iterator to the end of the range.">m_end</a>.block_offset() ? 1 : 0);
<a name="l01991"></a>01991 
<a name="l01992"></a>01992         <span class="comment">// construct buffered istream_reverse for range</span>
<a name="l01993"></a>01993         <a class="code" href="classvector__bufreader__reverse.html#a7f0d381fef99d125d5286926d14b8710" title="buffered input stream used to overlapped I/O.">m_bufin</a> = <span class="keyword">new</span> <a class="code" href="classvector__bufreader__reverse.html#af98c8ab0cbb5693db55d2b63b73a1c4e" title="construct output buffered stream used for overlapped reading">buf_istream_type</a>(<a class="code" href="classvector__bufreader__reverse.html#acbee77a8ca1bc6314361a47f6aa8c6bf" title="iterator to the beginning of the range.">m_begin</a>.bid(), end_bid, <a class="code" href="classvector__bufreader__reverse.html#afc21b8821c55835a0d81035709e533fa" title="number of blocks to use as buffers.">m_nbuffers</a>);
<a name="l01994"></a>01994 
<a name="l01995"></a>01995         <span class="comment">// skip to beginning of reverse sequence.</span>
<a name="l01996"></a>01996         stxxl::int_type endoff = <a class="code" href="classvector__bufreader__reverse.html#a8ab90949ead2f8f8ca0cbdb0edcb4e2c" title="iterator to the end of the range.">m_end</a>.block_offset();
<a name="l01997"></a>01997         <span class="keywordflow">if</span> (endoff == 0) {
<a name="l01998"></a>01998             <span class="comment">// nothing to skip</span>
<a name="l01999"></a>01999         } <span class="keywordflow">else</span> {
<a name="l02000"></a>02000             <span class="comment">// else, let ifstream_reverse skip last elements at end of block,</span>
<a name="l02001"></a>02001             <span class="comment">// up to real end</span>
<a name="l02002"></a>02002             <span class="keywordflow">for</span> (; endoff != <a class="code" href="classvector__bufreader__reverse.html#a416c7da1e08ccbd6f076613bdaf29383" title="Return remaining size.">block_type::size</a>; endoff++)
<a name="l02003"></a>02003                 ++(*<a class="code" href="classvector__bufreader__reverse.html#a7f0d381fef99d125d5286926d14b8710" title="buffered input stream used to overlapped I/O.">m_bufin</a>);
<a name="l02004"></a>02004         }
<a name="l02005"></a>02005     }
<a name="l02006"></a>02006 <span class="comment"></span>
<a name="l02007"></a>02007 <span class="comment">    //! Finish reading and free buffered reader.</span>
<a name="l02008"></a><a class="code" href="classvector__bufreader__reverse.html#ac382b9bbfbc8ddf5a8db09da30a7d7e5">02008</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader__reverse.html#ac382b9bbfbc8ddf5a8db09da30a7d7e5" title="Finish reading and free buffered reader.">~vector_bufreader_reverse</a>() {
<a name="l02009"></a>02009         <span class="keywordflow">if</span> (<a class="code" href="classvector__bufreader__reverse.html#a7f0d381fef99d125d5286926d14b8710" title="buffered input stream used to overlapped I/O.">m_bufin</a>) <span class="keyword">delete</span> <a class="code" href="classvector__bufreader__reverse.html#a7f0d381fef99d125d5286926d14b8710" title="buffered input stream used to overlapped I/O.">m_bufin</a>;
<a name="l02010"></a>02010     }
<a name="l02011"></a>02011 <span class="comment"></span>
<a name="l02012"></a>02012 <span class="comment">    //! Return constant reference to current item</span>
<a name="l02013"></a><a class="code" href="classvector__bufreader__reverse.html#a8313724237896981432574c54f444309">02013</a> <span class="comment"></span>    <span class="keyword">const</span> <a class="code" href="classvector__bufreader__reverse.html#a35a0594d7204d80bd6a61ccf1d9ee9a9" title="value type of the output vector">value_type</a>&amp; <a class="code" href="classvector__bufreader__reverse.html#a8313724237896981432574c54f444309" title="Return constant reference to current item.">operator *</a>()<span class="keyword"> const </span>{
<a name="l02014"></a>02014         <span class="keywordflow">return</span> *(*m_bufin);
<a name="l02015"></a>02015     }
<a name="l02016"></a>02016 <span class="comment"></span>
<a name="l02017"></a>02017 <span class="comment">    //! Return constant pointer to current item</span>
<a name="l02018"></a><a class="code" href="classvector__bufreader__reverse.html#afab090710fc7b02740a2050f8703baf2">02018</a> <span class="comment"></span>    <span class="keyword">const</span> <a class="code" href="classvector__bufreader__reverse.html#a35a0594d7204d80bd6a61ccf1d9ee9a9" title="value type of the output vector">value_type</a>* <a class="code" href="classvector__bufreader__reverse.html#afab090710fc7b02740a2050f8703baf2" title="Return constant pointer to current item.">operator -&gt; </a>()<span class="keyword"> const </span>{
<a name="l02019"></a>02019         <span class="keywordflow">return</span> &amp;(*(*m_bufin));
<a name="l02020"></a>02020     }
<a name="l02021"></a>02021 <span class="comment"></span>
<a name="l02022"></a>02022 <span class="comment">    //! Advance to next item (asserts if !empty()).</span>
<a name="l02023"></a><a class="code" href="classvector__bufreader__reverse.html#a9286af7e3f1fdddaab1602e57885144e">02023</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader__reverse.html" title="Buffered sequential reverse reader from a vector using overlapped I/O.">vector_bufreader_reverse</a>&amp; <a class="code" href="classvector__bufreader__reverse.html#a9286af7e3f1fdddaab1602e57885144e" title="Advance to next item (asserts if !empty()).">operator ++</a>() {
<a name="l02024"></a>02024         assert(!<a class="code" href="classvector__bufreader__reverse.html#a379622bacb40542ca3425528a16755d2" title="Returns true once the whole range has been read.">empty</a>());
<a name="l02025"></a>02025         --<a class="code" href="classvector__bufreader__reverse.html#a04d604ba5983a18911c6064dde1cbd38" title="internal &quot;current&quot; iterator into the vector.">m_iter</a>;
<a name="l02026"></a>02026         ++(*m_bufin);
<a name="l02027"></a>02027 
<a name="l02028"></a>02028         <span class="keywordflow">if</span> (UNLIKELY(<a class="code" href="classvector__bufreader__reverse.html#a379622bacb40542ca3425528a16755d2" title="Returns true once the whole range has been read.">empty</a>())) {
<a name="l02029"></a>02029             <span class="keyword">delete</span> <a class="code" href="classvector__bufreader__reverse.html#a7f0d381fef99d125d5286926d14b8710" title="buffered input stream used to overlapped I/O.">m_bufin</a>;
<a name="l02030"></a>02030             <a class="code" href="classvector__bufreader__reverse.html#a7f0d381fef99d125d5286926d14b8710" title="buffered input stream used to overlapped I/O.">m_bufin</a> = NULL;
<a name="l02031"></a>02031         }
<a name="l02032"></a>02032 
<a name="l02033"></a>02033         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02034"></a>02034     }
<a name="l02035"></a>02035 <span class="comment"></span>
<a name="l02036"></a>02036 <span class="comment">    //! Read current item into variable and advance to next one.</span>
<a name="l02037"></a><a class="code" href="classvector__bufreader__reverse.html#ab62bb1531045ddbd29f2234a884bc18e">02037</a> <span class="comment"></span>    <a class="code" href="classvector__bufreader__reverse.html" title="Buffered sequential reverse reader from a vector using overlapped I/O.">vector_bufreader_reverse</a>&amp; <a class="code" href="classvector__bufreader__reverse.html#ab62bb1531045ddbd29f2234a884bc18e" title="Read current item into variable and advance to next one.">operator &gt;&gt;</a>(<a class="code" href="classvector__bufreader__reverse.html#a35a0594d7204d80bd6a61ccf1d9ee9a9" title="value type of the output vector">value_type</a>&amp; v) {
<a name="l02038"></a>02038         v = <a class="code" href="classvector__bufreader__reverse.html#a8313724237896981432574c54f444309" title="Return constant reference to current item.">operator *</a>();
<a name="l02039"></a>02039         <a class="code" href="classvector__bufreader__reverse.html#a9286af7e3f1fdddaab1602e57885144e" title="Advance to next item (asserts if !empty()).">operator ++</a>();
<a name="l02040"></a>02040 
<a name="l02041"></a>02041         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02042"></a>02042     }
<a name="l02043"></a>02043 <span class="comment"></span>
<a name="l02044"></a>02044 <span class="comment">    //! Return remaining size.</span>
<a name="l02045"></a><a class="code" href="classvector__bufreader__reverse.html#a416c7da1e08ccbd6f076613bdaf29383">02045</a> <span class="comment"></span>    <span class="keywordtype">size_t</span> <a class="code" href="classvector__bufreader__reverse.html#a416c7da1e08ccbd6f076613bdaf29383" title="Return remaining size.">size</a>()<span class="keyword"> const </span>{
<a name="l02046"></a>02046         assert(<a class="code" href="classvector__bufreader__reverse.html#acbee77a8ca1bc6314361a47f6aa8c6bf" title="iterator to the beginning of the range.">m_begin</a> &lt;= <a class="code" href="classvector__bufreader__reverse.html#a04d604ba5983a18911c6064dde1cbd38" title="internal &quot;current&quot; iterator into the vector.">m_iter</a> &amp;&amp; <a class="code" href="classvector__bufreader__reverse.html#a04d604ba5983a18911c6064dde1cbd38" title="internal &quot;current&quot; iterator into the vector.">m_iter</a> &lt;= <a class="code" href="classvector__bufreader__reverse.html#a8ab90949ead2f8f8ca0cbdb0edcb4e2c" title="iterator to the end of the range.">m_end</a>);
<a name="l02047"></a>02047         <span class="keywordflow">return</span> (<a class="code" href="classvector__bufreader__reverse.html#a04d604ba5983a18911c6064dde1cbd38" title="internal &quot;current&quot; iterator into the vector.">m_iter</a> - <a class="code" href="classvector__bufreader__reverse.html#acbee77a8ca1bc6314361a47f6aa8c6bf" title="iterator to the beginning of the range.">m_begin</a>);
<a name="l02048"></a>02048     }
<a name="l02049"></a>02049 <span class="comment"></span>
<a name="l02050"></a>02050 <span class="comment">    //! Returns true once the whole range has been read.</span>
<a name="l02051"></a><a class="code" href="classvector__bufreader__reverse.html#a379622bacb40542ca3425528a16755d2">02051</a> <span class="comment"></span>    <span class="keywordtype">bool</span> <a class="code" href="classvector__bufreader__reverse.html#a379622bacb40542ca3425528a16755d2" title="Returns true once the whole range has been read.">empty</a>()<span class="keyword"> const </span>{
<a name="l02052"></a>02052         <span class="keywordflow">return</span> (<a class="code" href="classvector__bufreader__reverse.html#a04d604ba5983a18911c6064dde1cbd38" title="internal &quot;current&quot; iterator into the vector.">m_iter</a> == <a class="code" href="classvector__bufreader__reverse.html#acbee77a8ca1bc6314361a47f6aa8c6bf" title="iterator to the beginning of the range.">m_begin</a>);
<a name="l02053"></a>02053     }
<a name="l02054"></a>02054 };
<a name="l02055"></a>02055 <span class="comment"></span>
<a name="l02056"></a>02056 <span class="comment">////////////////////////////////////////////////////////////////////////////</span>
<a name="l02057"></a>02057 <span class="comment"></span><span class="comment">/*!</span>
<a name="l02058"></a>02058 <span class="comment"> * Buffered sequential writer to a vector using overlapped I/O.</span>
<a name="l02059"></a>02059 <span class="comment"> *</span>
<a name="l02060"></a>02060 <span class="comment"> * This buffered writer can be used to write a large sequential region of a</span>
<a name="l02061"></a>02061 <span class="comment"> * vector using overlapped I/O. The object is created from an iterator range,</span>
<a name="l02062"></a>02062 <span class="comment"> * which can then be written to using operator &lt;&lt; (), or with operator * () and</span>
<a name="l02063"></a>02063 <span class="comment"> * operator ++ ().</span>
<a name="l02064"></a>02064 <span class="comment"> *</span>
<a name="l02065"></a>02065 <span class="comment"> * The buffered writer is given one iterator in the constructor. When writing,</span>
<a name="l02066"></a>02066 <span class="comment"> * this iterator advances in the vector and will \b enlarge the vector once it</span>
<a name="l02067"></a>02067 <span class="comment"> * reaches the end(). The vector size is doubled each time; nevertheless, it is</span>
<a name="l02068"></a>02068 <span class="comment"> * better to preinitialize the vector&#39;s size using stxxl::vector::resize().</span>
<a name="l02069"></a>02069 <span class="comment"> *</span>
<a name="l02070"></a>02070 <span class="comment"> * See \ref tutorial_vector_buf</span>
<a name="l02071"></a>02071 <span class="comment"> */</span>
<a name="l02072"></a>02072 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorIterator&gt;
<a name="l02073"></a><a class="code" href="classvector__bufwriter.html">02073</a> <span class="keyword">class </span><a class="code" href="classvector__bufwriter.html" title="Buffered sequential writer to a vector using overlapped I/O.">vector_bufwriter</a> : <span class="keyword">public</span> stxxl::noncopyable {
<a name="l02074"></a>02074 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l02075"></a>02075 <span class="comment">    //! template parameter: the vector iterator type</span>
<a name="l02076"></a><a class="code" href="classvector__bufwriter.html#a935d8a2c0ad696299b8f0923364f9581">02076</a> <span class="comment"></span>    <span class="keyword">typedef</span> VectorIterator <a class="code" href="classvector__bufwriter.html#a935d8a2c0ad696299b8f0923364f9581" title="template parameter: the vector iterator type">iterator</a>;
<a name="l02077"></a>02077 <span class="comment"></span>
<a name="l02078"></a>02078 <span class="comment">    //! type of the output vector</span>
<a name="l02079"></a><a class="code" href="classvector__bufwriter.html#aa3759fe3fa055007f61616a58d0e46c2">02079</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator::vector_type <a class="code" href="classvector__bufwriter.html#aa3759fe3fa055007f61616a58d0e46c2" title="type of the output vector">vector_type</a>;
<a name="l02080"></a>02080 <span class="comment"></span>
<a name="l02081"></a>02081 <span class="comment">    //! value type of the output vector</span>
<a name="l02082"></a><a class="code" href="classvector__bufwriter.html#a2778ec5b11bc2f20562ce445ee299b87">02082</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator::value_type <a class="code" href="classvector__bufwriter.html#a2778ec5b11bc2f20562ce445ee299b87" title="value type of the output vector">value_type</a>;
<a name="l02083"></a>02083 <span class="comment"></span>
<a name="l02084"></a>02084 <span class="comment">    //! block type used in the vector</span>
<a name="l02085"></a><a class="code" href="classvector__bufwriter.html#a9b95cdceb39fca17dd53e78f4df32ad2">02085</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator::block_type <a class="code" href="classvector__bufwriter.html#a9b95cdceb39fca17dd53e78f4df32ad2" title="block type used in the vector">block_type</a>;
<a name="l02086"></a>02086 <span class="comment"></span>
<a name="l02087"></a>02087 <span class="comment">    //! block identifier iterator of the vector</span>
<a name="l02088"></a><a class="code" href="classvector__bufwriter.html#a6f36937caca601e5570f6a69ab309723">02088</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator::bids_container_iterator <a class="code" href="classvector__bufwriter.html#a6f36937caca601e5570f6a69ab309723" title="block identifier iterator of the vector">bids_container_iterator</a>;
<a name="l02089"></a>02089 <span class="comment"></span>
<a name="l02090"></a>02090 <span class="comment">    //! iterator type of vector</span>
<a name="l02091"></a><a class="code" href="classvector__bufwriter.html#ad5df85d4cda41a033e7a923cee8e258e">02091</a> <span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator::iterator <a class="code" href="classvector__bufwriter.html#ad5df85d4cda41a033e7a923cee8e258e" title="iterator type of vector">vector_iterator</a>;
<a name="l02092"></a><a class="code" href="classvector__bufwriter.html#a91c774d7a4b6c88f018c94fac4f00c0a">02092</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator::const_iterator <a class="code" href="classvector__bufwriter.html#a91c774d7a4b6c88f018c94fac4f00c0a">vector_const_iterator</a>;
<a name="l02093"></a>02093 <span class="comment"></span>
<a name="l02094"></a>02094 <span class="comment">    //! construct output buffered stream used for overlapped writing</span>
<a name="l02095"></a><a class="code" href="classvector__bufwriter.html#aaf101c881d995d1637334941bc5e2e34">02095</a> <span class="comment"></span>    <span class="keyword">typedef</span> stxxl::buf_ostream&lt;block_type, bids_container_iterator&gt; <a class="code" href="classvector__bufwriter.html#aaf101c881d995d1637334941bc5e2e34" title="construct output buffered stream used for overlapped writing">buf_ostream_type</a>;
<a name="l02096"></a>02096 
<a name="l02097"></a>02097 <span class="keyword">protected</span>:<span class="comment"></span>
<a name="l02098"></a>02098 <span class="comment">    //! internal iterator into the vector.</span>
<a name="l02099"></a><a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304">02099</a> <span class="comment"></span>    <a class="code" href="classvector__bufwriter.html#ad5df85d4cda41a033e7a923cee8e258e" title="iterator type of vector">vector_iterator</a> <a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>;
<a name="l02100"></a>02100 <span class="comment"></span>
<a name="l02101"></a>02101 <span class="comment">    //! iterator to the current end of the vector.</span>
<a name="l02102"></a><a class="code" href="classvector__bufwriter.html#a655b494c403a291ec6f0dadecbe7bcac">02102</a> <span class="comment"></span>    <a class="code" href="classvector__bufwriter.html#a91c774d7a4b6c88f018c94fac4f00c0a">vector_const_iterator</a> <a class="code" href="classvector__bufwriter.html#a655b494c403a291ec6f0dadecbe7bcac" title="iterator to the current end of the vector.">m_end</a>;
<a name="l02103"></a>02103 <span class="comment"></span>
<a name="l02104"></a>02104 <span class="comment">    //! boolean whether the vector was grown, will shorten at finish().</span>
<a name="l02105"></a><a class="code" href="classvector__bufwriter.html#a1d3604ef0882641a91ee68d9b84fcee9">02105</a> <span class="comment"></span>    <span class="keywordtype">bool</span> <a class="code" href="classvector__bufwriter.html#a1d3604ef0882641a91ee68d9b84fcee9" title="boolean whether the vector was grown, will shorten at finish().">m_grown</a>;
<a name="l02106"></a>02106 <span class="comment"></span>
<a name="l02107"></a>02107 <span class="comment">    //! iterator into vector of the last block accessed (used to issue updates</span>
<a name="l02108"></a>02108 <span class="comment">    //! when the block is switched).</span>
<a name="l02109"></a><a class="code" href="classvector__bufwriter.html#a2479dbd79fb4f7590f332c47f27158c3">02109</a> <span class="comment"></span>    <a class="code" href="classvector__bufwriter.html#a91c774d7a4b6c88f018c94fac4f00c0a">vector_const_iterator</a> <a class="code" href="classvector__bufwriter.html#a2479dbd79fb4f7590f332c47f27158c3" title="iterator into vector of the last block accessed (used to issue updates when the block is switched)...">m_prevblk</a>;
<a name="l02110"></a>02110 <span class="comment"></span>
<a name="l02111"></a>02111 <span class="comment">    //! buffered output stream used to overlapped I/O.</span>
<a name="l02112"></a><a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9">02112</a> <span class="comment"></span>    <a class="code" href="classvector__bufwriter.html#aaf101c881d995d1637334941bc5e2e34" title="construct output buffered stream used for overlapped writing">buf_ostream_type</a>* <a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a>;
<a name="l02113"></a>02113 <span class="comment"></span>
<a name="l02114"></a>02114 <span class="comment">    //! number of blocks to use as buffers.</span>
<a name="l02115"></a><a class="code" href="classvector__bufwriter.html#a12b0b9161df06e792c4c00b8cf7dde0d">02115</a> <span class="comment"></span>    stxxl::unsigned_type <a class="code" href="classvector__bufwriter.html#a12b0b9161df06e792c4c00b8cf7dde0d" title="number of blocks to use as buffers.">m_nbuffers</a>;
<a name="l02116"></a>02116 
<a name="l02117"></a>02117 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l02118"></a>02118 <span class="comment">    //! Create overlapped writer beginning at the given iterator.</span>
<a name="l02119"></a>02119 <span class="comment">    //! \param begin iterator to position were to start writing in vector</span>
<a name="l02120"></a>02120 <span class="comment">    //! \param nbuffers number of buffers used for overlapped I/O (&gt;= 2D recommended)</span>
<a name="l02121"></a><a class="code" href="classvector__bufwriter.html#ac9017000fc27ef4c112ee796c1f144a8">02121</a> <span class="comment"></span>    <a class="code" href="classvector__bufwriter.html#ac9017000fc27ef4c112ee796c1f144a8" title="Create overlapped writer beginning at the given iterator.">vector_bufwriter</a>(<a class="code" href="classvector__bufwriter.html#ad5df85d4cda41a033e7a923cee8e258e" title="iterator type of vector">vector_iterator</a> begin,
<a name="l02122"></a>02122             stxxl::unsigned_type nbuffers = 0)
<a name="l02123"></a>02123     : <a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>(begin),
<a name="l02124"></a>02124     <a class="code" href="classvector__bufwriter.html#a655b494c403a291ec6f0dadecbe7bcac" title="iterator to the current end of the vector.">m_end</a>(<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>.parent_vector()-&gt;end()),
<a name="l02125"></a>02125     <a class="code" href="classvector__bufwriter.html#a1d3604ef0882641a91ee68d9b84fcee9" title="boolean whether the vector was grown, will shorten at finish().">m_grown</a>(false),
<a name="l02126"></a>02126     <a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a>(NULL),
<a name="l02127"></a>02127     <a class="code" href="classvector__bufwriter.html#a12b0b9161df06e792c4c00b8cf7dde0d" title="number of blocks to use as buffers.">m_nbuffers</a>(nbuffers) {
<a name="l02128"></a>02128         <span class="keywordflow">if</span> (<a class="code" href="classvector__bufwriter.html#a12b0b9161df06e792c4c00b8cf7dde0d" title="number of blocks to use as buffers.">m_nbuffers</a> == 0)
<a name="l02129"></a>02129             <a class="code" href="classvector__bufwriter.html#a12b0b9161df06e792c4c00b8cf7dde0d" title="number of blocks to use as buffers.">m_nbuffers</a> = 2 * stxxl::config::get_instance()-&gt;disks_number();
<a name="l02130"></a>02130 
<a name="l02131"></a>02131         assert(<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a> &lt;= <a class="code" href="classvector__bufwriter.html#a655b494c403a291ec6f0dadecbe7bcac" title="iterator to the current end of the vector.">m_end</a>);
<a name="l02132"></a>02132     }
<a name="l02133"></a>02133 <span class="comment"></span>
<a name="l02134"></a>02134 <span class="comment">    //! Create overlapped writer for the vector&#39;s beginning</span>
<a name="l02135"></a>02135 <span class="comment">    //! \param vec vector to write</span>
<a name="l02136"></a>02136 <span class="comment">    //! \param nbuffers number of buffers used for overlapped I/O (&gt;= 2D recommended)</span>
<a name="l02137"></a><a class="code" href="classvector__bufwriter.html#a81612f2644a5f7335eec085658d86003">02137</a> <span class="comment"></span>    <a class="code" href="classvector__bufwriter.html#ac9017000fc27ef4c112ee796c1f144a8" title="Create overlapped writer beginning at the given iterator.">vector_bufwriter</a>(<a class="code" href="classvector__bufwriter.html#aa3759fe3fa055007f61616a58d0e46c2" title="type of the output vector">vector_type</a>&amp; vec,
<a name="l02138"></a>02138             stxxl::unsigned_type nbuffers = 0)
<a name="l02139"></a>02139     : <a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>(vec.begin()),
<a name="l02140"></a>02140     <a class="code" href="classvector__bufwriter.html#a655b494c403a291ec6f0dadecbe7bcac" title="iterator to the current end of the vector.">m_end</a>(<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>.parent_vector()-&gt;end()),
<a name="l02141"></a>02141     <a class="code" href="classvector__bufwriter.html#a1d3604ef0882641a91ee68d9b84fcee9" title="boolean whether the vector was grown, will shorten at finish().">m_grown</a>(false),
<a name="l02142"></a>02142     <a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a>(NULL),
<a name="l02143"></a>02143     <a class="code" href="classvector__bufwriter.html#a12b0b9161df06e792c4c00b8cf7dde0d" title="number of blocks to use as buffers.">m_nbuffers</a>(nbuffers) {
<a name="l02144"></a>02144         <span class="keywordflow">if</span> (<a class="code" href="classvector__bufwriter.html#a12b0b9161df06e792c4c00b8cf7dde0d" title="number of blocks to use as buffers.">m_nbuffers</a> == 0)
<a name="l02145"></a>02145             <a class="code" href="classvector__bufwriter.html#a12b0b9161df06e792c4c00b8cf7dde0d" title="number of blocks to use as buffers.">m_nbuffers</a> = 2 * stxxl::config::get_instance()-&gt;disks_number();
<a name="l02146"></a>02146 
<a name="l02147"></a>02147         assert(<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a> &lt;= <a class="code" href="classvector__bufwriter.html#a655b494c403a291ec6f0dadecbe7bcac" title="iterator to the current end of the vector.">m_end</a>);
<a name="l02148"></a>02148     }
<a name="l02149"></a>02149 <span class="comment"></span>
<a name="l02150"></a>02150 <span class="comment">    //! Finish writing and flush output back to vector.</span>
<a name="l02151"></a><a class="code" href="classvector__bufwriter.html#aef5e223c0f3259366806bf91e64d4e15">02151</a> <span class="comment"></span>    <a class="code" href="classvector__bufwriter.html#aef5e223c0f3259366806bf91e64d4e15" title="Finish writing and flush output back to vector.">~vector_bufwriter</a>() {
<a name="l02152"></a>02152         <a class="code" href="classvector__bufwriter.html#ae3bae5f75163ee7c5177353022758a69" title="Finish writing and flush output back to vector.">finish</a>();
<a name="l02153"></a>02153     }
<a name="l02154"></a>02154 <span class="comment"></span>
<a name="l02155"></a>02155 <span class="comment">    //! Return mutable reference to item at the position of the internal</span>
<a name="l02156"></a>02156 <span class="comment">    //! iterator.</span>
<a name="l02157"></a><a class="code" href="classvector__bufwriter.html#aede7d5ebf9880a6455b76bfd70437940">02157</a> <span class="comment"></span>    <a class="code" href="classvector__bufwriter.html#a2778ec5b11bc2f20562ce445ee299b87" title="value type of the output vector">value_type</a>&amp; <a class="code" href="classvector__bufwriter.html#aede7d5ebf9880a6455b76bfd70437940" title="Return mutable reference to item at the position of the internal iterator.">operator *</a>() {
<a name="l02158"></a>02158         <span class="keywordflow">if</span> (UNLIKELY(<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a> == <a class="code" href="classvector__bufwriter.html#a655b494c403a291ec6f0dadecbe7bcac" title="iterator to the current end of the vector.">m_end</a>)) {
<a name="l02159"></a>02159             <span class="comment">// iterator points to end of vector -&gt; double vector&#39;s size</span>
<a name="l02160"></a>02160 
<a name="l02161"></a>02161             <span class="keywordflow">if</span> (<a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a>) {
<a name="l02162"></a>02162                 <span class="comment">// fixes issue with buf_ostream writing invalid blocks: when</span>
<a name="l02163"></a>02163                 <span class="comment">// buf_ostream::current_elem advances to next block, flush()</span>
<a name="l02164"></a>02164                 <span class="comment">// will write to block beyond bid().end.</span>
<a name="l02165"></a>02165                 <span class="keywordflow">if</span> (<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>.block_offset() != 0)
<a name="l02166"></a>02166                     <a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a>-&gt;flush(); <span class="comment">// flushes overlap buffers</span>
<a name="l02167"></a>02167 
<a name="l02168"></a>02168                 <span class="keyword">delete</span> <a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a>;
<a name="l02169"></a>02169                 <a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a> = NULL;
<a name="l02170"></a>02170 
<a name="l02171"></a>02171                 <span class="keywordflow">if</span> (<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>.block_offset() != 0)
<a name="l02172"></a>02172                     <a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>.block_externally_updated();
<a name="l02173"></a>02173             }
<a name="l02174"></a>02174 
<a name="l02175"></a>02175             <a class="code" href="classvector__bufwriter.html#aa3759fe3fa055007f61616a58d0e46c2" title="type of the output vector">vector_type</a>&amp; v = *<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>.parent_vector();
<a name="l02176"></a>02176             <span class="keywordflow">if</span> (v.size() &lt; 2 * block_type::size) {
<a name="l02177"></a>02177                 v.resize(2 * block_type::size);
<a name="l02178"></a>02178             } <span class="keywordflow">else</span> {
<a name="l02179"></a>02179                 v.resize(2 * v.size());
<a name="l02180"></a>02180             }
<a name="l02181"></a>02181             <a class="code" href="classvector__bufwriter.html#a655b494c403a291ec6f0dadecbe7bcac" title="iterator to the current end of the vector.">m_end</a> = v.end();
<a name="l02182"></a>02182             <a class="code" href="classvector__bufwriter.html#a1d3604ef0882641a91ee68d9b84fcee9" title="boolean whether the vector was grown, will shorten at finish().">m_grown</a> = <span class="keyword">true</span>;
<a name="l02183"></a>02183         }
<a name="l02184"></a>02184 
<a name="l02185"></a>02185         assert(<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a> &lt; <a class="code" href="classvector__bufwriter.html#a655b494c403a291ec6f0dadecbe7bcac" title="iterator to the current end of the vector.">m_end</a>);
<a name="l02186"></a>02186 
<a name="l02187"></a>02187         <span class="keywordflow">if</span> (UNLIKELY(<a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a> == NULL)) {
<a name="l02188"></a>02188             <span class="keywordflow">if</span> (<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>.block_offset() != 0) {
<a name="l02189"></a>02189                 <span class="comment">// output position is not at the start of the block, we</span>
<a name="l02190"></a>02190                 <span class="comment">// continue to use the iterator initially passed to the</span>
<a name="l02191"></a>02191                 <span class="comment">// constructor.</span>
<a name="l02192"></a>02192                 <span class="keywordflow">return</span> *<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>;
<a name="l02193"></a>02193             } <span class="keywordflow">else</span> {
<a name="l02194"></a>02194                 <span class="comment">// output position is start of block: create buffered writer</span>
<a name="l02195"></a>02195 
<a name="l02196"></a>02196                 <a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>.flush(); <span class="comment">// flush container</span>
<a name="l02197"></a>02197 
<a name="l02198"></a>02198                 <span class="comment">// create buffered write stream for blocks</span>
<a name="l02199"></a>02199                 <a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a> = <span class="keyword">new</span> <a class="code" href="classvector__bufwriter.html#aaf101c881d995d1637334941bc5e2e34" title="construct output buffered stream used for overlapped writing">buf_ostream_type</a>(<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>.bid(), <a class="code" href="classvector__bufwriter.html#a12b0b9161df06e792c4c00b8cf7dde0d" title="number of blocks to use as buffers.">m_nbuffers</a>);
<a name="l02200"></a>02200                 <a class="code" href="classvector__bufwriter.html#a2479dbd79fb4f7590f332c47f27158c3" title="iterator into vector of the last block accessed (used to issue updates when the block is switched)...">m_prevblk</a> = <a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>;
<a name="l02201"></a>02201 
<a name="l02202"></a>02202                 <span class="comment">// drop through to normal output into buffered writer</span>
<a name="l02203"></a>02203             }
<a name="l02204"></a>02204         }
<a name="l02205"></a>02205 
<a name="l02206"></a>02206         <span class="comment">// if the pointer has finished a block, then we inform the vector that</span>
<a name="l02207"></a>02207         <span class="comment">// this block has been updated.</span>
<a name="l02208"></a>02208         <span class="keywordflow">if</span> (UNLIKELY(<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>.block_offset() == 0)) {
<a name="l02209"></a>02209             <span class="keywordflow">if</span> (<a class="code" href="classvector__bufwriter.html#a2479dbd79fb4f7590f332c47f27158c3" title="iterator into vector of the last block accessed (used to issue updates when the block is switched)...">m_prevblk</a> != <a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>) {
<a name="l02210"></a>02210                 <a class="code" href="classvector__bufwriter.html#a2479dbd79fb4f7590f332c47f27158c3" title="iterator into vector of the last block accessed (used to issue updates when the block is switched)...">m_prevblk</a>.block_externally_updated();
<a name="l02211"></a>02211                 <a class="code" href="classvector__bufwriter.html#a2479dbd79fb4f7590f332c47f27158c3" title="iterator into vector of the last block accessed (used to issue updates when the block is switched)...">m_prevblk</a> = <a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>;
<a name="l02212"></a>02212             }
<a name="l02213"></a>02213         }
<a name="l02214"></a>02214 
<a name="l02215"></a>02215         <span class="keywordflow">return</span> <a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a>-&gt;operator *();
<a name="l02216"></a>02216     }
<a name="l02217"></a>02217 <span class="comment"></span>
<a name="l02218"></a>02218 <span class="comment">    //! Advance internal iterator.</span>
<a name="l02219"></a><a class="code" href="classvector__bufwriter.html#a37a37289311a7bf1d533b1ff06963f62">02219</a> <span class="comment"></span>    <a class="code" href="classvector__bufwriter.html" title="Buffered sequential writer to a vector using overlapped I/O.">vector_bufwriter</a>&amp; <a class="code" href="classvector__bufwriter.html#a37a37289311a7bf1d533b1ff06963f62" title="Advance internal iterator.">operator ++</a>() {
<a name="l02220"></a>02220         <span class="comment">// always advance internal iterator</span>
<a name="l02221"></a>02221         ++<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>;
<a name="l02222"></a>02222 
<a name="l02223"></a>02223         <span class="comment">// if buf_ostream active, advance that too</span>
<a name="l02224"></a>02224         <span class="keywordflow">if</span> (LIKELY(<a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a> != NULL)) <a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a>-&gt;operator ++();
<a name="l02225"></a>02225 
<a name="l02226"></a>02226         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02227"></a>02227     }
<a name="l02228"></a>02228 <span class="comment"></span>
<a name="l02229"></a>02229 <span class="comment">    //! Write value to the current position and advance the internal iterator.</span>
<a name="l02230"></a><a class="code" href="classvector__bufwriter.html#a81a0f3b46cfa3c7c421675c5a3c47ca7">02230</a> <span class="comment"></span>    <a class="code" href="classvector__bufwriter.html" title="Buffered sequential writer to a vector using overlapped I/O.">vector_bufwriter</a>&amp; <a class="code" href="classvector__bufwriter.html#a81a0f3b46cfa3c7c421675c5a3c47ca7" title="Write value to the current position and advance the internal iterator.">operator &lt;&lt;</a>(<span class="keyword">const</span> <a class="code" href="classvector__bufwriter.html#a2778ec5b11bc2f20562ce445ee299b87" title="value type of the output vector">value_type</a>&amp; v) {
<a name="l02231"></a>02231         <a class="code" href="classvector__bufwriter.html#aede7d5ebf9880a6455b76bfd70437940" title="Return mutable reference to item at the position of the internal iterator.">operator *</a>() = v;
<a name="l02232"></a>02232         <a class="code" href="classvector__bufwriter.html#a37a37289311a7bf1d533b1ff06963f62" title="Advance internal iterator.">operator ++</a>();
<a name="l02233"></a>02233 
<a name="l02234"></a>02234         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02235"></a>02235     }
<a name="l02236"></a>02236 <span class="comment"></span>
<a name="l02237"></a>02237 <span class="comment">    //! Finish writing and flush output back to vector.</span>
<a name="l02238"></a><a class="code" href="classvector__bufwriter.html#ae3bae5f75163ee7c5177353022758a69">02238</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classvector__bufwriter.html#ae3bae5f75163ee7c5177353022758a69" title="Finish writing and flush output back to vector.">finish</a>() {
<a name="l02239"></a>02239         <span class="keywordflow">if</span> (<a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a>) {
<a name="l02240"></a>02240             <span class="comment">// must finish the block started in the buffered writer: fill it with</span>
<a name="l02241"></a>02241             <span class="comment">// the data in the vector</span>
<a name="l02242"></a>02242             <a class="code" href="classvector__bufwriter.html#a91c774d7a4b6c88f018c94fac4f00c0a">vector_const_iterator</a> const_out = <a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>;
<a name="l02243"></a>02243 
<a name="l02244"></a>02244             <span class="keywordflow">while</span> (const_out.block_offset() != 0) {
<a name="l02245"></a>02245                 <a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a>-&gt;operator *() = *const_out;
<a name="l02246"></a>02246                 <a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a>-&gt;operator ++();
<a name="l02247"></a>02247                 ++const_out;
<a name="l02248"></a>02248             }
<a name="l02249"></a>02249 
<a name="l02250"></a>02250             <span class="comment">// inform the vector that the block has been updated.</span>
<a name="l02251"></a>02251             <span class="keywordflow">if</span> (<a class="code" href="classvector__bufwriter.html#a2479dbd79fb4f7590f332c47f27158c3" title="iterator into vector of the last block accessed (used to issue updates when the block is switched)...">m_prevblk</a> != <a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>) {
<a name="l02252"></a>02252                 <a class="code" href="classvector__bufwriter.html#a2479dbd79fb4f7590f332c47f27158c3" title="iterator into vector of the last block accessed (used to issue updates when the block is switched)...">m_prevblk</a>.block_externally_updated();
<a name="l02253"></a>02253                 <a class="code" href="classvector__bufwriter.html#a2479dbd79fb4f7590f332c47f27158c3" title="iterator into vector of the last block accessed (used to issue updates when the block is switched)...">m_prevblk</a> = <a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>;
<a name="l02254"></a>02254             }
<a name="l02255"></a>02255 
<a name="l02256"></a>02256             <span class="keyword">delete</span> <a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a>;
<a name="l02257"></a>02257             <a class="code" href="classvector__bufwriter.html#a4d3b19e5da8cc8ef966478f700674ea9" title="buffered output stream used to overlapped I/O.">m_bufout</a> = NULL;
<a name="l02258"></a>02258         }
<a name="l02259"></a>02259 
<a name="l02260"></a>02260         <span class="keywordflow">if</span> (<a class="code" href="classvector__bufwriter.html#a1d3604ef0882641a91ee68d9b84fcee9" title="boolean whether the vector was grown, will shorten at finish().">m_grown</a>) {
<a name="l02261"></a>02261             <a class="code" href="classvector__bufwriter.html#aa3759fe3fa055007f61616a58d0e46c2" title="type of the output vector">vector_type</a>&amp; v = *<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a>.parent_vector();
<a name="l02262"></a>02262             v.resize(<a class="code" href="classvector__bufwriter.html#aa4cb936be035119c37476c2b801a6304" title="internal iterator into the vector.">m_iter</a> - v.begin());
<a name="l02263"></a>02263 
<a name="l02264"></a>02264             <a class="code" href="classvector__bufwriter.html#a1d3604ef0882641a91ee68d9b84fcee9" title="boolean whether the vector was grown, will shorten at finish().">m_grown</a> = <span class="keyword">false</span>;
<a name="l02265"></a>02265         }
<a name="l02266"></a>02266     }
<a name="l02267"></a>02267 };
<a name="l02268"></a>02268 <span class="comment"></span>
<a name="l02269"></a>02269 <span class="comment">////////////////////////////////////////////////////////////////////////////</span>
<a name="l02270"></a>02270 <span class="comment"></span><span class="comment"></span>
<a name="l02271"></a>02271 <span class="comment">//! \brief External vector type generator.</span>
<a name="l02272"></a>02272 <span class="comment">//!</span>
<a name="l02273"></a>02273 <span class="comment">//! \tparam ValueType element type of contained objects (POD with no references to internal memory)</span>
<a name="l02274"></a>02274 <span class="comment">//! \tparam PageSize number of blocks in a page, default: \b 4 (recommended &gt;= D)</span>
<a name="l02275"></a>02275 <span class="comment">//! \tparam CachePages number of pages in cache, default: \b 8 (recommended &gt;= 2)</span>
<a name="l02276"></a>02276 <span class="comment">//! \tparam BlockSize external block size \a B in bytes, default: &lt;b&gt;2 MiB&lt;/b&gt;</span>
<a name="l02277"></a>02277 <span class="comment">//! \tparam AllocStr parallel disk allocation strategies: \c striping, RC, SR, or FR. default: \b RC.</span>
<a name="l02278"></a>02278 <span class="comment">//! \tparam Pager pager type: \c random or \c lru, default: \b lru.</span>
<a name="l02279"></a>02279 <span class="comment">//!</span>
<a name="l02280"></a>02280 <span class="comment">//! \warning Do not store references to the elements of an external vector. Such references</span>
<a name="l02281"></a>02281 <span class="comment">//! might be invalidated during any following access to elements of the vector</span>
<a name="l02282"></a>02282 <span class="comment"></span><span class="keyword">template</span> &lt;
<a name="l02283"></a>02283 <span class="keyword">typename</span> ValueType,
<a name="l02284"></a>02284 <span class="keywordtype">unsigned</span> PageSize = 4,
<a name="l02285"></a>02285 <span class="keywordtype">unsigned</span> CachePages = 8,
<a name="l02286"></a>02286 <span class="keywordtype">unsigned</span> BlockSize = STXXL_DEFAULT_BLOCK_SIZE(ValueType),
<a name="l02287"></a>02287 <span class="keyword">typename</span> AllocStr = STXXL_DEFAULT_ALLOC_STRATEGY,
<a name="l02288"></a>02288 stxxl::pager_type Pager = stxxl::lru
<a name="l02289"></a>02289 &gt;
<a name="l02290"></a><a class="code" href="structVECTOR__GENERATOR.html">02290</a> <span class="keyword">struct </span><a class="code" href="structVECTOR__GENERATOR.html" title="External vector type generator.">VECTOR_GENERATOR</a> {
<a name="l02291"></a>02291     <span class="keyword">typedef</span> <span class="keyword">typename</span> stxxl::IF&lt;Pager == stxxl::lru,
<a name="l02292"></a><a class="code" href="structVECTOR__GENERATOR.html#a9035e39f2b2830256072213351e2fdcc">02292</a>     stxxl::lru_pager&lt;CachePages&gt;, stxxl::random_pager&lt;CachePages&gt; &gt;<a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">::result</a> <a class="code" href="structVECTOR__GENERATOR.html#a9035e39f2b2830256072213351e2fdcc">PagerType</a>;
<a name="l02293"></a>02293 
<a name="l02294"></a><a class="code" href="structVECTOR__GENERATOR.html#a8948fb8e7364462b40029e1ec4bf7c7c">02294</a>     <span class="keyword">typedef</span> <a class="code" href="classvector.html" title="External vector container.   Introduction to vector container: see STXXL Vector tutorial.   Design and Internals of vector container: see Vector.">vector&lt;ValueType, PageSize, PagerType, BlockSize, AllocStr&gt;</a> <a class="code" href="structVECTOR__GENERATOR.html#a8948fb8e7364462b40029e1ec4bf7c7c">result</a>;
<a name="l02295"></a>02295 };
<a name="l02296"></a>02296 <span class="comment"></span>
<a name="l02297"></a>02297 <span class="comment">//! \}</span>
<a name="l02298"></a>02298 <span class="comment"></span>
<a name="l02299"></a>02299 <span class="comment">//namespace std {</span>
<a name="l02300"></a>02300 <span class="comment">//    template &lt;</span>
<a name="l02301"></a>02301 <span class="comment">//    typename ValueType,</span>
<a name="l02302"></a>02302 <span class="comment">//    unsigned PageSize,</span>
<a name="l02303"></a>02303 <span class="comment">//    typename PagerType,</span>
<a name="l02304"></a>02304 <span class="comment">//    unsigned BlockSize,</span>
<a name="l02305"></a>02305 <span class="comment">//    typename AllocStr,</span>
<a name="l02306"></a>02306 <span class="comment">//    typename SizeType&gt;</span>
<a name="l02307"></a>02307 <span class="comment">//    void swap(vector&lt;ValueType, PageSize, PagerType, BlockSize, AllocStr, SizeType&gt;&amp; a,</span>
<a name="l02308"></a>02308 <span class="comment">//            vector&lt;ValueType, PageSize, PagerType, BlockSize, AllocStr, SizeType&gt;&amp; b) {</span>
<a name="l02309"></a>02309 <span class="comment">//        a.swap(b);</span>
<a name="l02310"></a>02310 <span class="comment">//    }</span>
<a name="l02311"></a>02311 <span class="comment">//</span>
<a name="l02312"></a>02312 <span class="comment">//} // namespace std</span>
<a name="l02313"></a>02313 
<a name="l02314"></a>02314 <span class="preprocessor">#endif  </span><span class="comment">/* EXTSTXXLVECTOR_H */</span>
<a name="l02315"></a>02315 
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="ExtStxxlVector_8h.html">ExtStxxlVector.h</a>      </li>

    <li class="footer">Generated on Sat Jun 14 2014 01:55:17 for ExtLP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
