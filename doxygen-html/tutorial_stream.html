<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ExtLP: Tutorial for the Stream Package</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ExtLP
   &#160;<span id="projectnumber">1.0-dev</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('tutorial_stream.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial for the Stream Package </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="author"><dt><b>Author:</b></dt><dd>Timo Bingmann (2012-06-11)</dd></dl>
<p>This page gives a short introduction into the stream package. First the main abstractions are discussed and then some examples on how to utilize the existing algorithms are developed.</p>
<p>All example code can be found in <a class="el" href="examples_2stream_2stream1_8cpp-example.html">examples/stream/stream1::cpp</a></p>
<p>In <a class="el" href="tutorial_stream_edgesort.html">Generating Random Graphs using Streams</a> another example is given, where an existing algorithm is "pipelined".</p>
<h2><a class="anchor" id="stream1"></a>
Abstraction, Interface and a Simple Example</h2>
<p>The stream package is built around the abstract notion of an object being able to produce a sequence of output values. Only three simple operations are necessary:</p>
<ul>
<li>Retrieval of the current value: prefix <code>*</code> operator</li>
<li>Advance to the next value in the sequence: prefix <code>++</code> operator</li>
<li>Indication of the sequence's end: <code>empty()</code> function</li>
</ul>
<p>The most common place object that fits easily into this abstraction is the random generator. Actually, a random generator only requires two operations: it can be queried for its current value and be instructed to calculate/advance to new value. Of course the random sequence should be unbounded, so an <code>empty()</code> function would always be false. Nevertheless, this common-place example illustrates the purpose of the stream interface pretty well.</p>
<p>All stream objects must support the three operations above, they form the stream algorithm concept. In C++ a class conforms to this concept if it implements the following interface:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>stream_object
{
    <span class="comment">// Type of the values in the output sequence.</span>
    <span class="keyword">typedef</span> output_type value_type;

    <span class="comment">// Retrieval prefix * operator (like dereferencing a pointer or iterator).</span>
    <span class="keyword">const</span> value_type&amp; operator* () <span class="keyword">const</span>;

    <span class="comment">// Prefix increment ++ operator, which advances the stream to the next value.</span>
    stream_object&amp; operator++ ();

    <span class="comment">// Empty indicator. True if the last ++ operation could not fetch a value.</span>
    <span class="keywordtype">bool</span> empty() <span class="keyword">const</span>;
};
</pre></div><p>A very simple stream object that produces the sequence 1,2,3,4,....,1000 is shown in the following snippet:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>counter_object
{
    <span class="comment">// This stream produces a sequence of integers.</span>
    <span class="keyword">typedef</span> <span class="keywordtype">int</span>         value_type;

<span class="keyword">private</span>:
    <span class="comment">// A class attribute to save the current value.</span>
    <span class="keywordtype">int</span>                 m_current_value;

<span class="keyword">public</span>:
    <span class="comment">// A constructor to set the initial value to 1.</span>
    counter_object()
        : m_current_value(1)
    {
    }

    <span class="comment">// The retrieve operator returning the current value.</span>
    <span class="keyword">const</span> value_type&amp; operator* ()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> m_current_value;
    }

    <span class="comment">// Increment operator advancing to the next integer.</span>
    counter_object&amp; operator++ ()
    {
        ++m_current_value;
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }

    <span class="comment">// Empty indicator, which in this case can check the current value.</span>
    <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> (m_current_value &gt; 1000);
    }
};
</pre></div><p>After this verbose interface definition, the actual iteration over a stream object can be done as follows:</p>
<div class="fragment"><pre class="fragment">counter_object counter;

<span class="keywordflow">while</span> (!counter.empty())
{
    std::cout &lt;&lt; *counter &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
    ++counter;
}
std::cout &lt;&lt; std::endl;
</pre></div><p>For those who like to shorten everything into fewer lines, the above can also be expressed as a for loop:</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> (counter_object cnt; !cnt.empty(); ++cnt)
{
    std::cout &lt;&lt; *cnt &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
}
std::cout &lt;&lt; std::endl;
</pre></div><p>Both loops will print the following output: </p>
<div class="fragment"><pre class="fragment">
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [...] 995 996 997 998 999 1000
</pre></div><h2><a class="anchor" id="stream2"></a>
Pipelining: Plugging Stream Objects Together</h2>
<p>The stream interface is so very useful for external memory algorithms because it represents the concept of sequential access to a stream of individual values. While the simple example above only works with integers, the <code>value_type</code> of streams will more often contain complex tuple structs with multiple components.</p>
<p>A stream algorithm can then be constructed from multiple stream objects that pass data from one to another. This notion of "plugging together" stream objects is used in the following example to calculate the square of each value of an integer sequence:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputStream&gt;
<span class="keyword">struct </span>squaring_object
{
    <span class="comment">// This stream produces a sequence of integers.</span>
    <span class="keyword">typedef</span> <span class="keywordtype">int</span>         value_type;

<span class="keyword">private</span>:
    <span class="comment">// A reference to another stream of integers, which are our input.</span>
    InputStream&amp;        m_input_stream;

    <span class="comment">// A temporary value buffer to hold the current square for retrieval.</span>
    value_type          m_current_value;

<span class="keyword">public</span>:
    <span class="comment">// A constructor taking another stream of integers as input.</span>
    squaring_object(InputStream&amp; input_stream)
        : m_input_stream(input_stream)
    {
        <span class="keywordflow">if</span> (!m_input_stream.empty())
        {
            m_current_value = *m_input_stream;
            m_current_value = m_current_value * m_current_value;
        }
    }

    <span class="comment">// The retrieve operator returning the square of the input stream.</span>
    <span class="keyword">const</span> value_type&amp; operator* ()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> m_current_value;
    }

    <span class="comment">// Increment operator: handled by incrementing the input stream.</span>
    squaring_object&amp; operator++ ()
    {
        ++m_input_stream;
        <span class="keywordflow">if</span> (!m_input_stream.empty())
        {
            m_current_value = *m_input_stream;
            m_current_value = m_current_value * m_current_value;
        }
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }

    <span class="comment">// Empty indicator: this stream is empty when the input stream is.</span>
    <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> m_input_stream.empty();
    }
};
</pre></div><p>For a beginner in stream object programming, the squaring example contains multiple unexpected, verbose complications.</p>
<ul>
<li>We wish to allow many different integer sequences as input streams to the squaring class. For this we use template meta-programming and define squaring to take any class as <code>InputStream</code> template parameter. As yet, in C++ we cannot syntactically define which concepts the template parameters must fulfill, in this case one would require <code>InputStream</code> to implement the stream interface.</li>
</ul>
<ul>
<li>After defining the input stream class, one will usually need an instantiated object of that class inside the new stream class. Most common practice is to define references to other streams as class attributes, and have the actual objects be passed to the constructor of the new stream object. <br/>
 In the case of the squaring class, any <code>InputStream</code> object is accepted by the constructor and a reference is saved into <code>m_input_stream</code>.</li>
</ul>
<ul>
<li>As second attribute, the squaring class contains m_current_value. The additional temporary value is required in this case because <code>operator*()</code> must return a const-reference, so the square must actually be stored in a variable after it is calculated. Now note that the squaring operation in this version is implemented at two places: in the constructor and the <code>operator++()</code>. <br/>
 This is necessary, because the stream concept requires that the first value be <em>immediately available after construction</em>! Therefore it must be calculated in the constructor, and this code is usually a duplicate to the action done in <code>operator++()</code>. A real implementation would probably combine the calculation code into a <code>process()</code> function and also do additional allocation work in the constructor.</li>
</ul>
<p>An instance of the <code>counter_object</code> can be plugged into a <code>squaring_object</code> as done in the following example:</p>
<div class="fragment"><pre class="fragment">counter_object counter;
squaring_object&lt;counter_object&gt; squares(counter);

<span class="keywordflow">while</span> (!squares.empty())
{
    std::cout &lt;&lt; *squares &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
    ++squares;
}
std::cout &lt;&lt; std::endl;
</pre></div><p>The example outputs:</p>
<div class="fragment"><pre class="fragment">
1 4 9 16 25 36 49 64 81 100 121 144 169 [...] 986049 988036 990025 992016 994009 996004 998001 1000000
</pre></div><h2><a class="anchor" id="stream3"></a>
Miscellaneous Utilities Provided by the Stream Package</h2>
<p>The above examples are pure C++ interface manipulations and do not even require STXXL. However, when writing stream algorithms you can take advantage of the utilities provided by the stream package to create complex algorithms. Probably the most useful is the pair of sorting classes, which will be discussed after a few preliminaries.</p>
<p>More complex algorithms will most often use tuples as values passed from one stream to another. These tuples wrap all information fields of a specific piece of data. Simple tuples can be created using <code>std::pair</code>, tuples with larger number of components can use Boost.Tuple or just plain structs with multiple fields. (In the tuple case, the temporary value inside the stream struct can mostly be avoided.)</p>
<p>The stream package contains utilities to plug stream classes together to form complex algorithms. The following few examples are very basic algorithms:</p>
<p>Very often the input to a sequence of stream classes comes from an array or other container. In this case one requires an input stream object, which iterates through the container and outputs each element once. STXXL provides iterator2stream for this common purpose: </p>
<div class="fragment"><pre class="fragment">std::vector&lt;int&gt; intvector;
<span class="comment">// (fill intvector)</span>

<span class="comment">// define stream class iterating over an integer vector</span>
<span class="keyword">typedef</span> stxxl::stream::iterator2stream&lt; std::vector&lt;int&gt;::const_iterator &gt; intstream_type;

<span class="comment">// instantiate the stream object, iterate from begin to end of intvector.</span>
intstream_type intstream (intvector.begin(), intvector.end());

<span class="comment">// plug in squaring object after vector iterator stream.</span>
squaring_object&lt;intstream_type&gt; squares(intstream);
</pre></div><p>Most important: if the input container is a stxxl::vector, then one should use vector_iterator2stream, because this class will prefetch additional blocks from the vector while processing the stream. </p>
<div class="fragment"><pre class="fragment">stxxl::vector&lt;int&gt; intvector;
<span class="comment">// (fill intvector)</span>

<span class="comment">// define stream class iterating over an integer STXXL vector</span>
<span class="keyword">typedef</span> stxxl::stream::vector_iterator2stream&lt; stxxl::vector&lt;int&gt;::const_iterator &gt; intstream_type;

<span class="comment">// instantiate the stream object, iterate from begin to end of intvector using prefetching</span>
intstream_type intstream (intvector.begin(), intvector.end());

<span class="comment">// plug in squaring object after vector iterator stream.</span>
squaring_object&lt;intstream_type&gt; squares(intstream);
</pre></div><p>The opposite to iterator2stream is to collect the output of a sequence of stream objects into a container or stxxl::vector. This operation is called <code>materialize</code> and also comes in the general version and a special version for the STXXL-vector, which uses asynchronous writes.</p>
<p>This example shows how to materialize a stream into a usual STL vector. </p>
<div class="fragment"><pre class="fragment"><span class="comment">// construct the squared counter stream</span>
counter_object counter;
squaring_object&lt;counter_object&gt; squares(counter);

<span class="comment">// allocate vector of 100 integers</span>
std::vector&lt;int&gt; intvector (100);

<span class="comment">// materialize 100 integers from stream and put into vector</span>
stxxl::stream::materialize(squares, intvector.begin(), intvector.end());
</pre></div><p>And the only modification needed to support larger data sets is to materialize to an STXXL vector: </p>
<div class="fragment"><pre class="fragment"><span class="comment">// construct the squared counter stream</span>
counter_object counter;
squaring_object&lt;counter_object&gt; squares(counter);

<span class="comment">// allocate STXXL vector of 100 integers</span>
stxxl::vector&lt;int&gt; intvector (100);

<span class="comment">// materialize 100 integers from stream and put into STXXL vector</span>
stxxl::stream::materialize(squares, intvector.begin(), intvector.end());
</pre></div><h2><a class="anchor" id="stream4"></a>
Sorting As Provided by the Stream Package</h2>
<p>Maybe the most important set of tools in the stream package is the pairs of sorter classes runs_creator and runs_merger. The general way to sort a sequential input stream is to first consolidate a large number of input items in an internal memory buffer. Then when the buffer is full, it can be sorted in internal memory and subsequently written out to disk. This sorted sequence is then called a run. When the input stream is finished and the sorted output must be produced, theses sorted sequences can efficiently be merged using a tournament tree or similar multi-way comparison structure. (see <a class="el" href="design_algo_sorting.html">Parallel Disk Sorting</a>.)</p>
<p>STXXL implements this using two stream classes: runs_creator and runs_merger.</p>
<p>The following examples shows how to sort the integer sequence 1,2,...,1000 first by the right-most decimal digit, then by its absolute value (yes a somewhat constructed example, but it serves its purpose well.) For all sorters a comparator object is required which tells the sorter which of two objects is the smaller one. This is similar to the requirements of the usual STL, however, the STXXL sorters need to additional functions: <code>min_value()</code> and <code>max_value()</code> which are used as padding sentinels. These functions return the smallest and highest possible values of the given data type. </p>
<div class="fragment"><pre class="fragment"><span class="comment">// define comparator class: compare right-most decimal and then absolute value</span>
<span class="keyword">struct </span>CompareMod10
{
    <span class="comment">// comparison operator() returning true if (a &lt; b)</span>
    <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator() (<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">if</span> ((a % 10) == (b % 10))
            <span class="keywordflow">return</span> a &lt; b;
        <span class="keywordflow">else</span>
            <span class="keywordflow">return</span> (a % 10) &lt; (b % 10);
    }

    <span class="comment">// smallest possible integer value</span>
    <span class="keywordtype">int</span> min_value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> INT_MIN; }
    <span class="comment">// largest possible integer value</span>
    <span class="keywordtype">int</span> max_value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> INT_MAX; }
};
</pre></div><p>All sorters steps require an internal memory buffer. This size can be fixed using a parameter to runs_creator and runs_merger. The following example code instantiates a counter object, plugs this into a runs_creator which is followed by a runs_merger.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> ram_use = 10*1024*1024;   <span class="comment">// amount of memory to use in runs creation</span>

counter_object  counter;        <span class="comment">// the counter stream from first examples</span>

<span class="comment">// define a runs sorter for the counter stream which order by CompareMod10 object.</span>
<span class="keyword">typedef</span> stxxl::stream::runs_creator&lt;counter_object, CompareMod10&gt; rc_counter_type;

<span class="comment">// instance of CompareMod10 comparator class</span>
CompareMod10    comparemod10;

<span class="comment">// instance of runs_creator which reads the counter stream.</span>
rc_counter_type rc_counter (counter, comparemod10, ram_use);

<span class="comment">// define a runs merger for the sorted runs from rc_counter.</span>
<span class="keyword">typedef</span> stxxl::stream::runs_merger&lt;rc_counter_type::sorted_runs_type, CompareMod10&gt; rm_counter_type;

<span class="comment">// instance of runs_merger which merges sorted runs from rc_counter.</span>
rm_counter_type rm_counter (rc_counter.result(), comparemod10, ram_use);

<span class="comment">// read sorted stream: runs_merger also conforms to the stream interface.</span>
<span class="keywordflow">while</span> (!rm_counter.empty())
{
    std::cout &lt;&lt; *rm_counter &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
    ++rm_counter;
}
std::cout &lt;&lt; std::endl;
</pre></div><p> The output of the code above is: </p>
<div class="fragment"><pre class="fragment">
10 20 30 40 50 60 70 80 [...] 990 1000 1 11 21 31 41 51 61 [...] 909 919 929 939 949 959 969 979 989 999
</pre></div><p>Note that in the above example the input of the runs_creator is itself a stream. If however the data is not naturally available as a stream, one can use a variant of runs_creator which accepts input via a <code>push()</code> function. This is more useful when using an imperative programming style. Note that the runs_merger does not change. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> ram_use = 10*1024*1024;   <span class="comment">// amount of memory to use in runs creation</span>

<span class="comment">// define a runs sorter which accepts imperative push()s and orders by CompareMod10 object.</span>
<span class="keyword">typedef</span> stxxl::stream::runs_creator&lt;stxxl::stream::use_push&lt;int&gt;, CompareMod10&gt; rc_counter_type;

<span class="comment">// instance of CompareMod10 comparator class.</span>
CompareMod10    comparemod10;

<span class="comment">// instance of runs_creator which waits for input.</span>
rc_counter_type rc_counter (comparemod10, ram_use);

<span class="comment">// write sequence of integers into runs</span>
<span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= 1000; ++i)
    rc_counter.push(i);

<span class="comment">// define a runs merger for the sorted runs from rc_counter.</span>
<span class="keyword">typedef</span> stxxl::stream::runs_merger&lt;rc_counter_type::sorted_runs_type, CompareMod10&gt; rm_counter_type;

<span class="comment">// instance of runs_merger which merges sorted runs from rc_counter.</span>
rm_counter_type rm_counter (rc_counter.result(), comparemod10, ram_use);

<span class="comment">// read sorted stream: runs_merger also conforms to the stream interface.</span>
<span class="keywordflow">while</span> (!rm_counter.empty())
{
    std::cout &lt;&lt; *rm_counter &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
    ++rm_counter;
}
std::cout &lt;&lt; std::endl;
</pre></div><p>And as the last example in this tutorial we show how to use stxxl::sorter, which combines runs_creator and runs_merger into one object. The sorter has two states: input and output. During input, new elements can be sorted using <code>push()</code>. Then to switch to output state, the function <code>sort()</code> is called, after which the sorter can be queried using the usual stream interface. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> ram_use = 10*1024*1024;   <span class="comment">// amount of memory to use in runs creation</span>

<span class="comment">// define a runs sorter which accepts imperative push()s and orders by CompareMod10 object.</span>
<span class="keyword">typedef</span> stxxl::sorter&lt;int, CompareMod10&gt; sr_counter_type;

<span class="comment">// instance of CompareMod10 comparator class.</span>
CompareMod10    comparemod10;

<span class="comment">// instance of sorter which waits for input.</span>
sr_counter_type sr_counter (comparemod10, ram_use);

<span class="comment">// write sequence of integers into sorter, which creates sorted runs</span>
<span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= 1000; ++i)
    sr_counter.push(i);

<span class="comment">// signal sorter that the input stream is finished and switch to output mode.</span>
sr_counter.sort();

<span class="comment">// read sorted stream: sorter also conforms to the stream interface.</span>
<span class="keywordflow">while</span> (!sr_counter.empty())
{
    std::cout &lt;&lt; *sr_counter &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
    ++sr_counter;
}
std::cout &lt;&lt; std::endl;
</pre></div><p>All three examples have the same output. </p>
</div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="tutorial.html">Tutorials and Examples</a>      </li>

    <li class="footer">Generated on Sat Jun 14 2014 01:55:17 for ExtLP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
