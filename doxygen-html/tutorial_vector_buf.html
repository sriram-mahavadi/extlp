<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ExtLP: Efficient Sequential Reading and Writing to Vectors</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ExtLP
   &#160;<span id="projectnumber">1.0-dev</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('tutorial_vector_buf.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Efficient Sequential Reading and Writing to Vectors </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="author"><dt><b>Author:</b></dt><dd>Timo Bingmann (2013)</dd></dl>
<p>The stxxl::vector is a very versatile container and it allows sequential access loops like the following:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> stxxl::VECTOR_GENERATOR&lt;uint64&gt;::result vector_type;

    vector_type vec(size);

    <span class="keywordflow">for</span> (uint64 i = 0; i &lt; vec.size(); ++i)
        vec[i] = (i % 1024);

    uint64 sum = 0;
    <span class="keywordflow">for</span> (uint64 i = 0; i &lt; vec.size(); ++i)
        sum += vec[i];
</pre></div><p> However, these sequential loops using element access are <b>not very efficient</b> (see the experimental results below). Each <code>operator</code>[] is processed by the vector paging mechanism, and returns a writeable reference to the element. Because the reference might be modified, the vector must assume that the accessed page is dirty. Thus the read loop will actually rewrite the whole vector.</p>
<p>This effect can be avoided using a <code>const vector&amp;</code> or <a class="el" href="classvector.html#aa4028dfad10b3ba6322ed5ad588f2713" title="constant iterator used to iterate through a vector, see More Notes.">vector::const_iterator</a> as shown in the following:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> stxxl::VECTOR_GENERATOR&lt;uint64&gt;::result vector_type;

    vector_type vec(size);

    uint64 i = 0;
    <span class="keywordflow">for</span> (vector_type::iterator it = vec.begin(); it != vec.end(); ++it, ++i)
        *it = (i % 1024);

    uint64 sum = 0;
    <span class="keywordflow">for</span> (vector_type::const_iterator it = vec.begin(); it != vec.end(); ++it)
        sum += *it;
</pre></div><p> This method is already pretty good, but one can achieve even better performance. The problem with iterators is that all accesses still go through the vector's paging algorithms, possibly updating the internal paging algorithm's state. More importantly, the access operators do not use prefetching. For this purpose STXXL provides buffered reading and writing to vector ranges. These utilized asynchronous I/O and will thus <b>will overlap I/O with computation</b>.</p>
<p>The two basic classes to efficiently read and write vector are <a class="el" href="classvector__bufreader.html" title="Buffered sequential reader from a vector using overlapped I/O.">vector_bufreader</a> and <a class="el" href="classvector__bufwriter.html" title="Buffered sequential writer to a vector using overlapped I/O.">vector_bufwriter</a>. Their interface is a combination of the <code>stream</code> interface and iostreams. The two classes are more conveniently accessible via <a class="el" href="classvector.html#a73bc2a4348cf178fe4488ca83d0e6d1f" title="vector_bufreader compatible with this vector">vector::bufreader_type</a> and <a class="el" href="classvector.html#a17b303d6362a1197b4cb039ce73015cd" title="vector_bufwriter compatible with this vector">vector::bufwriter_type</a>.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> stxxl::VECTOR_GENERATOR&lt;uint64&gt;::result vector_type;

    vector_type vec(size);

    <span class="comment">// write using vector_bufwriter</span>
    vector_type::bufwriter_type writer(vec);

    <span class="keywordflow">for</span> (uint64 i = 0; i &lt; vec.size(); ++i)
        writer &lt;&lt; (i % 1024);

    <span class="comment">// required to flush out the last block (or destruct the bufwriter)</span>
    writer.finish();

    <span class="comment">// now read using vector_bufreader</span>
    uint64 sum = 0;

    <span class="keywordflow">for</span> (vector_type::bufreader_type reader(vec); !reader.empty(); ++reader)
    {
        sum += *reader;
    }
</pre></div><p> When using <a class="el" href="classvector__bufwriter.html" title="Buffered sequential writer to a vector using overlapped I/O.">vector_bufwriter</a> the vector's size <em>should</em> be allocated in advance. However, this is not required: when reaching the end of the vector, the buffered writer will automatically double the vector's size. Thus writing will not produce segfaults; however, doubling may go wrong for huge vectors.</p>
<p>Note that the same efficiency can be achieved using stream functions: stream::vector_iterator2stream and stream::materialize also use overlapping I/O.</p>
<p>As last method, which is currently supported by STXXL, one can iterate over the vector using C++11's <code>auto</code> <code>for</code> loop construct:</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// now using vector_bufreader adaptor to C++11 for loop</span>
    uint64 sum = 0;

    <span class="keywordflow">for</span> (<span class="keyword">auto</span> it : vector_type::bufreader_type(vec))
    {
        sum += it;
    }
</pre></div><p> Note that we must construct a buffered reader explicitly, because just stating <code>"vec"</code> would amount to using the usual iterators (with pager). Support for C++11 is still experimental.</p>
<p>All source code from this example is available in <a class="el" href="examples_2containers_2vector_buf_8cpp-example.html">examples/containers/vector_buf::cpp</a>. The program also check the sum results and measures the time.</p>
<p>The following experimental results are from a machine with four disks: </p>
<div class="fragment"><pre class="fragment">
$ vector_buf 64
[STXXL-MSG] STXXL v1.4.0 (prerelease)
[STXXL-MSG] Disk '/data01/stxxl' is allocated, space: 162124 MiB, I/O implementation: syscall_unlink
[STXXL-MSG] Disk '/data02/stxxl' is allocated, space: 228881 MiB, I/O implementation: syscall_unlink
[STXXL-MSG] Disk '/data03/stxxl' is allocated, space: 228881 MiB, I/O implementation: syscall_unlink
[STXXL-MSG] Disk '/data04/stxxl' is allocated, space: 228881 MiB, I/O implementation: syscall_unlink
[STXXL-MSG] In total 4 disks are allocated, space: 848770 MiB
[STXXL-MSG] Starting vector element access
sum: 4393751543808
[STXXL-MSG] Finished vector element access after 848.695 seconds. Processed 128.000 GiB @ 154.439 MiB/s
[STXXL-MSG] Starting vector iterator access
sum: 4393751543808
[STXXL-MSG] Finished vector iterator access after 540.938 seconds. Processed 128.000 GiB @ 242.305 MiB/s
[STXXL-MSG] Starting vector buffered access
sum: 4393751543808
[STXXL-MSG] Finished vector buffered access after 441.26 seconds. Processed 128.000 GiB @ 297.040 MiB/s
[STXXL-MSG] Starting vector C++11 loop access
sum: 4393751543808
[STXXL-MSG] Finished vector C++11 loop access after 440.977 seconds. Processed 128.000 GiB @ 297.231 MiB/s
</pre></div><p>Obviously, buffered access to stxxl::vector most efficient, where using const_iterators is only 18% slower. Just using element access via operator[] is not a good idea.</p>
<p>The difference between the methods grows smaller then using only one disk, because the I/O bandwidth decreases: </p>
<div class="fragment"><pre class="fragment">
$ vector_buf 64
[STXXL-MSG] STXXL v1.4.0 (prerelease)
[STXXL-MSG] Disk '/data01/stxxl' is allocated, space: 162124 MiB, I/O implementation: syscall_unlink
[STXXL-MSG] Starting vector element access
sum: 4393751543808
[STXXL-MSG] Finished vector element access after 2793.85 seconds. Processed 128.000 GiB @ 46.915 MiB/s
[STXXL-MSG] Starting vector iterator access
sum: 4393751543808
[STXXL-MSG] Finished vector iterator access after 1770.75 seconds. Processed 128.000 GiB @ 74.020 MiB/s
[STXXL-MSG] Starting vector buffered access
sum: 4393751543808
[STXXL-MSG] Finished vector buffered access after 1670.13 seconds. Processed 128.000 GiB @ 78.480 MiB/s
[STXXL-MSG] Starting vector C++11 loop access
sum: 4393751543808
[STXXL-MSG] Finished vector C++11 loop access after 1671.53 seconds. Processed 128.000 GiB @ 78.415 MiB/s
</pre></div><p>As a last note: there is also <a class="el" href="classvector__bufreader__reverse.html" title="Buffered sequential reverse reader from a vector using overlapped I/O.">vector_bufreader_reverse</a> and <a class="el" href="classvector.html#a4407beb443590b73160c2c25e9f204e3" title="vector_bufreader compatible with this vector">vector::bufreader_reverse_type</a> for buffered reading in reverse. </p>
</div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="tutorial.html">Tutorials and Examples</a>      </li>

    <li class="footer">Generated on Sat Jun 14 2014 01:55:17 for ExtLP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
