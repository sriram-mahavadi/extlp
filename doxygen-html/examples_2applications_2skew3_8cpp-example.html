<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ExtLP: examples/applications/skew3.cpp</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ExtLP
   &#160;<span id="projectnumber">1.0-dev</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('examples_2applications_2skew3_8cpp-example.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">examples/applications/skew3.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><span class="comment">/***************************************************************************</span>
<span class="comment"> *  examples/applications/skew3.cpp</span>
<span class="comment"> *</span>
<span class="comment"> *  Implementation of the external memory suffix sorting algorithm DC3 aka</span>
<span class="comment"> *  skew3 as described in Roman Dementiev, Juha Kaerkkaeinen, Jens Mehnert and</span>
<span class="comment"> *  Peter Sanders. &quot;Better External Memory Suffix Array Construction&quot;. Journal</span>
<span class="comment"> *  of Experimental Algorithmics (JEA), volume 12, 2008.</span>
<span class="comment"> *</span>
<span class="comment"> *  Part of the STXXL. See http://stxxl.sourceforge.net</span>
<span class="comment"> *</span>
<span class="comment"> *  Copyright (C) 2004 Jens Mehnert &lt;jmehnert@mpi-sb.mpg.de&gt;</span>
<span class="comment"> *  Copyright (C) 2012-2013 Timo Bingmann &lt;tb@panthema.net&gt;</span>
<span class="comment"> *  Copyright (C) 2012-2013 Daniel Feist &lt;daniel.feist@student.kit.edu&gt;</span>
<span class="comment"> *</span>
<span class="comment"> *  Distributed under the Boost Software License, Version 1.0.</span>
<span class="comment"> *  (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="comment"> *  http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="comment"> **************************************************************************/</span>

<span class="preprocessor">#include &lt;algorithm&gt;</span>
<span class="preprocessor">#include &lt;cassert&gt;</span>
<span class="preprocessor">#include &lt;cctype&gt;</span>
<span class="preprocessor">#include &lt;cstddef&gt;</span>
<span class="preprocessor">#include &lt;cstdlib&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;limits&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>

<span class="preprocessor">#include &lt;stxxl/algorithm&gt;</span>
<span class="preprocessor">#include &lt;stxxl/cmdline&gt;</span>
<span class="preprocessor">#include &lt;stxxl/io&gt;</span>
<span class="preprocessor">#include &lt;stxxl/random&gt;</span>
<span class="preprocessor">#include &lt;stxxl/sorter&gt;</span>
<span class="preprocessor">#include &lt;stxxl/stats&gt;</span>
<span class="preprocessor">#include &lt;stxxl/stream&gt;</span>
<span class="preprocessor">#include &lt;stxxl/vector&gt;</span>
<span class="preprocessor">#include &lt;stxxl/bits/common/uint_types.h&gt;</span>

<span class="keyword">using</span> stxxl::uint64;
<span class="keyword">using</span> stxxl::external_size_type;
<span class="keyword">namespace </span>stream = stxxl::stream;

<span class="comment">// 1 GiB ram used by external data structures / 1 MiB block size</span>
uint64 ram_use = 1024 * 1024 * 1024;

<span class="comment">// alphabet data type</span>
<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> alphabet_type;

<span class="comment">// calculation data type</span>
<span class="keyword">typedef</span> external_size_type size_type;
<span class="comment"></span>
<span class="comment">/// Suffix Array checker for correctness verification</span>
<span class="comment"></span><span class="comment"></span>
<span class="comment">/**</span>
<span class="comment"> * Algorithm to check whether the suffix array is correct. Loosely based on the</span>
<span class="comment"> * ideas of Kaerkkaeinen und Burghardt, originally implemented in STXXL by Jens</span>
<span class="comment"> * Mehnert (2004), reimplemented using triples by Timo Bingmann (2012).</span>
<span class="comment"> *</span>
<span class="comment"> * @param InputT is the original text, from which the suffix array was build</span>
<span class="comment"> * @param InputSA is the suffix array from InputT</span>
<span class="comment"> *</span>
<span class="comment"> * Note: ISA := The inverse of SA</span>
<span class="comment"> */</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputT, <span class="keyword">typename</span> InputSA&gt;
<span class="keywordtype">bool</span> sacheck(InputT&amp; inputT, InputSA&amp; inputSA)
{
    <span class="keyword">typedef</span> <span class="keyword">typename</span> InputSA::value_type offset_type;
    <span class="keyword">typedef</span> stxxl::tuple&lt;offset_type, offset_type&gt; pair_type;
    <span class="keyword">typedef</span> stxxl::tuple&lt;offset_type, offset_type, offset_type&gt; triple_type;

    <span class="comment">// *** Pipeline Declaration ***</span>

    <span class="comment">// Build tuples with index: (SA[i]) -&gt; (i, SA[i])</span>
    <span class="keyword">typedef</span> stxxl::stream::counter&lt;offset_type&gt; index_counter_type;
    index_counter_type index_counter;

    <span class="keyword">typedef</span> stream::make_tuple&lt;index_counter_type, InputSA&gt; tuple_index_sa_type;
    tuple_index_sa_type tuple_index_sa(index_counter, inputSA);

    <span class="comment">// take (i, SA[i]) and sort to (ISA[i], i)</span>
    <span class="keyword">typedef</span> stxxl::tuple_less2nd&lt;pair_type&gt; pair_less_type;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::sort&lt;tuple_index_sa_type, pair_less_type&gt; build_isa_type;

    build_isa_type build_isa(tuple_index_sa, pair_less_type(), ram_use / 3);

    <span class="comment">// build (ISA[i], T[i], ISA[i+1]) and sort to (i, T[SA[i]], ISA[SA[i]+1])</span>
    <span class="keyword">typedef</span> stxxl::tuple_less1st&lt;triple_type&gt; triple_less_type;      <span class="comment">// comparison relation</span>

    <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::use_push&lt;triple_type&gt; triple_push_type; <span class="comment">// indicator use push()</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_creator&lt;triple_push_type, triple_less_type&gt; triple_rc_type;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_merger&lt;typename triple_rc_type::sorted_runs_type, triple_less_type&gt; triple_rm_type;

    triple_rc_type triple_rc(triple_less_type(), ram_use / 3);

    <span class="comment">// ************************* Process ******************************</span>
    <span class="comment">// loop 1: read ISA and check for a permutation. Simultaneously create runs</span>
    <span class="comment">// of triples by iterating ISA and T.</span>

    size_type totalSize;
    {
        offset_type prev_isa = (*build_isa).first;
        offset_type counter = 0;
        <span class="keywordflow">while</span> (!build_isa.empty())
        {
            <span class="keywordflow">if</span> ((*build_isa).second != counter) {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Error: suffix array is not a permutation of 0..n-1.&quot;</span> &lt;&lt; std::endl;
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
            }

            ++counter;
            ++build_isa; <span class="comment">// ISA is one in front of T</span>

            <span class="keywordflow">if</span> (!build_isa.empty()) {
                triple_rc.push(triple_type(prev_isa, *inputT, (*build_isa).first));
                prev_isa = (*build_isa).first;
            }
            ++inputT;
        }

        totalSize = counter;
    }

    <span class="keywordflow">if</span> (totalSize == 1) <span class="keywordflow">return</span> <span class="keyword">true</span>;

    <span class="comment">// ************************************************************************</span>
    <span class="comment">// loop 2: read triples (i,T[SA[i]],ISA[SA[i]+1]) and check for correct</span>
    <span class="comment">// ordering.</span>

    triple_rm_type triple_rm(triple_rc.result(), triple_less_type(), ram_use / 3);

    {
        triple_type prev_triple = *triple_rm;
        size_type counter = 0;

        ++triple_rm;

        <span class="keywordflow">while</span> (!triple_rm.empty())
        {
            <span class="keyword">const</span> triple_type&amp; this_triple = *triple_rm;

            <span class="keywordflow">if</span> (prev_triple.second &gt; this_triple.second)
            {
                <span class="comment">// simple check of first character of suffix</span>
                std::cout &lt;&lt; <span class="stringliteral">&quot;Error: suffix array position &quot;</span> &lt;&lt; counter &lt;&lt; <span class="stringliteral">&quot; ordered incorrectly.&quot;</span> &lt;&lt; std::endl;
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
            }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (prev_triple.second == this_triple.second)
            {
                <span class="keywordflow">if</span> (this_triple.third == (offset_type)totalSize) {
                    <span class="comment">// last suffix of string must be first among those with same</span>
                    <span class="comment">// first character</span>
                    std::cout &lt;&lt; <span class="stringliteral">&quot;Error: suffix array position &quot;</span> &lt;&lt; counter &lt;&lt; <span class="stringliteral">&quot; ordered incorrectly.&quot;</span> &lt;&lt; std::endl;
                    <span class="keywordflow">return</span> <span class="keyword">false</span>;
                }
                <span class="keywordflow">if</span> (prev_triple.third != (offset_type)totalSize &amp;&amp; prev_triple.third &gt; this_triple.third) {
                    <span class="comment">// positions SA[i] and SA[i-1] has same first character but</span>
                    <span class="comment">// their suffixes are ordered incorrectly: the suffix</span>
                    <span class="comment">// position of SA[i] is given by ISA[SA[i]]</span>
                    std::cout &lt;&lt; <span class="stringliteral">&quot;Error: suffix array position &quot;</span> &lt;&lt; counter &lt;&lt; <span class="stringliteral">&quot; ordered incorrectly.&quot;</span> &lt;&lt; std::endl;
                    <span class="keywordflow">return</span> <span class="keyword">false</span>;
                }
            }

            prev_triple = this_triple;

            ++triple_rm;
            ++counter;
        }
    }
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputT, <span class="keyword">typename</span> InputSA&gt;
<span class="keywordtype">bool</span> sacheck_vectors(InputT&amp; inputT, InputSA&amp; inputSA)
{
    <span class="keyword">typename</span> stream::streamify_traits&lt;typename InputT::iterator&gt;::stream_type streamT
        = stream::streamify(inputT.begin(), inputT.end());

    <span class="keyword">typename</span> stream::streamify_traits&lt;typename InputSA::iterator&gt;::stream_type streamSA
        = stream::streamify(inputSA.begin(), inputSA.end());

    <span class="keywordflow">return</span> sacheck(streamT, streamSA);
}
<span class="comment"></span>
<span class="comment">/// DC3 aka skew algorithm</span>
<span class="comment"></span>
<span class="comment">/*</span>
<span class="comment"> * DC3 aka skew algorithm a short description. T := input string</span>
<span class="comment"> * The recursion works as follows:</span>
<span class="comment"> * Step 1: a) pick all mod1/mod2 triples (i.e. triples T[i,i+2] at position i mod 3 != 0) (-&gt; extract_mod12 class)</span>
<span class="comment"> *         b) sort mod1/mod2 triples lexicographically (-&gt; build_sa class)</span>
<span class="comment"> *         c) give mod1/mod2 triples lexicographical ascending names n (-&gt; naming class)</span>
<span class="comment"> *         d) check lexicographical names for uniqueness (-&gt; naming class)</span>
<span class="comment"> *            If yes: proceed to next Step, If no: set T := lexicographical names and run Step 1 again</span>
<span class="comment"> * Step 2: a) by sorting the lexicographical names n we receive ranks r</span>
<span class="comment"> *         b) construct mod0-quints, mod1-quads and mod2-quints  (-&gt; build_sa class)</span>
<span class="comment"> *         c) prepare for merging by:</span>
<span class="comment"> *            sort mod0-quints by 2 components, sort mod1-quads / mod2-quints by one component (-&gt; build_sa class)</span>
<span class="comment"> *         c) merge mod0-quints, mod1-quads and mod2-quints (-&gt; merge_sa class)</span>
<span class="comment"> * Step 3: a) return Suffix Array of T</span>
<span class="comment"> *</span>
<span class="comment"> * @param offset_type later suffix array data type</span>
<span class="comment"> */</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> offset_type&gt;
<span class="keyword">class </span>skew
{
<span class="keyword">public</span>:
    <span class="comment">// 2-tuple, 3-tuple, 4-tuple (=quads), 5-tuple(=quints) definition</span>
    <span class="keyword">typedef</span> stxxl::tuple&lt;offset_type, offset_type&gt; skew_pair_type;
    <span class="keyword">typedef</span> stxxl::tuple&lt;offset_type, offset_type, offset_type&gt; skew_triple_type;
    <span class="keyword">typedef</span> stxxl::tuple&lt;offset_type, offset_type, offset_type, offset_type&gt; skew_quad_type;
    <span class="keyword">typedef</span> stxxl::tuple&lt;offset_type, offset_type, offset_type, offset_type, offset_type&gt; skew_quint_type;

    <span class="keyword">typedef</span> <span class="keyword">typename</span> stxxl::VECTOR_GENERATOR&lt;offset_type, 1, 2&gt;::result offset_array_type;
    <span class="keyword">typedef</span> stream::vector_iterator2stream&lt;typename offset_array_type::iterator&gt; offset_array_it_rg;
<span class="comment"></span>
<span class="comment">    /** Comparison function for the mod0 tuples. */</span>
    <span class="keyword">struct </span>less_mod0
    {
        <span class="keyword">typedef</span> skew_quint_type value_type;

        <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> value_type&amp; a, <span class="keyword">const</span> value_type&amp; b)<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">if</span> (a.second == b.second)
                <span class="keywordflow">return</span> a.fourth &lt; b.fourth;
            <span class="keywordflow">else</span>
                <span class="keywordflow">return</span> a.second &lt; b.second;
        }

        <span class="keyword">static</span> value_type min_value() { <span class="keywordflow">return</span> value_type::min_value(); }
        <span class="keyword">static</span> value_type max_value() { <span class="keywordflow">return</span> value_type::max_value(); }
    };

    <span class="keyword">typedef</span> stxxl::tuple_less2nd&lt;skew_quad_type&gt; less_mod1;
    <span class="keyword">typedef</span> stxxl::tuple_less2nd&lt;skew_quint_type&gt; less_mod2;
<span class="comment"></span>
<span class="comment">    /** Put the (0 mod 2) [which are the 1,2 mod 3 tuples] tuples at the begin. */</span>
    <span class="keyword">struct </span>less_skew
    {
        <span class="keyword">typedef</span> skew_pair_type value_type;

        <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> value_type&amp; a, <span class="keyword">const</span> value_type&amp; b)<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">if</span> ((a.first &amp; 1) == (b.first &amp; 1))
                <span class="keywordflow">return</span> a.first &lt; b.first;
            <span class="keywordflow">else</span>
                <span class="keywordflow">return</span> (a.first &amp; 1) &lt; (b.first &amp; 1);
        }

        <span class="keyword">static</span> value_type min_value() { <span class="keywordflow">return</span> value_type::min_value(); }
        <span class="keyword">static</span> value_type max_value() { <span class="keywordflow">return</span> value_type::max_value(); }
    };
<span class="comment"></span>
<span class="comment">    /** Sort skew_quad datatype. */</span>
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> alphabet_type&gt;
    <span class="keyword">struct </span>less_quad
    {
        <span class="keyword">typedef</span> stxxl::tuple&lt;offset_type, alphabet_type, alphabet_type, alphabet_type&gt; value_type;

        <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> value_type&amp; a, <span class="keyword">const</span> value_type&amp; b)<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">if</span> (a.second == b.second) {
                <span class="keywordflow">if</span> (a.third == b.third)
                    <span class="keywordflow">return</span> a.fourth &lt; b.fourth;
                <span class="keywordflow">else</span>
                    <span class="keywordflow">return</span> a.third &lt; b.third;
            }
            <span class="keywordflow">else</span>
                <span class="keywordflow">return</span> a.second &lt; b.second;
        }

        <span class="keyword">static</span> value_type min_value() { <span class="keywordflow">return</span> value_type::min_value(); }
        <span class="keyword">static</span> value_type max_value() { <span class="keywordflow">return</span> value_type::max_value(); }
    };

<span class="comment"></span>
<span class="comment">    /** Check, if last two components of tree quads are equal. */</span>
    <span class="keyword">template</span> &lt;<span class="keyword">class</span> quad_type&gt;
    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> quad_eq(<span class="keyword">const</span> quad_type&amp; a, <span class="keyword">const</span> quad_type&amp; b)
    {
        <span class="keywordflow">return</span> (a.second == b.second) &amp;&amp; (a.third == b.third) &amp;&amp; (a.fourth == b.fourth);
    }
<span class="comment"></span>
<span class="comment">    /** Naming pipe for the conventional skew algorithm without discarding. */</span>
    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Input&gt;
    <span class="keyword">class </span>naming
    {
    <span class="keyword">public</span>:
        <span class="keyword">typedef</span> <span class="keyword">typename</span> Input::value_type quad_type;

        <span class="keyword">typedef</span> skew_pair_type value_type;

    <span class="keyword">private</span>:
        Input&amp; A;

        <span class="keywordtype">bool</span>&amp; unique;
        offset_type lexname;
        quad_type prev;
        skew_pair_type result;

    <span class="keyword">public</span>:
        naming(Input&amp; A_, <span class="keywordtype">bool</span>&amp; unique_) :
            A(A_), unique(unique_), lexname(0)
        {
            assert(!A.empty());
            unique = <span class="keyword">true</span>;

            prev = *A;
            result.first = prev.first;
            result.second = lexname;
        }

        <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">return</span> result;
        }

        naming&amp; operator ++ ()
        {
            assert(!A.empty());

            ++A;
            <span class="keywordflow">if</span> (A.empty())
                <span class="keywordflow">return</span> *<span class="keyword">this</span>;

            quad_type curr = *A;
            <span class="keywordflow">if</span> (!quad_eq(prev, curr)) {
                ++lexname;
            } <span class="keywordflow">else</span> {
                <span class="keywordflow">if</span> (!A.empty() &amp;&amp; curr.second != offset_type(0)) {
                    unique = <span class="keyword">false</span>;
                }
            }

            result.first = curr.first;
            result.second = lexname;

            prev = curr;
            <span class="keywordflow">return</span> *<span class="keyword">this</span>;
        }

        <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">return</span> A.empty();
        }
    };
<span class="comment"></span>
<span class="comment">    /** Create tuples of 2 components until one of the input streams are empty. */</span>
    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputA, <span class="keyword">class</span> InputB, const <span class="keywordtype">int</span> add_alphabet = 0&gt;
    <span class="keyword">class </span>make_pairs
    {
    <span class="keyword">public</span>:
        <span class="keyword">typedef</span> stxxl::tuple&lt;typename InputA::value_type, offset_type&gt; value_type;

    <span class="keyword">private</span>:
        InputA&amp; A;
        InputB&amp; B;
        value_type result;

    <span class="keyword">public</span>:
        make_pairs(InputA&amp; a, InputB&amp; b)
            : A(a), B(b)
        {
            assert(!A.empty());
            assert(!B.empty());
            <span class="keywordflow">if</span> (!empty()) {
                result = value_type(*A, *B + add_alphabet);
            }
        }

        <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span>
<span class="keyword">        </span>{ <span class="keywordflow">return</span> result; }

        make_pairs&amp; operator ++ ()
        {
            assert(!A.empty());
            assert(!B.empty());

            ++A;
            ++B;

            <span class="keywordflow">if</span> (!A.empty() &amp;&amp; !B.empty()) {
                result = value_type(*A, *B + add_alphabet);
            }

            <span class="keywordflow">return</span> *<span class="keyword">this</span>;
        }

        <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<span class="keyword">        </span>{ <span class="keywordflow">return</span> (A.empty() || B.empty()); }
    };

<span class="comment"></span>
<span class="comment">    /**</span>
<span class="comment">     * Collect three characters t_i, t_{i+1}, t_{i+2} beginning at the index</span>
<span class="comment">     * i. Since we need at least one unique endcaracter, we free the first</span>
<span class="comment">     * characters i.e. we map (t_i) -&gt; (i,t_i,t_{i+1},t_{i+2})</span>
<span class="comment">     *</span>
<span class="comment">     * @param Input holds all characters t_i from input string t</span>
<span class="comment">     * @param alphabet_type</span>
<span class="comment">     * @param add_alphabet</span>
<span class="comment">     */</span>
    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Input, <span class="keyword">typename</span> alphabet_type, const <span class="keywordtype">int</span> add_alphabet = 0&gt;
    <span class="keyword">class </span>make_quads
    {
    <span class="keyword">public</span>:
        <span class="keyword">typedef</span> stxxl::tuple&lt;offset_type, alphabet_type, alphabet_type, alphabet_type&gt; value_type;

    <span class="keyword">private</span>:
        Input&amp; A;
        value_type current;
        offset_type counter;
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z3z;  <span class="comment">// = counter mod 3, (&quot;+&quot;,Z/3Z) is cheaper than %</span>
        <span class="keywordtype">bool</span> finished;

        offset_array_type&amp; text;

    <span class="keyword">public</span>:
        make_quads(Input&amp; data_in_, offset_array_type&amp; text_)
            : A(data_in_),
              current(0, 0, 0, 0),
              counter(0),
              z3z(0),
              finished(false),
              text(text_)
        {
            assert(!A.empty());

            current.first = counter;
            current.second = (*A).second + add_alphabet;
            ++A;

            <span class="keywordflow">if</span> (!A.empty()) {
                current.third = (*A).second + add_alphabet;
                ++A;
            }
            <span class="keywordflow">else</span> {
                current.third = 0;
                current.fourth = 0;
            }

            <span class="keywordflow">if</span> (!A.empty()) {
                current.fourth = (*A).second + add_alphabet;
            }
            <span class="keywordflow">else</span> {
                current.fourth = 0;
            }
        }

        <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span>
<span class="keyword">        </span>{ <span class="keywordflow">return</span> current; }

        make_quads&amp; operator ++ ()
        {
            assert(!A.empty() || !finished);

            <span class="keywordflow">if</span> (current.second != offset_type(0)) {
                text.push_back(current.second);
            }

            <span class="comment">// Calculate module</span>
            <span class="keywordflow">if</span> (++z3z == 3) z3z = 0;

            current.first = ++counter;
            current.second = current.third;
            current.third = current.fourth;

            <span class="keywordflow">if</span> (!A.empty())
                ++A;

            <span class="keywordflow">if</span> (!A.empty()) {
                current.fourth = (*A).second + add_alphabet;
            }
            <span class="keywordflow">else</span> {
                current.fourth = 0;
            }

            <span class="comment">// Inserts a dummy tuple for input sizes of n%3==1</span>
            <span class="keywordflow">if</span> ((current.second == offset_type(0)) &amp;&amp; (z3z != 1)) {
                finished = <span class="keyword">true</span>;
            }

            <span class="keywordflow">return</span> *<span class="keyword">this</span>;
        }

        <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<span class="keyword">        </span>{ <span class="keywordflow">return</span> (A.empty() &amp;&amp; finished); }
    };
<span class="comment"></span>
<span class="comment">    /** Drop 1/3 of the input. More exactly the offsets at positions (0 mod</span>
<span class="comment">     * 3). Index begins with 0. */</span>
    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Input&gt;
    <span class="keyword">class </span>extract_mod12
    {
    <span class="keyword">public</span>:
        <span class="keyword">typedef</span> <span class="keyword">typename</span> Input::value_type value_type;

    <span class="keyword">private</span>:
        Input&amp; A;
        offset_type counter;
        offset_type output_counter;
        value_type result;

    <span class="keyword">public</span>:
        extract_mod12(Input&amp; A_)
            : A(A_),
              counter(0),
              output_counter(0)
        {
            assert(!A.empty());
            ++A, ++counter;  <span class="comment">// skip 0 = mod0 offset</span>
            <span class="keywordflow">if</span> (!A.empty()) {
                result = *A;
                result.first = output_counter;
            }
        }

        <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span>
<span class="keyword">        </span>{ <span class="keywordflow">return</span> result; }

        extract_mod12&amp; operator ++ ()
        {
            assert(!A.empty());

            ++A, ++counter, ++output_counter;

            <span class="keywordflow">if</span> (!A.empty() &amp;&amp; (counter % 3) == 0) {
                <span class="comment">// skip mod0 offsets</span>
                ++A, ++counter;
            }
            <span class="keywordflow">if</span> (!A.empty()) {
                result = *A;
                result.first = output_counter;
            }

            <span class="keywordflow">return</span> *<span class="keyword">this</span>;
        }

        <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<span class="keyword">        </span>{ <span class="keywordflow">return</span> A.empty(); }
    };

<span class="comment"></span>
<span class="comment">    /** Create the suffix array from the current sub problem by simple</span>
<span class="comment">     *  comparison-based merging.  More precisely: compare characters(out of</span>
<span class="comment">     *  text t) and ranks(out of ISA12) of the following constellation:</span>
<span class="comment">     *  Input constellation:</span>
<span class="comment">     *  @param Mod0 5-tuple (quint): &lt;i, t_i, t_{i+1}, ISA12[i+1], ISA12[i+2]&gt;</span>
<span class="comment">     *  @param Mod1 4-tuple (quad): &lt;i, ISA12[i], t_i, ISA12[i+1]&gt;</span>
<span class="comment">     *  @param Mod2 5-tuple (quint): &lt;i, ISA[i], t_i, t_{i+1}, ISA12[i+1]&gt;</span>
<span class="comment">     */</span>
    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Mod0, <span class="keyword">class</span> Mod1, <span class="keyword">class</span> Mod2&gt;
    <span class="keyword">class </span>merge_sa
    {
    <span class="keyword">public</span>:
        <span class="keyword">typedef</span> offset_type value_type;

    <span class="keyword">private</span>:
        Mod0&amp; A;
        Mod1&amp; B;
        Mod2&amp; C;

        skew_quint_type s0;
        skew_quad_type s1;
        skew_quint_type s2;

        <span class="keywordtype">int</span> selected;
        <span class="keywordtype">bool</span> done[3];

        offset_type index;
        offset_type merge_result;

        <span class="keywordtype">bool</span> cmp_mod1_less_mod2()
        {
            assert(!done[1] &amp;&amp; !done[2]);

            <span class="keywordflow">return</span> s1.second &lt; s2.second;
        }

        <span class="keywordtype">bool</span> cmp_mod0_less_mod2()
        {
            assert(!done[0] &amp;&amp; !done[2]);

            <span class="keywordflow">if</span> (s0.second == s2.third) {
                <span class="keywordflow">if</span> (s0.third == s2.fourth)
                    <span class="keywordflow">return</span> s0.fifth &lt; s2.fifth;
                <span class="keywordflow">else</span>
                    <span class="keywordflow">return</span> s0.third &lt; s2.fourth;
            }
            <span class="keywordflow">else</span>
                <span class="keywordflow">return</span> s0.second &lt; s2.third;
        }

        <span class="keywordtype">bool</span> cmp_mod0_less_mod1()
        {
            assert(!done[0] &amp;&amp; !done[1]);

            <span class="keywordflow">if</span> (s0.second == s1.third)
                <span class="keywordflow">return</span> s0.fourth &lt; s1.fourth;
            <span class="keywordflow">else</span>
                <span class="keywordflow">return</span> s0.second &lt; s1.third;
        }

        <span class="keywordtype">void</span> merge()
        {
            assert(!done[0] || !done[1] || !done[2]);

            <span class="keywordflow">if</span> (done[0])
            {
                <span class="keywordflow">if</span> (done[2] || (!done[1] &amp;&amp; cmp_mod1_less_mod2()))
                {
                    selected = 1;
                    merge_result = s1.first;
                }
                <span class="keywordflow">else</span>
                {
                    selected = 2;
                    merge_result = s2.first;
                }
            }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (done[1] || cmp_mod0_less_mod1())
            {
                <span class="keywordflow">if</span> (done[2] || cmp_mod0_less_mod2())
                {
                    selected = 0;
                    merge_result = s0.first;
                }
                <span class="keywordflow">else</span>
                {
                    selected = 2;
                    merge_result = s2.first;
                }
            }
            <span class="keywordflow">else</span>
            {
                <span class="keywordflow">if</span> (done[2] || cmp_mod1_less_mod2())
                {
                    selected = 1;
                    merge_result = s1.first;
                }
                <span class="keywordflow">else</span>
                {
                    selected = 2;
                    merge_result = s2.first;
                }
            }

            assert(!done[selected]);
        }

    <span class="keyword">public</span>:
        <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">return</span> (A.empty() &amp;&amp; B.empty() &amp;&amp; C.empty());
        }

        merge_sa(Mod0&amp; x1, Mod1&amp; x2, Mod2&amp; x3)
            : A(x1), B(x2), C(x3), selected(-1), index(0)
        {
            assert(!A.empty());
            assert(!B.empty());
            assert(!C.empty());
            done[0] = <span class="keyword">false</span>;
            done[1] = <span class="keyword">false</span>;
            done[2] = <span class="keyword">false</span>;
            s0 = *A;
            s1 = *B;
            s2 = *C;

            merge();
        }

        <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">return</span> merge_result;
        }

        merge_sa&amp; operator ++ ()
        {
            <span class="keywordflow">if</span> (selected == 0) {
                assert(!A.empty());
                ++A;
                <span class="keywordflow">if</span> (!A.empty())
                    s0 = *A;
                <span class="keywordflow">else</span>
                    done[0] = <span class="keyword">true</span>;
            }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (selected == 1) {
                assert(!B.empty());
                ++B;
                <span class="keywordflow">if</span> (!B.empty())
                    s1 = *B;
                <span class="keywordflow">else</span>
                    done[1] = <span class="keyword">true</span>;
            }
            <span class="keywordflow">else</span> {
                assert(!C.empty());
                assert(selected == 2);
                ++C;
                <span class="keywordflow">if</span> (!C.empty())
                    s2 = *C;
                <span class="keywordflow">else</span>
                    done[2] = <span class="keyword">true</span>;
            }

            ++index;
            <span class="keywordflow">if</span> (!empty())
                merge();

            <span class="keywordflow">return</span> *<span class="keyword">this</span>;
        }
    };

<span class="comment"></span>
<span class="comment">    /** Helper function for computing the size of the 2/3 subproblem. */</span>
    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">size_t</span> subp_size(<span class="keywordtype">size_t</span> n)
    {
        <span class="keywordflow">return</span> (n / 3) * 2 + ((n % 3) == 2);
    }
<span class="comment"></span>
<span class="comment">    /**</span>
<span class="comment">     * Sort mod0-quints / mod1-quads / mod2-quints and run merge_sa class to</span>
<span class="comment">     * merge them together.</span>
<span class="comment">     * @param S input string pipe type.</span>
<span class="comment">     * @param Mod1 mod1 tuples input pipe type.</span>
<span class="comment">     * @param Mod2 mod2 tuples input pipe type.</span>
<span class="comment">     */</span>
    <span class="keyword">template</span> &lt;<span class="keyword">class</span> S, <span class="keyword">class</span> Mod1, <span class="keyword">class</span> Mod2&gt;
    <span class="keyword">class </span>build_sa
    {
    <span class="keyword">public</span>:
        <span class="keyword">typedef</span> offset_type value_type;

        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> add_rank = 1;  <span class="comment">// free first rank to mark ranks beyond end of input</span>

    <span class="keyword">private</span>:
        <span class="comment">// mod1 types</span>
        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::use_push&lt;skew_quad_type&gt; mod1_push_type;
        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_creator&lt;mod1_push_type, less_mod1&gt; mod1_runs_type;
        <span class="keyword">typedef</span> <span class="keyword">typename</span> mod1_runs_type::sorted_runs_type sorted_mod1_runs_type;
        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_merger&lt;sorted_mod1_runs_type, less_mod1&gt; mod1_rm_type;

        <span class="comment">// mod2 types</span>
        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::use_push&lt;skew_quint_type&gt; mod2_push_type;
        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_creator&lt;mod2_push_type, less_mod2&gt; mod2_runs_type;
        <span class="keyword">typedef</span> <span class="keyword">typename</span> mod2_runs_type::sorted_runs_type sorted_mod2_runs_type;
        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_merger&lt;sorted_mod2_runs_type, less_mod2&gt; mod2_rm_type;

        <span class="comment">// mod0 types</span>
        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::use_push&lt;skew_quint_type&gt; mod0_push_type;
        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_creator&lt;mod0_push_type, less_mod0&gt; mod0_runs_type;
        <span class="keyword">typedef</span> <span class="keyword">typename</span> mod0_runs_type::sorted_runs_type sorted_mod0_runs_type;
        <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::runs_merger&lt;sorted_mod0_runs_type, less_mod0&gt; mod0_rm_type;

        <span class="comment">// Merge type</span>
        <span class="keyword">typedef</span> merge_sa&lt;mod0_rm_type, mod1_rm_type, mod2_rm_type&gt; merge_sa_type;

        <span class="comment">// Functions</span>
        less_mod0 c0;
        less_mod1 c1;
        less_mod2 c2;

        <span class="comment">// Runs merger</span>
        mod1_rm_type* mod1_result;
        mod2_rm_type* mod2_result;
        mod0_rm_type* mod0_result;

        <span class="comment">// Merger</span>
        merge_sa_type* vmerge_sa;

        <span class="comment">// Input</span>
        S&amp; source;
        Mod1&amp; mod_1;
        Mod2&amp; mod_2;

        <span class="comment">// Tmp variables</span>
        offset_type t[3];
        offset_type old_t2;
        offset_type old_mod2;
        <span class="keywordtype">bool</span> exists[3];
        offset_type mod_one;
        offset_type mod_two;

        offset_type index;

        <span class="comment">// Empty_flag</span>
        <span class="keywordtype">bool</span> ready;

        <span class="comment">// Result</span>
        value_type result;

    <span class="keyword">public</span>:
        build_sa(S&amp; source_, Mod1&amp; mod_1_, Mod2&amp; mod_2_, <span class="keywordtype">size_t</span> a_size, <span class="keywordtype">size_t</span> memsize)
            : source(source_), mod_1(mod_1_), mod_2(mod_2_), index(0), ready(false)
        {
            assert(!source_.empty());

            <span class="comment">// Runs storage</span>

            <span class="comment">// input: ISA_1,2 from previous level</span>
            mod0_runs_type mod0_runs(c0, memsize / 4);
            mod1_runs_type mod1_runs(c1, memsize / 4);
            mod2_runs_type mod2_runs(c2, memsize / 4);

            <span class="keywordflow">while</span> (!source.empty())
            {
                exists[0] = <span class="keyword">false</span>;
                exists[1] = <span class="keyword">false</span>;
                exists[2] = <span class="keyword">false</span>;

                <span class="keywordflow">if</span> (!source.empty()) {
                    t[0] = *source;
                    ++source;
                    exists[0] = <span class="keyword">true</span>;
                }

                <span class="keywordflow">if</span> (!source.empty()) {
                    assert(!mod_1.empty());
                    t[1] = *source;
                    ++source;
                    mod_one = *mod_1 + add_rank;
                    ++mod_1;
                    exists[1] = <span class="keyword">true</span>;
                }

                <span class="keywordflow">if</span> (!source.empty()) {
                    assert(!mod_2.empty());
                    t[2] = *source;
                    ++source;
                    mod_two = *mod_2 + add_rank;
                    ++mod_2;
                    exists[2] = <span class="keyword">true</span>;
                }

                <span class="comment">// Check special cases in the middle of &quot;source&quot;</span>
                <span class="comment">// Cases are cx|xc cxx|cxx and cxxc|xxc</span>

                assert(t[0] != offset_type(0));
                assert(t[1] != offset_type(0));
                assert(t[2] != offset_type(0));

                <span class="comment">// Mod 0 : (index0,char0,char1,mod1,mod2)</span>
                <span class="comment">// Mod 1 : (index1,mod1,char1,mod2)</span>
                <span class="comment">// Mod 2 : (index2,mod2)</span>

                <span class="keywordflow">if</span> (exists[2]) { <span class="comment">// Nothing is missed</span>
                    mod0_runs.push(skew_quint_type(index, t[0], t[1], mod_one, mod_two));
                    mod1_runs.push(skew_quad_type(index + 1, mod_one, t[1], mod_two));

                    <span class="keywordflow">if</span> (index != offset_type(0)) {
                        mod2_runs.push(skew_quint_type((index - 1), old_mod2, old_t2, t[0], mod_one));
                    }
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exists[1]) { <span class="comment">// Last element missed</span>
                    mod0_runs.push(skew_quint_type(index, t[0], t[1], mod_one, 0));
                    mod1_runs.push(skew_quad_type(index + 1, mod_one, t[1], 0));

                    <span class="keywordflow">if</span> (index != offset_type(0)) {
                        mod2_runs.push(skew_quint_type((index - 1), old_mod2, old_t2, t[0], mod_one));
                    }
                }
                <span class="keywordflow">else</span> { <span class="comment">// Only one element left</span>
                    assert(exists[0]);
                    mod0_runs.push(skew_quint_type(index, t[0], 0, 0, 0));

                    <span class="keywordflow">if</span> (index != offset_type(0)) {
                        mod2_runs.push(skew_quint_type((index - 1), old_mod2, old_t2, t[0], 0));
                    }
                }

                old_mod2 = mod_two;
                old_t2 = t[2];
                index += 3;
            }

            <span class="keywordflow">if</span> ((a_size % 3) == 0) { <span class="comment">// changed</span>
                <span class="keywordflow">if</span> (index != offset_type(0)) {
                    mod2_runs.push(skew_quint_type((index - 1), old_mod2, old_t2, 0, 0));
                }
            }

            mod0_runs.deallocate();
            mod1_runs.deallocate();
            mod2_runs.deallocate();

            std::cout &lt;&lt; <span class="stringliteral">&quot;merging S0 = &quot;</span> &lt;&lt; mod0_runs.size() &lt;&lt; <span class="stringliteral">&quot;, S1 = &quot;</span> &lt;&lt; mod1_runs.size()
                      &lt;&lt; <span class="stringliteral">&quot;, S2 = &quot;</span> &lt;&lt; mod2_runs.size() &lt;&lt; <span class="stringliteral">&quot; tuples&quot;</span> &lt;&lt; std::endl;

            <span class="comment">// Prepare for merging</span>

            mod0_result = <span class="keyword">new</span> mod0_rm_type(mod0_runs.result(), less_mod0(), memsize / 5);
            mod1_result = <span class="keyword">new</span> mod1_rm_type(mod1_runs.result(), less_mod1(), memsize / 5);
            mod2_result = <span class="keyword">new</span> mod2_rm_type(mod2_runs.result(), less_mod2(), memsize / 5);

            <span class="comment">// output: ISA_1,2 for next level</span>
            vmerge_sa = <span class="keyword">new</span> merge_sa_type(*mod0_result, *mod1_result, *mod2_result);

            <span class="comment">// read first suffix</span>
            result = *(*vmerge_sa);
        }

        <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">return</span> result;
        }

        build_sa&amp; operator ++ ()
        {
            assert(vmerge_sa != 0 &amp;&amp; !vmerge_sa-&gt;empty());

            ++(*vmerge_sa);
            <span class="keywordflow">if</span> (!vmerge_sa-&gt;empty()) {
                result = *(*vmerge_sa);
            }
            <span class="keywordflow">else</span> {  <span class="comment">// cleaning up</span>
                assert(vmerge_sa-&gt;empty());
                ready = <span class="keyword">true</span>;

                assert(vmerge_sa != NULL);
                <span class="keyword">delete</span> vmerge_sa, vmerge_sa = NULL;

                assert(mod0_result != NULL &amp;&amp; mod1_result != NULL &amp;&amp; mod2_result != NULL);
                <span class="keyword">delete</span> mod0_result, mod0_result = NULL;
                <span class="keyword">delete</span> mod1_result, mod1_result = NULL;
                <span class="keyword">delete</span> mod2_result, mod2_result = NULL;
            }

            <span class="keywordflow">return</span> *<span class="keyword">this</span>;
        }

        ~build_sa()
        {
            <span class="keywordflow">if</span> (vmerge_sa) <span class="keyword">delete</span> vmerge_sa;

            <span class="keywordflow">if</span> (mod0_result) <span class="keyword">delete</span> mod0_result;
            <span class="keywordflow">if</span> (mod1_result) <span class="keyword">delete</span> mod1_result;
            <span class="keywordflow">if</span> (mod2_result) <span class="keyword">delete</span> mod2_result;
        }

        <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">return</span> ready;
        }
    };
<span class="comment"></span>
<span class="comment">    /** The skew algorithm.</span>
<span class="comment">     *  @param Input type of the input pipe. */</span>
    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Input&gt;
    <span class="keyword">class </span>algorithm
    {
    <span class="keyword">public</span>:
        <span class="keyword">typedef</span> offset_type value_type;
        <span class="keyword">typedef</span> <span class="keyword">typename</span> Input::value_type alphabet_type;

    <span class="keyword">protected</span>:
        <span class="comment">// finished reading final suffix array</span>
        <span class="keywordtype">bool</span> finished;

        <span class="comment">// current recursion depth</span>
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rec_depth;

    <span class="keyword">protected</span>:
        <span class="comment">// generate (i) sequence</span>
        <span class="keyword">typedef</span> stxxl::stream::counter&lt;offset_type&gt; counter_stream_type;

        <span class="comment">// Sorter</span>
        <span class="keyword">typedef</span> stxxl::tuple_less1st&lt;skew_pair_type&gt; mod12cmp;
        <span class="keyword">typedef</span> stxxl::sorter&lt;skew_pair_type, mod12cmp&gt; mod12_sorter_type;

        <span class="comment">// Additional streaming items</span>
        <span class="keyword">typedef</span> stream::choose&lt;mod12_sorter_type, 2&gt; isa_second_type;
        <span class="keyword">typedef</span> build_sa&lt;offset_array_it_rg, isa_second_type, isa_second_type&gt; buildSA_type;
        <span class="keyword">typedef</span> make_pairs&lt;buildSA_type, counter_stream_type&gt; precompute_isa_type;

        <span class="comment">// Real recursive skew3 implementation</span>
        <span class="comment">// This part is the core of the skew algorithm and runs all class objects in their respective order</span>
        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> RecInputType&gt;
        buildSA_type * skew3(RecInputType&amp; p_Input)
        {
            <span class="comment">// (t_i) -&gt; (i,t_i,t_{i+1},t_{i+2})</span>
            <span class="keyword">typedef</span> make_quads&lt;RecInputType, offset_type, 1&gt; make_quads_input_type;

            <span class="comment">// (t_i) -&gt; (i,t_i,t_{i+1},t_{i+2}) with i = 1,2 mod 3</span>
            <span class="keyword">typedef</span> extract_mod12&lt;make_quads_input_type&gt; mod12_quads_input_type;

            <span class="comment">// sort (i,t_i,t_{i+1},t_{i+2}) by (t_i,t_{i+1},t_{i+2})</span>
            <span class="keyword">typedef</span> <span class="keyword">typename</span> stream::sort&lt;mod12_quads_input_type, less_quad&lt;offset_type&gt; &gt; sort_mod12_input_type;

            <span class="comment">// name (i,t_i,t_{i+1},t_{i+2}) -&gt; (i,n_i)</span>
            <span class="keyword">typedef</span> naming&lt;sort_mod12_input_type&gt; naming_input_type;

            mod12_sorter_type m1_sorter(mod12cmp(), ram_use / 5);
            mod12_sorter_type m2_sorter(mod12cmp(), ram_use / 5);

            <span class="comment">// sorted mod1 runs -concatenate- sorted mod2 runs</span>
            <span class="keyword">typedef</span> stxxl::stream::concatenate&lt;mod12_sorter_type, mod12_sorter_type&gt; concatenation_type;

            <span class="comment">// (t_i) -&gt; (i,t_i,t_{i+1},t_{i+2})</span>
            offset_array_type text;
            make_quads_input_type quads_input(p_Input, text);

            <span class="comment">// (t_i) -&gt; (i,t_i,t_{i+1},t_{i+2}) with i = 1,2 mod 3</span>
            mod12_quads_input_type mod12_quads_input(quads_input);

            <span class="comment">// sort (i,t_i,t_{i+1},t_{i+2}) by (t_i,t_i+1},t_{i+2})</span>
            sort_mod12_input_type sort_mod12_input(mod12_quads_input, less_quad&lt;offset_type&gt;(), ram_use / 5);

            <span class="comment">// name (i,t_i,t_{i+1},t_{i+2}) -&gt; (i,&quot;n_i&quot;)</span>
            <span class="keywordtype">bool</span> unique = <span class="keyword">false</span>;         <span class="comment">// is the current quad array unique?</span>
            naming_input_type names_input(sort_mod12_input, unique);

            <span class="comment">// create (i, s^12[i])</span>
            size_type concat_length = 0; <span class="comment">// holds length of current S_12</span>
            <span class="keywordflow">while</span> (!names_input.empty()) {
                <span class="keyword">const</span> skew_pair_type&amp; tmp = *names_input;
                <span class="keywordflow">if</span> (tmp.first &amp; 1) {
                    m2_sorter.push(tmp); <span class="comment">// sorter #2</span>
                }
                <span class="keywordflow">else</span> {
                    m1_sorter.push(tmp); <span class="comment">// sorter #1</span>
                }
                ++names_input;
                concat_length++;
            }

            std::cout &lt;&lt; <span class="stringliteral">&quot;recursion string length = &quot;</span> &lt;&lt; concat_length &lt;&lt; std::endl;

            m1_sorter.sort();
            m2_sorter.sort();

            <span class="keywordflow">if</span> (!unique)
            {
                std::cout &lt;&lt; <span class="stringliteral">&quot;not unique -&gt; next recursion level = &quot;</span> &lt;&lt; ++rec_depth &lt;&lt; std::endl;

                <span class="comment">// compute s^12 := lexname[S[1 mod 3]] . lexname[S[2 mod 3]], (also known as reduced recursion string &#39;R&#39;)</span>
                concatenation_type concat_mod1mod2(m1_sorter, m2_sorter);

                buildSA_type* recType = skew3(concat_mod1mod2);  <span class="comment">// recursion with recursion string T&#39; = concat_mod1mod2 lexnames</span>

                std::cout &lt;&lt; <span class="stringliteral">&quot;exit recursion level = &quot;</span> &lt;&lt; --rec_depth &lt;&lt; std::endl;

                counter_stream_type isa_loop_index;
                precompute_isa_type isa_pairs(*recType, isa_loop_index); <span class="comment">// add index as component =&gt; (SA12, i)</span>

                <span class="comment">// store beginning of mod2-tuples of s^12 in mod2_pos</span>
                offset_type special = (concat_length != subp_size(text.size()));
                offset_type mod2_pos = offset_type((subp_size(text.size()) &gt;&gt; 1) + (subp_size(text.size()) &amp; 1) + special);

                mod12_sorter_type isa1_pair(mod12cmp(), ram_use / 5);
                mod12_sorter_type isa2_pair(mod12cmp(), ram_use / 5);

                <span class="keywordflow">while</span> (!isa_pairs.empty()) {
                    <span class="keyword">const</span> skew_pair_type&amp; tmp = *isa_pairs;
                    <span class="keywordflow">if</span> (tmp.first &lt; mod2_pos) {
                        <span class="keywordflow">if</span> (tmp.first + special &lt; mod2_pos) <span class="comment">// else: special sentinel tuple is dropped</span>
                            isa1_pair.push(tmp);            <span class="comment">// sorter #1</span>
                    } <span class="keywordflow">else</span> {
                        isa2_pair.push(tmp);                <span class="comment">// sorter #2</span>
                    }
                    ++isa_pairs;
                }

                <span class="keyword">delete</span> recType;

                isa1_pair.finish();
                isa2_pair.finish();

                offset_array_it_rg input(text.begin(), text.end());

                <span class="comment">// =&gt; (i, ISA)</span>
                isa1_pair.sort(ram_use / 8);
                isa2_pair.sort(ram_use / 8);

                <span class="comment">// pick ISA of (i, ISA)</span>
                isa_second_type isa1(isa1_pair);
                isa_second_type isa2(isa2_pair);

                <span class="comment">// prepare and run merger</span>
                <span class="keywordflow">return</span> <span class="keyword">new</span> buildSA_type(input, isa1, isa2, text.size(), ram_use);
            }
            <span class="keywordflow">else</span> <span class="comment">// unique</span>
            {
                std::cout &lt;&lt; <span class="stringliteral">&quot;unique names!&quot;</span> &lt;&lt; std::endl;

                isa_second_type isa1(m1_sorter);
                isa_second_type isa2(m2_sorter);

                offset_array_it_rg source(text.begin(), text.end());

                <span class="comment">// prepare and run merger</span>
                <span class="keywordflow">return</span> <span class="keyword">new</span> buildSA_type(source, isa1, isa2, text.size(), ram_use);
            }
        } <span class="comment">// end of skew3()</span>

    <span class="keyword">protected</span>:
        <span class="comment">// Adapt (t_i) -&gt; (i,t_i) for input to fit to recursive call</span>
        <span class="keyword">typedef</span> make_pairs&lt;counter_stream_type, Input&gt; make_pairs_input_type;

        <span class="comment">// points to final constructed suffix array generator</span>
        buildSA_type* out_sa;

    <span class="keyword">public</span>:
        algorithm(Input&amp; data_in)
            : finished(false), rec_depth(0)
        {
            <span class="comment">// (t_i) -&gt; (i,t_i)</span>
            counter_stream_type dummy;
            make_pairs_input_type pairs_input(dummy, data_in);

            out_sa = skew3(pairs_input);
        }

        <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">return</span> *(*out_sa);
        }

        algorithm&amp; operator ++ ()
        {
            assert(out_sa);
            assert(!out_sa-&gt;empty());

            ++(*out_sa);

            <span class="keywordflow">if</span> (out_sa-&gt;empty()) {
                finished = <span class="keyword">true</span>;
                <span class="keyword">delete</span> out_sa;
                out_sa = NULL;
            }
            <span class="keywordflow">return</span> *<span class="keyword">this</span>;
        }

        ~algorithm()
        {
            <span class="keywordflow">if</span> (out_sa) <span class="keyword">delete</span> out_sa;
        }

        <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">return</span> finished;
        }
    }; <span class="comment">// algorithm class</span>
};     <span class="comment">// skew class</span>
<span class="comment"></span>
<span class="comment">//! helper to print out readable characters.</span>
<span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> alphabet_type&gt;
<span class="keyword">static</span> <span class="keyword">inline</span> std::string dumpC(alphabet_type c)
{
    std::ostringstream oss;
    <span class="keywordflow">if</span> (isalnum(c)) oss &lt;&lt; <span class="charliteral">&#39;\&#39;&#39;</span> &lt;&lt; (char)c &lt;&lt; <span class="charliteral">&#39;\&#39;&#39;</span>;
    <span class="keywordflow">else</span> oss &lt;&lt; (int)c;
    <span class="keywordflow">return</span> oss.str();
}
<span class="comment"></span>
<span class="comment">//! helper stream to cut input off a specified length.</span>
<span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputType&gt;
<span class="keyword">class </span>cut_stream
{
<span class="keyword">public</span>:<span class="comment"></span>
<span class="comment">    //! same value type as input stream</span>
<span class="comment"></span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> InputType::value_type value_type;

<span class="keyword">protected</span>:<span class="comment"></span>
<span class="comment">    //! instance of input stream</span>
<span class="comment"></span>    InputType&amp; m_input;
<span class="comment"></span>
<span class="comment">    //! counter after which the stream ends</span>
<span class="comment"></span>    size_type m_count;

<span class="keyword">public</span>:
    cut_stream(InputType&amp; input, size_type count)
        : m_input(input), m_count(count)
    { }

    <span class="keyword">const</span> value_type&amp; operator * ()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        assert(m_count &gt; 0);
        <span class="keywordflow">return</span> *m_input;
    }

    cut_stream&amp; operator ++ ()
    {
        assert(!empty());
        --m_count;
        ++m_input;
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }

    <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> (m_count == 0) || m_input.empty();
    }
};

alphabet_type unary_generator()
{
    <span class="keywordflow">return</span> <span class="charliteral">&#39;a&#39;</span>;
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> offset_type&gt;
<span class="keywordtype">int</span> process(<span class="keyword">const</span> std::string&amp; input_filename, <span class="keyword">const</span> std::string&amp; output_filename,
            size_type sizelimit,
            <span class="keywordtype">bool</span> text_output_flag, <span class="keywordtype">bool</span> check_flag, <span class="keywordtype">bool</span> input_verbatim)
{
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> block_size = <span class="keyword">sizeof</span>(offset_type) * 1024 * 1024 / 2;

    <span class="keyword">typedef</span> <span class="keyword">typename</span> stxxl::VECTOR_GENERATOR&lt;alphabet_type, 1, 2&gt;::result alphabet_vector_type;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> stxxl::VECTOR_GENERATOR&lt;offset_type, 1, 2, block_size&gt;::result offset_vector_type;

    <span class="comment">// input and output files (if supplied via command line)</span>
    stxxl::syscall_file* input_file = NULL, * output_file = NULL;

    <span class="comment">// input and output vectors for suffix array construction</span>
    alphabet_vector_type input_vector;
    offset_vector_type output_vector;

    <span class="keyword">using</span> stxxl::file;

    <span class="keywordflow">if</span> (input_verbatim)
    {
        <span class="comment">// copy input verbatim into vector</span>
        input_vector.resize(input_filename.size());
        std::copy(input_filename.begin(), input_filename.end(), input_vector.begin());
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input_filename == <span class="stringliteral">&quot;random&quot;</span>)
    {
        <span class="keywordflow">if</span> (sizelimit == std::numeric_limits&lt;size_type&gt;::max()) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;You must provide -s &lt;size&gt; for generated inputs.&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">return</span> 1;
        }

        <span class="comment">// fill input vector with random bytes</span>
        input_vector.resize(sizelimit);
        stxxl::random_number8_r rand8;
        stxxl::generate(input_vector.begin(), input_vector.end(), rand8);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input_filename == <span class="stringliteral">&quot;unary&quot;</span>)
    {
        <span class="keywordflow">if</span> (sizelimit == std::numeric_limits&lt;size_type&gt;::max()) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;You must provide -s &lt;size&gt; for generated inputs.&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">return</span> 1;
        }

        <span class="comment">// fill input vector with random bytes</span>
        input_vector.resize(sizelimit);
        stxxl::generate(input_vector.begin(), input_vector.end(), unary_generator);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">// define input file object and map input_vector to input_file (no copying)</span>
        input_file = <span class="keyword">new</span> stxxl::syscall_file(input_filename, file::RDONLY | file::DIRECT);
        alphabet_vector_type file_input_vector(input_file);
        input_vector.swap(file_input_vector);
    }

    <span class="keywordflow">if</span> (output_filename.size())
    {
        <span class="comment">// define output file object and map output_vector to output_file</span>
        output_file = <span class="keyword">new</span> stxxl::syscall_file(output_filename, file::RDWR | file::CREAT | file::DIRECT);
        offset_vector_type file_output_vector(output_file);
        output_vector.swap(file_output_vector);
    }

    <span class="comment">// I/O measurement</span>
    stxxl::stats* Stats = stxxl::stats::get_instance();
    stxxl::stats_data stats_begin(*Stats);

    <span class="comment">// construct skew class with bufreader input type</span>
    <span class="keyword">typedef</span> alphabet_vector_type::bufreader_type input_type;
    <span class="keyword">typedef</span> cut_stream&lt;input_type&gt; cut_input_type;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> skew&lt;offset_type&gt;::template algorithm&lt;cut_input_type&gt; skew_type;

    size_type size = input_vector.size();
    <span class="keywordflow">if</span> (size &gt; sizelimit) size = sizelimit;

    std::cout &lt;&lt; <span class="stringliteral">&quot;input size = &quot;</span> &lt;&lt; size &lt;&lt; std::endl;

    <span class="keywordflow">if</span> (size + 3 &gt;= std::numeric_limits&lt;offset_type&gt;::max()) {
        std::cout &lt;&lt; <span class="stringliteral">&quot;error: input is too long for selected word size!&quot;</span> &lt;&lt; std::endl;
        <span class="keywordflow">return</span> -1;
    }

    input_type input(input_vector);
    cut_input_type cut_input(input, size);
    skew_type skew(cut_input);

    <span class="comment">// make sure output vector has the right size</span>
    output_vector.resize(size);

    <span class="comment">// write suffix array stream into output vector</span>
    stream::materialize(skew, output_vector.begin(), output_vector.end());

    std::cout &lt;&lt; <span class="stringliteral">&quot;output size = &quot;</span> &lt;&lt; output_vector.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; (stxxl::stats_data(*Stats) - stats_begin); <span class="comment">// print i/o statistics</span>

    <span class="keywordflow">if</span> (text_output_flag)
    {
        std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;resulting suffix array:&quot;</span> &lt;&lt; std::endl;

        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; output_vector.size(); i++) {
            std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; output_vector[i] &lt;&lt; <span class="stringliteral">&quot; : &quot;</span>;

            <span class="comment">// We need a const reference because operator[] would write data</span>
            <span class="keyword">const</span> alphabet_vector_type&amp; cinput = input_vector;

            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; output_vector[i] + j &lt; cinput.size(); j++) {
                std::cout &lt;&lt; dumpC(cinput[output_vector[i] + j]) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
            }

            std::cout &lt;&lt; std::endl;
        }
    }

    <span class="keywordtype">int</span> ret = 0;

    <span class="keywordflow">if</span> (check_flag)
    {
        (std::cout &lt;&lt; <span class="stringliteral">&quot;checking suffix array... &quot;</span>).flush();

        <span class="keywordflow">if</span> (!sacheck_vectors(input_vector, output_vector)) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;failed!&quot;</span> &lt;&lt; std::endl;
            ret = -1;
        }
        <span class="keywordflow">else</span>
            std::cout &lt;&lt; <span class="stringliteral">&quot;ok.&quot;</span> &lt;&lt; std::endl;
    }

    <span class="comment">// close file, but have to deallocate vector first!</span>

    <span class="keywordflow">if</span> (input_file) {
        input_vector = alphabet_vector_type();
        <span class="keyword">delete</span> input_file;
    }
    <span class="keywordflow">if</span> (output_file) {
        output_vector = offset_vector_type();
        <span class="keyword">delete</span> output_file;
    }

    <span class="keywordflow">return</span> ret;
}

<span class="keywordtype">int</span> <a name="a0"></a><a class="code" href="extlp_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])
{
    stxxl::cmdline_parser cp;

    cp.set_description(<span class="stringliteral">&quot;DC3 aka skew3 algorithm for external memory suffix array construction.&quot;</span>);
    cp.set_author(<span class="stringliteral">&quot;Jens Mehnert &lt;jmehnert@mpi-sb.mpg.de&gt;, Timo Bingmann &lt;tb@panthema.net&gt;, Daniel Feist &lt;daniel.feist@student.kit.edu&gt;&quot;</span>);

    std::string input_filename, output_filename;
    size_type sizelimit = std::numeric_limits&lt;size_type&gt;::max();
    <span class="keywordtype">bool</span> text_output_flag = <span class="keyword">false</span>;
    <span class="keywordtype">bool</span> check_flag = <span class="keyword">false</span>;
    <span class="keywordtype">bool</span> input_verbatim = <span class="keyword">false</span>;
    <span class="keywordtype">unsigned</span> wordsize = 32;

    cp.add_param_string(<span class="stringliteral">&quot;input&quot;</span>, <span class="stringliteral">&quot;Path to input file (or verbatim text).\n  The special inputs &#39;random&#39; and &#39;unary&#39; generate such text on-the-fly.&quot;</span>, input_filename);
    cp.add_flag(<span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;check&quot;</span>, <span class="stringliteral">&quot;Check suffix array for correctness.&quot;</span>, check_flag);
    cp.add_flag(<span class="charliteral">&#39;t&#39;</span>, <span class="stringliteral">&quot;text&quot;</span>, <span class="stringliteral">&quot;Print out suffix array in readable text.&quot;</span>, text_output_flag);
    cp.add_string(<span class="charliteral">&#39;o&#39;</span>, <span class="stringliteral">&quot;output&quot;</span>, <span class="stringliteral">&quot;Output suffix array to given path.&quot;</span>, output_filename);
    cp.add_flag(<span class="charliteral">&#39;v&#39;</span>, <span class="stringliteral">&quot;verbatim&quot;</span>, <span class="stringliteral">&quot;Consider \&quot;input\&quot; as verbatim text to construct suffix array on.&quot;</span>, input_verbatim);
    cp.add_bytes(<span class="charliteral">&#39;s&#39;</span>, <span class="stringliteral">&quot;size&quot;</span>, <span class="stringliteral">&quot;Cut input text to given size, e.g. 2 GiB.&quot;</span>, sizelimit);
    cp.add_bytes(<span class="charliteral">&#39;M&#39;</span>, <span class="stringliteral">&quot;memuse&quot;</span>, <span class="stringliteral">&quot;Amount of RAM to use, default: 1 GiB.&quot;</span>, ram_use);
    cp.add_uint(<span class="charliteral">&#39;w&#39;</span>, <span class="stringliteral">&quot;wordsize&quot;</span>, <span class="stringliteral">&quot;Set word size of suffix array to 32, 40 or 64 bit, default: 32-bit.&quot;</span>, wordsize);

    <span class="comment">// process command line</span>
    <span class="keywordflow">if</span> (!cp.process(argc, argv))
        <span class="keywordflow">return</span> -1;

    <span class="keywordflow">if</span> (wordsize == 32)
        <span class="keywordflow">return</span> process&lt;stxxl::uint32&gt;(input_filename, output_filename, sizelimit,
                                      text_output_flag, check_flag, input_verbatim);
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wordsize == 40)
        <span class="keywordflow">return</span> process&lt;stxxl::uint40&gt;(input_filename, output_filename, sizelimit,
                                      text_output_flag, check_flag, input_verbatim);
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wordsize == 64)
        <span class="keywordflow">return</span> process&lt;stxxl::uint64&gt;(input_filename, output_filename, sizelimit,
                                      text_output_flag, check_flag, input_verbatim);
    <span class="keywordflow">else</span>
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Invalid wordsize for suffix array: 32, 40 or 64 are allowed.&quot;</span> &lt;&lt; std::endl;

    <span class="keywordflow">return</span> -1;
}
</pre></div> </div><!-- contents -->
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Sat Jun 14 2014 01:55:17 for ExtLP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
